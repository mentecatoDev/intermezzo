{"config":{"lang":["es"],"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"Intermezzo Entornos Virtuales La tortuga que dibuja Bots de telegram en Python","title":"Intermezzo"},{"location":"#intermezzo","text":"","title":"Intermezzo"},{"location":"#entornos-virtuales","text":"","title":"Entornos Virtuales"},{"location":"#la-tortuga-que-dibuja","text":"","title":"La tortuga que dibuja"},{"location":"#bots-de-telegram-en-python","text":"","title":"Bots de telegram en Python"},{"location":"1200_alumnos_Google/","text":"Gestionar las cuentas de usuario de un colegio de 1200 alumnos con Python y La API de Google Goyo Regalado Follow Oct 13, 2019 \u00b7 13 min read Actualmente trabajo como jefe de estudios de un centro escolar en Tenerife. Nuestro centro dispone del servicio G-Suite for education de google. Tenemos 1200 alumnos y unos 70 profesores. Nuestro equipo TIC dispone exactamente de una hora semanal para gestionar el acceso de estas 1270 personas. Esta es la historia sobre c\u00f3mo lo hacemos y he decidido escribirla s\u00f3lo por si es de utilidad para alguien que pueda encontrarse en la misma situaci\u00f3n. Todo el c\u00f3digo est\u00e1 publicado en mi repositorio de gitlab y desde este momento es tan suyo como m\u00edo. Desde el punto de vista del equipo TIC, lo que nos vendr\u00eda bien es disponer de un esbirro, pero como la palabreja tiene connotaciones negativas, decidimos llamar a este proyecto \u201cSecuaz\u201d. Imagen de Nino Car\u00e8 en Pixabay Descargo de responsabilidades Ante todo me gustar\u00eda comenzar indic\u00e1ndoles que no puedo garantizar que este c\u00f3digo vaya a resolver sus problemas, ni tampoco que no vaya a producir ning\u00fan tipo de p\u00e9rdida de datos en su instituci\u00f3n. Puedo garantizarles que ha sido desarrollado intentando atender a todas las posibles causas de error y tambi\u00e9n que se ha escrito con la mejor de las voluntades, pero si se l\u00eda parda por utilizarlo\u2026 \u00a1El que avisa no es traidor! Piensen que este es el resultado de un proyecto elaborado durante mi tiempo libre y por el placer de aprender y experimentar. Seguro que un equipo de profesionales con dedicaci\u00f3n plena encontrar\u00e1 soluciones mejores que la m\u00eda, si es as\u00ed, no duden en compartirla con todos nosotros y, a lo mejor, terminamos teniendo la herramienta que necesitamos todos ;) He intentado testear todo lo posible este proyecto, pero no les puedo garantizar una cobertura del 100% del c\u00f3digo, sigo trabajando sobre \u00e9l y, en cuanto pueda, generar\u00e9 mocks para toda la parte del acceso a la API de google, de momento, les garantizo que he hecho todo lo que he podido con el poquito tiempo de que dispongo (Tambi\u00e9n les invito a ayudarme con eso) Un poco de contexto Las decisiones de dise\u00f1o que he tomado pueden parecer un tanto ins\u00f3litas, pero creo que est\u00e1n justificadas. Vamos a ver cu\u00e1l es el contexto en el que se desarrolla este proyecto. Como centro escolar de la Comunidad Aut\u00f3noma de Canarias, estamos obligados a utilizar una herramienta que se llama Pincel Ekade. Estoy seguro de que est\u00e1 repleta de endpoints, API\u2019s y servicios web, pero yo no tengo acceso a ninguno as\u00ed que tenemos que buscar una soluci\u00f3n creativa para acceder a los datos. Esta soluci\u00f3n creativa tiene que cumplir con algunas premisas: Tiene que ser \u00e1gil. No puede conllevar gran procesamiento. Debe ser f\u00e1cil de usar. La idea es que desde secretar\u00eda se pueda notificar la aparici\u00f3n de un nuevo alumno y que esto desencadene autom\u00e1ticamente la generaci\u00f3n de su cuenta de usuario y la matr\u00edcula en los cursos definidos en Classroom para las asignaturas de las que est\u00e1 matriculado. Debe limitar la intervenci\u00f3n humana al m\u00ednimo posible, recuerden, todo esto (y mucho m\u00e1s \u2026 ) se gestiona con s\u00f3lo una hora semanal efectiva de trabajo. Deber\u00eda garantizar que todos los usuarios cambian su contrase\u00f1a en el primer inicio de sesi\u00f3n. No queremos disponer de las credenciales de acceso de ning\u00fan miembro de nuestra comunidad educativa. Si un estudiante de nuestra instituci\u00f3n ya dispone de una cuenta corporativa, deber\u00eda poder continuar utiliz\u00e1ndola. Ya que estamos, habr\u00eda que agrupar a los usuarios por clases, de manera que dispongamos de grupos de correo que permitan que nuestros docentes puedan llevar a cabo comunicaciones masivas entre sus alumnos de la manera m\u00e1s c\u00f3moda posible. Nuestra soluci\u00f3n no debe permitir que salgan datos de nuestra infraestructura, limitando el uso de archivos temporales. Debe generarse una circular informativa por cada alumno en la que se muestre su correo electr\u00f3nico, su contrase\u00f1a inicial, que ser\u00e1 temporal e informaci\u00f3n para las familias sobre las condiciones de uso de esta plataforma. \u00bfDe d\u00f3nde me saco yo estos datos? Teniendo en cuenta los requisitos y las restricciones s\u00f3lo se me ocurri\u00f3 una posibilidad. \u00bfY si utilizamos una hoja de c\u00e1lculo de Google Docs almacenada en una unidad compartida de nuestro drive? Podr\u00edamos compartirla con el usuario espec\u00edfico de secretar\u00eda y una cuenta generada ex-profeso para la aplicaci\u00f3n. \u00bfTiene realmente sentido esto? Sin duda alguna s\u00ed. M\u00e1s de uno debe estar revolvi\u00e9ndose en la silla. Dejen que me explique. La aplicaci\u00f3n que me ofrece la consejer\u00eda de educaci\u00f3n puede disponer de API\u2019s, etc \u2026 pero a mi no me consta y no tengo acceso a su documentaci\u00f3n, sin embargo, s\u00ed que exporta listados personalizados de alumnos en diversos formatos de hojas de c\u00e1lculo. Por otro lado, no tengo ni tiempo ni ganas de estar pendiente de este proceso y mis compa\u00f1eras de secretar\u00eda tambi\u00e9n est\u00e1n hasta arriba de trabajo, pero saben usar perfectamente una hoja de c\u00e1lculo. \u00bfPor qu\u00e9 no aprovechar esta circunstancia? El primer paso fue definir la salida desde Pincel Ekade. Tras dedicar un rato a pensar llegamos a la conclusi\u00f3n de que necesit\u00e1bamos s\u00f3lo un subconjunto de todos los datos disponibles. Los campos seleccionados para la exportaci\u00f3n B\u00e1sicamente nos quedamos con el c\u00f3digo que establece la administraci\u00f3n educativa para cada alumno, su nombre, el nivel educativo en el que est\u00e1 matriculado, la clase concreta en la que se encuentra el estudiante, si es repetidor o no, si est\u00e1 matriculado del curso completo y la lista de asignaturas en las que est\u00e1 matriculado y las asignaturas que pudiera tener pendientes de cursos anteriores. Esta aplicaci\u00f3n de la administraci\u00f3n permite definir informes personalizados, as\u00ed que no hay que estar constantemente seleccionando columnas, el orden de salida ni nada por el estilo. Se define una vez y se exporta las que hagan falta. No es poca informaci\u00f3n, pero s\u00ed es la m\u00ednima que necesitamos para cumplir con nuestro objetivo. La idea es que cada vez que haya una modificaci\u00f3n, mis compa\u00f1eras simplemente exporten los datos y sin tener que volverse locas, copien la salida directamente en esta hoja de c\u00e1lculo. Nuestra aplicaci\u00f3n deber\u00eda ser capaz de detectar los cambios y aplicarlos. El caso de los profesores es parecido, pero este listado es mucho menos din\u00e1mico que el de alumnos. Hemos optado por un archivo generado manualmente que representa una asignatura impartida por cada profesor en cada fila de la hoja de c\u00e1lculo. Las cuentas de los profesores siempre estar\u00e1n creadas antes del inicio de la importaci\u00f3n as\u00ed que identificaremos a cada profesor con su correo electr\u00f3nico corporativo para evitar la ambig\u00fcedad. Este fichero cambia mucho menos que el de alumnos, as\u00ed que lo elaboramos una vez durante el curso y probablemente se mantendr\u00e1. El aspecto final del directorio dentro de nuestro drive, con todos los ficheros necesarios para mantener todas las cuentas de usuario de nuestro colegio es este: Con estas dos hojas de c\u00e1lculo podemos gestionar todas las cuentas de usuario. Otra cosa importante es que los nombres de los ficheros y de los directorios son totalmente irrelevantes, porque desde la API vamos a acceder a ellos a trav\u00e9s de un identificador. \u00bfC\u00f3mo hago para que mi script acceda a los datos? La autenticaci\u00f3n de los usuarios as\u00ed como el control de acceso a la API de google depende de que nuestro administrador de G-Suite nos conceda acceso a cada elemento de la API. Pero una vez hecho esto ya no nos tendremos que preocupar m\u00e1s. En la propia documentaci\u00f3n de la API dispones de un bot\u00f3n que permite habilitar cada una de las API\u2019s. Secuaz va a utilizar varias API\u2019s de manera simult\u00e1nea, les dejo los enlaces a la documentaci\u00f3n de cada una de ellas donde podr\u00e1n habilitarlas. API de hojas de c\u00e1lculo: https://developers.google.com/sheets/api/quickstart/python API de google directory: https://developers.google.com/admin-sdk/directory/v1/quickstart/python?refresh=1 API de google classroom: https://developers.google.com/classroom/quickstart/python API de google docs: https://developers.google.com/docs/api/quickstart/python En la versi\u00f3n actual de Secuaz, no utilizamos la \u00faltima API, hemos descubierto que un complemento para las hojas de c\u00e1lculo de Google Docs cumple con casi todos los requisitos, no tenemos mucho tiempo para reinventar ruedas, as\u00ed que optamos por generar las circulares con las credenciales utilizando Autocrat . Si no lo conoces a\u00fan, te garantizo que te va a dar m\u00e1s de una alegr\u00eda. Al habilitar cada API, vas a tener acceso a un cuadro de di\u00e1logo en el que podr\u00e1s ver tus credenciales o descargarlas en formato JSON. Dado que nuestra intenci\u00f3n es que la ejecuci\u00f3n de este servicio sea totalmente desatendida, lo que hacemos es descargar el JSON para cada uno. Esto en si mismo, no es realmente necesario, podemos tener un \u00fanico JSON para toda la aplicaci\u00f3n, de hecho finalmente ser\u00e1 as\u00ed, pero de cara a probar los m\u00f3dulos de manera individual creo que es mucho m\u00e1s c\u00f3modo. Utilizando el bot\u00f3n Download client configuration podr\u00e1s descargarte tus credenciales en formato JSON \u00bfC\u00f3mo se lleva a cabo el control de acceso? Una de las cosas que m\u00e1s me sorprendi\u00f3 es el modelo de autenticaci\u00f3n de usuarios. B\u00e1sicamente lo que hacemos para autenticar los accesos a la API es lo siguiente. Una aplicaci\u00f3n que ya ha sido autenticada debe disponer de un archivo serializado, en nuestro caso utilizamos el m\u00f3dulo pickle. Este archivo contiene el Token para la app. Lo curioso ocurre cuando a\u00fan no disponemos de ese Token. Si ejecutamos nuestro c\u00f3digo, utilizaremos parte del m\u00f3dulo google_auth_oauthlib_flow. La clase InstalledAppFlow dispone de un m\u00e9todo \u201cfrom_clients_secrets_file\u201d lo que hace es tomar como argumento nuestro archivo de credenciales, es decir, el JSON que nos descargamos en el apartado anterior y nos devuelve un objeto Flow. El objeto Flow dispone de un m\u00e9todo run_local_server , si ejecutamos esto en un sistema con entorno gr\u00e1fico, se nos abrir\u00e1 una ventana del navegador en la que tendremos que introducir nuestro correo y nuestra contrase\u00f1a del dominio asociado a G-Suite for education. Realmente podr\u00edamos utilizar un m\u00e9todo alternativo, concretamente run_console que muestra una URL al usuario en consola para que lo pegue manualmente en un navegador, se autentique con su cuenta de usuario y contrase\u00f1a y obtenga un c\u00f3digo que tendr\u00e1 que escribir en la misma consola. Con cualquiera de las dos alternativas lo que vamos a obtener son las credenciales OAuth2.0 que serializaremos y almacenaremos localmente para garantizar que, a partir de ese momento, no sea necesaria m\u00e1s intervenci\u00f3n humana. El c\u00f3digo que les muestro ya incluye la funcionalidad para \u201crefrescar\u201d un token que haya caducado. Parte del c\u00f3digo del archivo auth.py Por motivos evidentes, ninguno de los archivos relativos a credenciales est\u00e1 en el repositorio de gitlab, la ruta donde la aplicaci\u00f3n buscar\u00e1 estos archivos es configurable. La funci\u00f3n check_auth nos devuelve un objeto service que ser\u00e1 el que nos permitir\u00e1 acceder a los endpoints de las distintas API\u2019s Fragmento de main.py donde obtenemos un objeto por cada API que utilizamos. Los scopes El \u00faltimo argumento de nuestra funci\u00f3n check_auth son los SCOPES para los que estamos solicitando autorizaci\u00f3n. B\u00e1sicamente es una manera de segmentar el grado de autorizaci\u00f3n que tiene nuestra aplicaci\u00f3n a la hora de interactuar con cada API. Puedes garantizar acceso de s\u00f3lo lectura a algunas API\u2019s y permitir que se lleven a cabo borrados y modificaciones en otras. \u00c1mbitos de autorizaci\u00f3n de Secuaz Traduciendo un poco estos Scopes podr\u00edamos decir que estamos dando permiso para leer, crear, modificar y borrar tanto hojas de c\u00e1lculo como documentos de nuestro Drive, podemos tambi\u00e9n hacer todo tipo de operaciones CRUD sobre los usuarios de nuestro dominio y sobre los grupos y sobre los cursos de classroom. No son pocos permisos, pero para la tarea que tenemos entre manos s\u00ed son los m\u00ednimos. Gesti\u00f3n de la configuraci\u00f3n Otro de los grandes escollos que hemos tenido que sortear en esta herramienta es la gesti\u00f3n de la configuraci\u00f3n. Nos lo podr\u00edamos haber ahorrado, pero habr\u00eda hecho que Secuaz no pudiera utilizarse en otros centros educativos y que, el pr\u00f3ximo a\u00f1o, hubiera que modificar el c\u00f3digo otra vez. Para evitar esto hemos tenido que recurrir a un m\u00f3dulo que desconoc\u00eda totalmente pero que, me sugirieron los amigos del grupo Python Canarias (desde aqu\u00ed muchas gracias por estar siempre ah\u00ed) El m\u00f3dulo se llama prettyconf y permite leer e interpretar distintos formatos de archivos de configuraci\u00f3n. Como les dec\u00eda hace un momento, no conoc\u00eda este m\u00f3dulo y seguro que se puede profundizar mucho m\u00e1s en su utilizaci\u00f3n, pero para el caso que me ocupaba, lo que hice fue recurrir a ficheros en formato .env Toda la configuraci\u00f3n de la aplicaci\u00f3n, de momento, puede resumirse en estos valores: Un ejemplo de archivo de configuraci\u00f3n para Secuaz Creo que los nombres de las variables son bastante autoexplicativos, perdonen el spanglish pero hay una parte de la configuraci\u00f3n, que puede ser \u00fatil para todos los que trabajen en Canarias, por eso la he dejado as\u00ed. Los seis primeros par\u00e1metros tienen que ver con los distintos archivos que utilizaremos en Drive, como son hojas de c\u00e1lculo, incluimos el ID del archivo y el rango de datos en formato A1 sobre el que vamos a trabajar. Sobre el ID de los archivos de Drive, me gustar\u00eda hacer una aclaraci\u00f3n, se trata de un valor que es parte de la URL para compartir que nos ofrece la interfaz web de Drive, se las se\u00f1alo en la siguiente imagen para que vean de d\u00f3nde sale. El ID del fichero es la cadena alfanum\u00e9rica que aparece tras el \u201cid=\u201d suele ser bastante larga B\u00e1sicamente tendr\u00e1s que copiar el valor del par\u00e1metro id de esa URL, ojo que en la imagen aparece cortado, suele ser bastante m\u00e1s largo. Importaci\u00f3n de profesores Bueno, entrando en materia, lo que secuaz hace en cada ciclo de generaci\u00f3n de cuentas es bastante b\u00e1sico y puede dividirse en dos procesos: El proceso de gesti\u00f3n de profesores y el proceso de gesti\u00f3n de alumnos Durante el proceso de gesti\u00f3n de profesores no se lleva a cabo ninguna creaci\u00f3n de cuentas del dominio, se presupone que todos han sido creados manualmente. Lo primero que hacemos es leer la hoja de c\u00e1lculo de nuestro Drive y crear un macro-diccionario en memoria. Las claves de este diccionario ser\u00e1n los correos electr\u00f3nicos de los docentes. Asociaremos a cada correo electr\u00f3nico el nombre de cada profesor y las asignaturas que imparte, los nombres de sus asignaturas se han normalizado, de manera que este identificador contenga informaci\u00f3n sobre la etapa, curso y secci\u00f3n. Una vez disponemos de ese s\u00faper diccionario, lo que hacemos es recorrerlo clave a clave, verificando que el usuario forma parte del grupo de profesores de classroom del dominio y si no es as\u00ed insert\u00e1ndolo. En nuestro classroom, si no eres miembro de este grupo no puedes ser profesor de ning\u00fan curso. Finalmente matriculamos a cada docente en su curso. Esto tiene alg\u00fan truco, el primer profesor que aparezca relacionado con un curso ser\u00e1 el propietario del mismo en classroom y el resto ser\u00e1n profesores adicionales. Esto que parece una chorrada es important\u00edsimo, hasta que el profesor propietario no acepte su curso en la interfaz web de classroom, el resto no podr\u00e1n verlo. Por otro lado, nos abre la puerta a configuraciones creativas del equipo docente, por ejemplo, puedo generar un grupo en el que impartan clases varios profesores, ya sea en formato s\u00faper-aula o para desarrollar proyectos multidisciplinares. Importaci\u00f3n de alumnos La importaci\u00f3n de alumnos es un poco m\u00e1s compleja. Una vez que leemos el contenido de la hoja de c\u00e1lculo de nuestro drive, lo primero que hacemos es calcular el hash para esta estructura en memoria. Si en el disco de nuestra m\u00e1quina existiera un archivo con un hash previo los comparar\u00edamos para ver si ha habido alg\u00fan cambio en todo el bloque de definici\u00f3n de alumnos. Si los hashes coinciden, no tendremos que realizar ninguna nueva operaci\u00f3n. Si por el contrario, el hash almacenado y el que acabamos de calcular fueran distintos, esto nos indicar\u00eda que alguno de los registros de la hoja de c\u00e1lculo han cambiado. Si ha habido una sincronizaci\u00f3n previa, en memoria almacenamos la lista del alumnado a la que le hemos calculado un hash por registro, de esta manera podemos saber qu\u00e9 fila del archivo es la que se ha modificado para intervenir s\u00f3lo en esta. Para cada nuevo registro o registro modificado continuamos con los siguientes pasos. En primer lugar intentamos determinar si ya existe una cuenta en nuestro dominio para este estudiante. Si existe, generamos una nueva contrase\u00f1a aleatoria, forzamos que deba cambiarla en el pr\u00f3ximo inicio de sesi\u00f3n y continuamos con el proceso de matriculaci\u00f3n en classroom. Si no existiera cuenta previamente, se crear\u00eda y se forzar\u00eda el cambio de contrase\u00f1a en el primer inicio de sesi\u00f3n. En cualquiera de los dos procesos anteriores lo que hacemos es matricular a cada alumno en la lista de asignaturas con la que se relaciona. A parte de eso, se le har\u00e1 miembro de un grupo del dominio que tendr\u00e1 el nombre de su grupo de clase. Esto nos facilitar\u00e1 en gran medida la comunicaci\u00f3n con grupos completos. Generaci\u00f3n de autorizaciones y distribuci\u00f3n de credenciales Al terminar cada ciclo de importaci\u00f3n, se generan nuevas filas en una hoja de c\u00e1lculo de drive. La pinta que tiene este archivo de salida es la siguiente. Archivo de salida en drive con las credenciales temporales de los usuarios Utilizando el complemento Autocrat es muy sencillo hacer circulares personalizadas para cada alumno con el texto de autorizaci\u00f3n de las familias. Conclusiones Este curso hemos utilizado por primera vez a nuestro \u201cSecuaz\u201d, en dos a\u00f1os hemos mejorado en casi dos meses el tiempo de configuraci\u00f3n de todas nuestras plataformas de elearning y la asignaci\u00f3n autom\u00e1tica de alumnos y profesores a cursos. Sin embargo, creo que esto s\u00f3lo ha sido un paso m\u00e1s hacia la herramienta ideal. Las l\u00edneas de trabajo futuras creo que deben ser las siguientes: Terminar el c\u00f3digo de sincronizaci\u00f3n para garantizar que sea totalmente desatendida. A\u00fan hay algunas dificultades con los registros modificados. Deber\u00edamos poder configurar la asignaci\u00f3n de asignaturas optativas, esta parte a\u00fan es manual. La generaci\u00f3n de todas las cuentas para este curso llev\u00f3 m\u00e1s de ocho horas seguidas, habr\u00eda que paralelizar los accesos a la API para mejorar estos tiempos. Necesitamos un sistema de logs normalizados. Una interfaz web agradable permitir\u00eda que otras personas sin conocimientos t\u00e9cnicos pudieran hacerse cargo de este proceso. Agradecimientos Si hacemos esto es porque creemos que es \u00fatil a nuestros alumnos y a nuestros compa\u00f1eros y estamos muy orgullosos de poder trabajar con todos ellos. Es un privilegio trabajar cada d\u00eda con personas que se toman tan en serio la educaci\u00f3n as\u00ed que: compa\u00f1eros y compa\u00f1eras, va por ustedes ;) Fuente","title":"Gestionar las cuentas de usuario de un colegio de 1200 alumnos con Python y La API de Google"},{"location":"1200_alumnos_Google/#gestionar-las-cuentas-de-usuario-de-un-colegio-de-1200-alumnos-con-python-y-la-api-de-google","text":"Goyo Regalado Follow Oct 13, 2019 \u00b7 13 min read Actualmente trabajo como jefe de estudios de un centro escolar en Tenerife. Nuestro centro dispone del servicio G-Suite for education de google. Tenemos 1200 alumnos y unos 70 profesores. Nuestro equipo TIC dispone exactamente de una hora semanal para gestionar el acceso de estas 1270 personas. Esta es la historia sobre c\u00f3mo lo hacemos y he decidido escribirla s\u00f3lo por si es de utilidad para alguien que pueda encontrarse en la misma situaci\u00f3n. Todo el c\u00f3digo est\u00e1 publicado en mi repositorio de gitlab y desde este momento es tan suyo como m\u00edo. Desde el punto de vista del equipo TIC, lo que nos vendr\u00eda bien es disponer de un esbirro, pero como la palabreja tiene connotaciones negativas, decidimos llamar a este proyecto \u201cSecuaz\u201d. Imagen de Nino Car\u00e8 en Pixabay","title":"Gestionar las cuentas de usuario de un colegio de 1200 alumnos con Python y La API de Google"},{"location":"1200_alumnos_Google/#descargo-de-responsabilidades","text":"Ante todo me gustar\u00eda comenzar indic\u00e1ndoles que no puedo garantizar que este c\u00f3digo vaya a resolver sus problemas, ni tampoco que no vaya a producir ning\u00fan tipo de p\u00e9rdida de datos en su instituci\u00f3n. Puedo garantizarles que ha sido desarrollado intentando atender a todas las posibles causas de error y tambi\u00e9n que se ha escrito con la mejor de las voluntades, pero si se l\u00eda parda por utilizarlo\u2026 \u00a1El que avisa no es traidor! Piensen que este es el resultado de un proyecto elaborado durante mi tiempo libre y por el placer de aprender y experimentar. Seguro que un equipo de profesionales con dedicaci\u00f3n plena encontrar\u00e1 soluciones mejores que la m\u00eda, si es as\u00ed, no duden en compartirla con todos nosotros y, a lo mejor, terminamos teniendo la herramienta que necesitamos todos ;) He intentado testear todo lo posible este proyecto, pero no les puedo garantizar una cobertura del 100% del c\u00f3digo, sigo trabajando sobre \u00e9l y, en cuanto pueda, generar\u00e9 mocks para toda la parte del acceso a la API de google, de momento, les garantizo que he hecho todo lo que he podido con el poquito tiempo de que dispongo (Tambi\u00e9n les invito a ayudarme con eso)","title":"Descargo de responsabilidades"},{"location":"1200_alumnos_Google/#un-poco-de-contexto","text":"Las decisiones de dise\u00f1o que he tomado pueden parecer un tanto ins\u00f3litas, pero creo que est\u00e1n justificadas. Vamos a ver cu\u00e1l es el contexto en el que se desarrolla este proyecto. Como centro escolar de la Comunidad Aut\u00f3noma de Canarias, estamos obligados a utilizar una herramienta que se llama Pincel Ekade. Estoy seguro de que est\u00e1 repleta de endpoints, API\u2019s y servicios web, pero yo no tengo acceso a ninguno as\u00ed que tenemos que buscar una soluci\u00f3n creativa para acceder a los datos. Esta soluci\u00f3n creativa tiene que cumplir con algunas premisas: Tiene que ser \u00e1gil. No puede conllevar gran procesamiento. Debe ser f\u00e1cil de usar. La idea es que desde secretar\u00eda se pueda notificar la aparici\u00f3n de un nuevo alumno y que esto desencadene autom\u00e1ticamente la generaci\u00f3n de su cuenta de usuario y la matr\u00edcula en los cursos definidos en Classroom para las asignaturas de las que est\u00e1 matriculado. Debe limitar la intervenci\u00f3n humana al m\u00ednimo posible, recuerden, todo esto (y mucho m\u00e1s \u2026 ) se gestiona con s\u00f3lo una hora semanal efectiva de trabajo. Deber\u00eda garantizar que todos los usuarios cambian su contrase\u00f1a en el primer inicio de sesi\u00f3n. No queremos disponer de las credenciales de acceso de ning\u00fan miembro de nuestra comunidad educativa. Si un estudiante de nuestra instituci\u00f3n ya dispone de una cuenta corporativa, deber\u00eda poder continuar utiliz\u00e1ndola. Ya que estamos, habr\u00eda que agrupar a los usuarios por clases, de manera que dispongamos de grupos de correo que permitan que nuestros docentes puedan llevar a cabo comunicaciones masivas entre sus alumnos de la manera m\u00e1s c\u00f3moda posible. Nuestra soluci\u00f3n no debe permitir que salgan datos de nuestra infraestructura, limitando el uso de archivos temporales. Debe generarse una circular informativa por cada alumno en la que se muestre su correo electr\u00f3nico, su contrase\u00f1a inicial, que ser\u00e1 temporal e informaci\u00f3n para las familias sobre las condiciones de uso de esta plataforma.","title":"Un poco de contexto"},{"location":"1200_alumnos_Google/#de-donde-me-saco-yo-estos-datos","text":"Teniendo en cuenta los requisitos y las restricciones s\u00f3lo se me ocurri\u00f3 una posibilidad. \u00bfY si utilizamos una hoja de c\u00e1lculo de Google Docs almacenada en una unidad compartida de nuestro drive? Podr\u00edamos compartirla con el usuario espec\u00edfico de secretar\u00eda y una cuenta generada ex-profeso para la aplicaci\u00f3n. \u00bfTiene realmente sentido esto? Sin duda alguna s\u00ed. M\u00e1s de uno debe estar revolvi\u00e9ndose en la silla. Dejen que me explique. La aplicaci\u00f3n que me ofrece la consejer\u00eda de educaci\u00f3n puede disponer de API\u2019s, etc \u2026 pero a mi no me consta y no tengo acceso a su documentaci\u00f3n, sin embargo, s\u00ed que exporta listados personalizados de alumnos en diversos formatos de hojas de c\u00e1lculo. Por otro lado, no tengo ni tiempo ni ganas de estar pendiente de este proceso y mis compa\u00f1eras de secretar\u00eda tambi\u00e9n est\u00e1n hasta arriba de trabajo, pero saben usar perfectamente una hoja de c\u00e1lculo. \u00bfPor qu\u00e9 no aprovechar esta circunstancia? El primer paso fue definir la salida desde Pincel Ekade. Tras dedicar un rato a pensar llegamos a la conclusi\u00f3n de que necesit\u00e1bamos s\u00f3lo un subconjunto de todos los datos disponibles. Los campos seleccionados para la exportaci\u00f3n B\u00e1sicamente nos quedamos con el c\u00f3digo que establece la administraci\u00f3n educativa para cada alumno, su nombre, el nivel educativo en el que est\u00e1 matriculado, la clase concreta en la que se encuentra el estudiante, si es repetidor o no, si est\u00e1 matriculado del curso completo y la lista de asignaturas en las que est\u00e1 matriculado y las asignaturas que pudiera tener pendientes de cursos anteriores. Esta aplicaci\u00f3n de la administraci\u00f3n permite definir informes personalizados, as\u00ed que no hay que estar constantemente seleccionando columnas, el orden de salida ni nada por el estilo. Se define una vez y se exporta las que hagan falta. No es poca informaci\u00f3n, pero s\u00ed es la m\u00ednima que necesitamos para cumplir con nuestro objetivo. La idea es que cada vez que haya una modificaci\u00f3n, mis compa\u00f1eras simplemente exporten los datos y sin tener que volverse locas, copien la salida directamente en esta hoja de c\u00e1lculo. Nuestra aplicaci\u00f3n deber\u00eda ser capaz de detectar los cambios y aplicarlos. El caso de los profesores es parecido, pero este listado es mucho menos din\u00e1mico que el de alumnos. Hemos optado por un archivo generado manualmente que representa una asignatura impartida por cada profesor en cada fila de la hoja de c\u00e1lculo. Las cuentas de los profesores siempre estar\u00e1n creadas antes del inicio de la importaci\u00f3n as\u00ed que identificaremos a cada profesor con su correo electr\u00f3nico corporativo para evitar la ambig\u00fcedad. Este fichero cambia mucho menos que el de alumnos, as\u00ed que lo elaboramos una vez durante el curso y probablemente se mantendr\u00e1. El aspecto final del directorio dentro de nuestro drive, con todos los ficheros necesarios para mantener todas las cuentas de usuario de nuestro colegio es este: Con estas dos hojas de c\u00e1lculo podemos gestionar todas las cuentas de usuario. Otra cosa importante es que los nombres de los ficheros y de los directorios son totalmente irrelevantes, porque desde la API vamos a acceder a ellos a trav\u00e9s de un identificador.","title":"\u00bfDe d\u00f3nde me saco yo estos datos?"},{"location":"1200_alumnos_Google/#como-hago-para-que-mi-script-acceda-a-los-datos","text":"La autenticaci\u00f3n de los usuarios as\u00ed como el control de acceso a la API de google depende de que nuestro administrador de G-Suite nos conceda acceso a cada elemento de la API. Pero una vez hecho esto ya no nos tendremos que preocupar m\u00e1s. En la propia documentaci\u00f3n de la API dispones de un bot\u00f3n que permite habilitar cada una de las API\u2019s. Secuaz va a utilizar varias API\u2019s de manera simult\u00e1nea, les dejo los enlaces a la documentaci\u00f3n de cada una de ellas donde podr\u00e1n habilitarlas. API de hojas de c\u00e1lculo: https://developers.google.com/sheets/api/quickstart/python API de google directory: https://developers.google.com/admin-sdk/directory/v1/quickstart/python?refresh=1 API de google classroom: https://developers.google.com/classroom/quickstart/python API de google docs: https://developers.google.com/docs/api/quickstart/python En la versi\u00f3n actual de Secuaz, no utilizamos la \u00faltima API, hemos descubierto que un complemento para las hojas de c\u00e1lculo de Google Docs cumple con casi todos los requisitos, no tenemos mucho tiempo para reinventar ruedas, as\u00ed que optamos por generar las circulares con las credenciales utilizando Autocrat . Si no lo conoces a\u00fan, te garantizo que te va a dar m\u00e1s de una alegr\u00eda. Al habilitar cada API, vas a tener acceso a un cuadro de di\u00e1logo en el que podr\u00e1s ver tus credenciales o descargarlas en formato JSON. Dado que nuestra intenci\u00f3n es que la ejecuci\u00f3n de este servicio sea totalmente desatendida, lo que hacemos es descargar el JSON para cada uno. Esto en si mismo, no es realmente necesario, podemos tener un \u00fanico JSON para toda la aplicaci\u00f3n, de hecho finalmente ser\u00e1 as\u00ed, pero de cara a probar los m\u00f3dulos de manera individual creo que es mucho m\u00e1s c\u00f3modo. Utilizando el bot\u00f3n Download client configuration podr\u00e1s descargarte tus credenciales en formato JSON","title":"\u00bfC\u00f3mo hago para que mi script acceda a los datos?"},{"location":"1200_alumnos_Google/#como-se-lleva-a-cabo-el-control-de-acceso","text":"Una de las cosas que m\u00e1s me sorprendi\u00f3 es el modelo de autenticaci\u00f3n de usuarios. B\u00e1sicamente lo que hacemos para autenticar los accesos a la API es lo siguiente. Una aplicaci\u00f3n que ya ha sido autenticada debe disponer de un archivo serializado, en nuestro caso utilizamos el m\u00f3dulo pickle. Este archivo contiene el Token para la app. Lo curioso ocurre cuando a\u00fan no disponemos de ese Token. Si ejecutamos nuestro c\u00f3digo, utilizaremos parte del m\u00f3dulo google_auth_oauthlib_flow. La clase InstalledAppFlow dispone de un m\u00e9todo \u201cfrom_clients_secrets_file\u201d lo que hace es tomar como argumento nuestro archivo de credenciales, es decir, el JSON que nos descargamos en el apartado anterior y nos devuelve un objeto Flow. El objeto Flow dispone de un m\u00e9todo run_local_server , si ejecutamos esto en un sistema con entorno gr\u00e1fico, se nos abrir\u00e1 una ventana del navegador en la que tendremos que introducir nuestro correo y nuestra contrase\u00f1a del dominio asociado a G-Suite for education. Realmente podr\u00edamos utilizar un m\u00e9todo alternativo, concretamente run_console que muestra una URL al usuario en consola para que lo pegue manualmente en un navegador, se autentique con su cuenta de usuario y contrase\u00f1a y obtenga un c\u00f3digo que tendr\u00e1 que escribir en la misma consola. Con cualquiera de las dos alternativas lo que vamos a obtener son las credenciales OAuth2.0 que serializaremos y almacenaremos localmente para garantizar que, a partir de ese momento, no sea necesaria m\u00e1s intervenci\u00f3n humana. El c\u00f3digo que les muestro ya incluye la funcionalidad para \u201crefrescar\u201d un token que haya caducado. Parte del c\u00f3digo del archivo auth.py Por motivos evidentes, ninguno de los archivos relativos a credenciales est\u00e1 en el repositorio de gitlab, la ruta donde la aplicaci\u00f3n buscar\u00e1 estos archivos es configurable. La funci\u00f3n check_auth nos devuelve un objeto service que ser\u00e1 el que nos permitir\u00e1 acceder a los endpoints de las distintas API\u2019s Fragmento de main.py donde obtenemos un objeto por cada API que utilizamos.","title":"\u00bfC\u00f3mo se lleva a cabo el control de acceso?"},{"location":"1200_alumnos_Google/#los-scopes","text":"El \u00faltimo argumento de nuestra funci\u00f3n check_auth son los SCOPES para los que estamos solicitando autorizaci\u00f3n. B\u00e1sicamente es una manera de segmentar el grado de autorizaci\u00f3n que tiene nuestra aplicaci\u00f3n a la hora de interactuar con cada API. Puedes garantizar acceso de s\u00f3lo lectura a algunas API\u2019s y permitir que se lleven a cabo borrados y modificaciones en otras. \u00c1mbitos de autorizaci\u00f3n de Secuaz Traduciendo un poco estos Scopes podr\u00edamos decir que estamos dando permiso para leer, crear, modificar y borrar tanto hojas de c\u00e1lculo como documentos de nuestro Drive, podemos tambi\u00e9n hacer todo tipo de operaciones CRUD sobre los usuarios de nuestro dominio y sobre los grupos y sobre los cursos de classroom. No son pocos permisos, pero para la tarea que tenemos entre manos s\u00ed son los m\u00ednimos.","title":"Los scopes"},{"location":"1200_alumnos_Google/#gestion-de-la-configuracion","text":"Otro de los grandes escollos que hemos tenido que sortear en esta herramienta es la gesti\u00f3n de la configuraci\u00f3n. Nos lo podr\u00edamos haber ahorrado, pero habr\u00eda hecho que Secuaz no pudiera utilizarse en otros centros educativos y que, el pr\u00f3ximo a\u00f1o, hubiera que modificar el c\u00f3digo otra vez. Para evitar esto hemos tenido que recurrir a un m\u00f3dulo que desconoc\u00eda totalmente pero que, me sugirieron los amigos del grupo Python Canarias (desde aqu\u00ed muchas gracias por estar siempre ah\u00ed) El m\u00f3dulo se llama prettyconf y permite leer e interpretar distintos formatos de archivos de configuraci\u00f3n. Como les dec\u00eda hace un momento, no conoc\u00eda este m\u00f3dulo y seguro que se puede profundizar mucho m\u00e1s en su utilizaci\u00f3n, pero para el caso que me ocupaba, lo que hice fue recurrir a ficheros en formato .env Toda la configuraci\u00f3n de la aplicaci\u00f3n, de momento, puede resumirse en estos valores: Un ejemplo de archivo de configuraci\u00f3n para Secuaz Creo que los nombres de las variables son bastante autoexplicativos, perdonen el spanglish pero hay una parte de la configuraci\u00f3n, que puede ser \u00fatil para todos los que trabajen en Canarias, por eso la he dejado as\u00ed. Los seis primeros par\u00e1metros tienen que ver con los distintos archivos que utilizaremos en Drive, como son hojas de c\u00e1lculo, incluimos el ID del archivo y el rango de datos en formato A1 sobre el que vamos a trabajar. Sobre el ID de los archivos de Drive, me gustar\u00eda hacer una aclaraci\u00f3n, se trata de un valor que es parte de la URL para compartir que nos ofrece la interfaz web de Drive, se las se\u00f1alo en la siguiente imagen para que vean de d\u00f3nde sale. El ID del fichero es la cadena alfanum\u00e9rica que aparece tras el \u201cid=\u201d suele ser bastante larga B\u00e1sicamente tendr\u00e1s que copiar el valor del par\u00e1metro id de esa URL, ojo que en la imagen aparece cortado, suele ser bastante m\u00e1s largo.","title":"Gesti\u00f3n de la configuraci\u00f3n"},{"location":"1200_alumnos_Google/#importacion-de-profesores","text":"Bueno, entrando en materia, lo que secuaz hace en cada ciclo de generaci\u00f3n de cuentas es bastante b\u00e1sico y puede dividirse en dos procesos: El proceso de gesti\u00f3n de profesores y el proceso de gesti\u00f3n de alumnos Durante el proceso de gesti\u00f3n de profesores no se lleva a cabo ninguna creaci\u00f3n de cuentas del dominio, se presupone que todos han sido creados manualmente. Lo primero que hacemos es leer la hoja de c\u00e1lculo de nuestro Drive y crear un macro-diccionario en memoria. Las claves de este diccionario ser\u00e1n los correos electr\u00f3nicos de los docentes. Asociaremos a cada correo electr\u00f3nico el nombre de cada profesor y las asignaturas que imparte, los nombres de sus asignaturas se han normalizado, de manera que este identificador contenga informaci\u00f3n sobre la etapa, curso y secci\u00f3n. Una vez disponemos de ese s\u00faper diccionario, lo que hacemos es recorrerlo clave a clave, verificando que el usuario forma parte del grupo de profesores de classroom del dominio y si no es as\u00ed insert\u00e1ndolo. En nuestro classroom, si no eres miembro de este grupo no puedes ser profesor de ning\u00fan curso. Finalmente matriculamos a cada docente en su curso. Esto tiene alg\u00fan truco, el primer profesor que aparezca relacionado con un curso ser\u00e1 el propietario del mismo en classroom y el resto ser\u00e1n profesores adicionales. Esto que parece una chorrada es important\u00edsimo, hasta que el profesor propietario no acepte su curso en la interfaz web de classroom, el resto no podr\u00e1n verlo. Por otro lado, nos abre la puerta a configuraciones creativas del equipo docente, por ejemplo, puedo generar un grupo en el que impartan clases varios profesores, ya sea en formato s\u00faper-aula o para desarrollar proyectos multidisciplinares.","title":"Importaci\u00f3n de profesores"},{"location":"1200_alumnos_Google/#importacion-de-alumnos","text":"La importaci\u00f3n de alumnos es un poco m\u00e1s compleja. Una vez que leemos el contenido de la hoja de c\u00e1lculo de nuestro drive, lo primero que hacemos es calcular el hash para esta estructura en memoria. Si en el disco de nuestra m\u00e1quina existiera un archivo con un hash previo los comparar\u00edamos para ver si ha habido alg\u00fan cambio en todo el bloque de definici\u00f3n de alumnos. Si los hashes coinciden, no tendremos que realizar ninguna nueva operaci\u00f3n. Si por el contrario, el hash almacenado y el que acabamos de calcular fueran distintos, esto nos indicar\u00eda que alguno de los registros de la hoja de c\u00e1lculo han cambiado. Si ha habido una sincronizaci\u00f3n previa, en memoria almacenamos la lista del alumnado a la que le hemos calculado un hash por registro, de esta manera podemos saber qu\u00e9 fila del archivo es la que se ha modificado para intervenir s\u00f3lo en esta. Para cada nuevo registro o registro modificado continuamos con los siguientes pasos. En primer lugar intentamos determinar si ya existe una cuenta en nuestro dominio para este estudiante. Si existe, generamos una nueva contrase\u00f1a aleatoria, forzamos que deba cambiarla en el pr\u00f3ximo inicio de sesi\u00f3n y continuamos con el proceso de matriculaci\u00f3n en classroom. Si no existiera cuenta previamente, se crear\u00eda y se forzar\u00eda el cambio de contrase\u00f1a en el primer inicio de sesi\u00f3n. En cualquiera de los dos procesos anteriores lo que hacemos es matricular a cada alumno en la lista de asignaturas con la que se relaciona. A parte de eso, se le har\u00e1 miembro de un grupo del dominio que tendr\u00e1 el nombre de su grupo de clase. Esto nos facilitar\u00e1 en gran medida la comunicaci\u00f3n con grupos completos.","title":"Importaci\u00f3n de alumnos"},{"location":"1200_alumnos_Google/#generacion-de-autorizaciones-y-distribucion-de-credenciales","text":"Al terminar cada ciclo de importaci\u00f3n, se generan nuevas filas en una hoja de c\u00e1lculo de drive. La pinta que tiene este archivo de salida es la siguiente. Archivo de salida en drive con las credenciales temporales de los usuarios Utilizando el complemento Autocrat es muy sencillo hacer circulares personalizadas para cada alumno con el texto de autorizaci\u00f3n de las familias.","title":"Generaci\u00f3n de autorizaciones y distribuci\u00f3n de credenciales"},{"location":"1200_alumnos_Google/#conclusiones","text":"Este curso hemos utilizado por primera vez a nuestro \u201cSecuaz\u201d, en dos a\u00f1os hemos mejorado en casi dos meses el tiempo de configuraci\u00f3n de todas nuestras plataformas de elearning y la asignaci\u00f3n autom\u00e1tica de alumnos y profesores a cursos. Sin embargo, creo que esto s\u00f3lo ha sido un paso m\u00e1s hacia la herramienta ideal. Las l\u00edneas de trabajo futuras creo que deben ser las siguientes: Terminar el c\u00f3digo de sincronizaci\u00f3n para garantizar que sea totalmente desatendida. A\u00fan hay algunas dificultades con los registros modificados. Deber\u00edamos poder configurar la asignaci\u00f3n de asignaturas optativas, esta parte a\u00fan es manual. La generaci\u00f3n de todas las cuentas para este curso llev\u00f3 m\u00e1s de ocho horas seguidas, habr\u00eda que paralelizar los accesos a la API para mejorar estos tiempos. Necesitamos un sistema de logs normalizados. Una interfaz web agradable permitir\u00eda que otras personas sin conocimientos t\u00e9cnicos pudieran hacerse cargo de este proceso.","title":"Conclusiones"},{"location":"1200_alumnos_Google/#agradecimientos","text":"Si hacemos esto es porque creemos que es \u00fatil a nuestros alumnos y a nuestros compa\u00f1eros y estamos muy orgullosos de poder trabajar con todos ellos. Es un privilegio trabajar cada d\u00eda con personas que se toman tan en serio la educaci\u00f3n as\u00ed que: compa\u00f1eros y compa\u00f1eras, va por ustedes ;) Fuente","title":"Agradecimientos"},{"location":"bots_de_telegram_en_python/","text":"Bots de Telegram en python Este documento pretende ser una peque\u00f1a gu\u00eda sobre c\u00f3mo desarrollar un bot b\u00e1sico. \u00bfQu\u00e9 es eso de un bot? Es un programa capaz de engancharse a una conversaci\u00f3n de un sistema de mensajer\u00eda, atender a los mensajes de los usuarios e interactuar con estos de distintos modos. Uno de estos modos consiste en tener una serie de comandos que desencadenen acciones preprogramadas , cuando el usuario lanza uno de estos comandos, el bot hace algo concreto. Los comandos, en el caso de los bots de Telegram, siempre empiezan por un car\u00e1cter \u201c/\u201d Por ejemplo, si un nuevo bot entiende un comando /list_languages , cuando un usuario de una conversaci\u00f3n en la que est\u00e1 presente escribe /list_languages , el bot devuelve una lista con nombres de lenguajes de programaci\u00f3n. Lo que ocurrir\u00e1 es que se tendr\u00e1 un nuevo mensaje en la conversaci\u00f3n, enviado por el bot, en respuesta al comando. Bots inline Otro modo de actuar totalmente distinto es el de los bots inline . Los bots inline esperan que el resto de miembros de la conversaci\u00f3n empiecen un nuevo mensaje haciendo menci\u00f3n a su nombre precedido del car\u00e1cter @ . Se han desarrollado m\u00faltiples bots inline muy interesantes, por ejemplo, @gif que espera que se le pase un texto y devuelve gifs relacionados con el mismo. Si se escribe @gif en cualquier conversaci\u00f3n de Telegram se puede buscar gif\u2019s animados de una manera muy simple. Es un ejemplo de bot inline. Tambi\u00e9n est\u00e1n los que viven agazapados en la ventana de chat y act\u00faan espont\u00e1neamente reaccionando a los propios mensajes. As\u00ed que \u00e9ste es el tipo de bot sobre con el que se va a trabajar. Generando un bot Los desarrolladores de Telegram han elegido un m\u00e9todo muy llamativo para solicitar las credenciales necesarias para comenzar a trabajar con su API de bots. B\u00e1sicamente hay que abrir una conversaci\u00f3n con @BotFather desde el propio Telegram. @BotFather es un bot y reconoce una serie de comandos. El que nos ocupa es /newbot , que pedir\u00e1 que se introduzca un nombre para el nuevo esbirro digital as\u00ed como un nombre de usuario. Los dos datos pueden parecer lo mismo pero no lo son. El nombre aparecer\u00e1 en la informaci\u00f3n de contacto del bot sin embargo, el nombre de usuario ( username ) debe terminar siempre en bot y ser\u00e1 el identificador que se utilizar\u00e1 cuando se haga menci\u00f3n al bot en una ventana de chat, en nuestro caso ser\u00eda @iesromerovargas . De hecho, una manera de abrir una conversaci\u00f3n con este bot es, simplemente, dirigirte a la url http://t.me/<UsernameDelBot> , en nuestro caso http://t.me/iesromerovargas_bot Una vez ejecutado, la respuesta remota a la solicitud tendr\u00e1 forma de mensaje y dentro de \u00e9ste se encontrar\u00e1 un texto algo as\u00ed como: Use this token to access the HTTP API: 110201543:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw Esta ristra de n\u00fameros y letras es el identificador del bot, al que todo el mundo refiere como token y se deber\u00eda cuidar . Cualquiera que utilice ese token ser\u00e1, a efectos de la API de Telegram, nuestro bot. Esto tendr\u00e1 sentido en un momento -por cierto, ese token no es v\u00e1lido, ;-). Lo siguiente que se debe hacer es lanzar en la conversaci\u00f3n con @BotFather el comando /setdescription ; con \u00e9l se podr\u00e1 introducir un texto breve que sirva para presentar en sociedad al bot. Cada vez que alguien abra una conversaci\u00f3n con \u00e9l, ver\u00e1 esta descripci\u00f3n. Por \u00faltimo, habr\u00e1 que ponerle cara, as\u00ed que buscar una imagen adecuada y, una vez m\u00e1s, dentro de la ventana de la conversaci\u00f3n con \u201c@BotFather\u201d lanzar el comando /setuserpic \u201c@BotFather\u201d . Pedir\u00e1 que se suba una imagen de la galer\u00eda que pasar\u00e1 a ser la imagen del perfil del bot. Todas las piezas est\u00e1n en su sitio, el bot existe, tiene un nombre e imagen de perfil, ahora toca darle un poco de vida. D\u00e1ndole vida al bot Para Python existen varias librer\u00edas con las que desarrollar bots de Telegram, unas m\u00e1s eficientes que otras, para este ejemplo nos vamos a centrar en python-telegram-bot . Se puede acceder al repositorio en la siguiente direcci\u00f3n: https://github.com/python-telegram-bot/python-telegram-bot Para instalarla no hay m\u00e1s que ejecutar: pipenv install python-telegram-bot Del mismo modo, tambi\u00e9n tenemos creado un repositorio en github para este proyecto. Si te sientes perdido o no entiendes algo, ah\u00ed est\u00e1 disponible todo el proceso de desarrollo. La direcci\u00f3n del repositorio es: https://gitlab.com/goyoregalado/achicaynabot Cada paso formar\u00e1 parte de una nueva rama del repositorio as\u00ed se puede hacer un seguimiento secuencial del mismo y volver atr\u00e1s cuando sea necesario. La estructura del proyecto es muy simple: En este primer momento, todo el c\u00f3digo que har\u00e1 que el bot cobre vida estar\u00e1 en el archivo bot.py . La mayor\u00eda de ejemplos siguen esta misma estructura, sin embargo, vamos a a\u00f1adir un paquete de Python m\u00ednimo dentro del directorio config que permita aislar el token de autenticaci\u00f3n del repositorio. De esta manera, solamente se tendr\u00e1 que a\u00f1adir un archivo denominado auth.py tal y como se muestra en la imagen e incluir dentro de \u00e9l el token del bot como se puede ver a continuaci\u00f3n. Este valor debe ser el token que ofreci\u00f3 \u201c@BotFather\u201d cuando se solicit\u00f3 la creaci\u00f3n del bot. Sup\u00f3ngase que el Token que se devolvi\u00f3 fue este: 110201543:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw Como \u00faltima precauci\u00f3n, se ditar\u00e1 el fichero .gitignore para que no se pueda almacenar por error los datos de autenticaci\u00f3n en el repositorio. Vamos a empezar con un c\u00f3digo m\u00ednimo que nos permita interactuar con el bot. Dentro del fichero bot.py se encontrar\u00e1 lo siguiente: from telegram.ext import Updater from config.auth import token if __name__ == '__main__': updater = Updater(token=token, use_context=True) dispatcher = updater.dispatcher Si ahora se ejecuta este c\u00f3digo utilizando el int\u00e9rprete de Python se ver\u00e1 que el resultado es bastante pobre, b\u00e1sicamente, tras poco m\u00e1s de un segundo el programa terminar\u00e1 sin errores. El objeto Updater es el responsable de enviar las \u201creacciones\u201d del bot de vuelta a las ventanas de chat. Por ejemplo, si un usuario enviase el comando /start al bot, Updater ser\u00eda el que sabr\u00eda c\u00f3mo debe responder a ese comando. Para inicializar el bot, habr\u00e1 que pasarle el token que nos identifica un\u00edvocamente en los servidores de Telegram . El propio objeto Updater nos devuelve la referencia a otro objeto important\u00edsimo, el dispatcher . Si el bot fuera un ser vivo, el dispatcher ser\u00eda su oreja. La funci\u00f3n del dispatcher es mantenerse a la escucha en todas las ventanas de chat en las que est\u00e9 presente el ente digital. Un poco de feedback Lo siguiente que se ha de hacer es que el bot devuelva algo de informaci\u00f3n. Para lograrlo importaremos una nueva librer\u00eda, logging . La funci\u00f3n de esta librer\u00eda es registrar eventos, devolver informaci\u00f3n sobre el estado del bot. Es un software bastante vers\u00e1til, se puede conectar directamente a los registros del sistema operativo. Solamente se utilizar\u00e1 para que muestre por pantalla la informaci\u00f3n que se considere oportuna. La manera de utilizar logging puede parecer un poco extra\u00f1a, pero se ver\u00e1 que no es tan compleja como parece. import logging logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO) logger = logging.getLogger('AchicaynaBot') La primera l\u00ednea importa la librer\u00eda. La segunda l\u00ednea, sin embargo s\u00ed empieza a ser interesante. Lo que hacemos es configurar qu\u00e9 informaci\u00f3n se va a almacenar cada vez que se registre un evento. El primer argumento es format y, en este caso, se ha decidido configurar las salidas de esta manera: format='%(asctime)s - %(name)s - %(levelname)s - %(message)s' Esto no significa otra cosa que se quiere que cada l\u00ednea comience con la fecha y hora en un formato como el siguiente: 2019\u201301\u201313 22:19:36,146 A continuaci\u00f3n, separado por un gui\u00f3n, aparecer\u00e1 el nombre del bot, separado por un nuevo gui\u00f3n el nivel del registro que se est\u00e1 mostrando y por \u00faltimo el mensaje que el bot quiere mostrar. El segundo argumento es level que establece la gravedad m\u00ednima que tiene que tener un evento para que el bot decida molestar. Los mensajes de registro suelen tener una jerarqu\u00eda donde los mensajes menos prioritarios son aquellos que los programadores utilizan para buscar errores en el c\u00f3digo y los m\u00e1s importantes son aquellos que, de producirse, podr\u00edan hacer que la aplicaci\u00f3n no pudiera continuar funcionando. Por orden de menor a mayor prioridad, se dir\u00eda que los niveles de registro son: Debug , info , warning , error y critical . Si no se indica otra cosa, la librer\u00eda logging est\u00e1 configurada para mostrar mensajes con categor\u00eda m\u00ednima de warning . Esta categor\u00eda de eventos representa un aviso de que ha ocurrido algo inesperado. Si se deja esta configuraci\u00f3n tal cual, la informaci\u00f3n que se espera recibir no se mostrar\u00eda, porque no es algo inesperado, as\u00ed que se establece el nivel m\u00ednimo de prioridad en info. Esto se hace pasando el siguiente valor como segundo argumento: level=logging.INFO Por \u00faltimo, se almacena en la variable logger una instancia del objeto logger que permita enviar un mensaje. De manera que, si se quisiere enviar un mensaje al usuario para informarle de que est\u00e1 ocurriendo algo se har\u00eda uso de alguno de los siguientes m\u00e9todos. logger.debug('Este mensaje es s\u00f3lo para frikis programadores como nosotros') logger.info('Este mensaje representa algo normal') logger.warning('Esto ya no es tan normal') logger.error('Deber\u00edas empezar a preocuparte') logger.critical('El bot est\u00e1 as\u00ed X(') En primer lugar, vamos a hacer que pueda responder a su primer comando. Este comando ser\u00e1 /start y como respuesta enviar\u00e1 un mensaje al chat en el que diga: \u201cSoy de Jerez de la Frontera, cuna del fino, de los caballos cartujanos y Capital Mundial del Motociclismo\u201d . Habr\u00e1 que hablar de nuevo con @BotFather e indicarle que se quiere configurar el bot. Para ello se le env\u00eda el comando /mybots , que listar\u00e1 todos los bots que se han creado hasta la fecha. Con el comando /mybots siempre se puede consultar la lista de los bots creados. Una vez seleccionado el bot, dar\u00e1 una serie de opciones que permiten configurar distintos aspectos del mismo. Seleccionar la opci\u00f3n \u201cEdit Bot\u201d y una vez all\u00ed \u201c@BotFather\u201d ofrecer\u00e1 un nuevo men\u00fa. En este men\u00fa se puede definir la lista de comandos del bot. Para informar a Telegram de los comandos que entender\u00e1 el bot bastar\u00e1 con pulsar sobre el bot\u00f3n \u201cEdit Commands\u201d. Una vez m\u00e1s, la manera de establecer esa lista de comandos es muy original. Habr\u00e1 que enviarle un mensaje a \u201c@BotFather\u201d con el siguiente formato: comando1 - Texto explicativo sobre el comando1. comando2 - Texto explicativo sobre el comando2. Se a\u00f1ade el comando start. Una vez hecho esto, se est\u00e1 listo para indicar al bot c\u00f3mo debe reaccionar cuando reciba el \u00fanico comando que entender\u00e1 de momento. En primer lugar se programa la funci\u00f3n que se har\u00e1 cargo de esta respuesta. A estas funciones se les llama \u201c handlers \u201d y siempre tienen la misma estructura. def start(bot, update): logger.info('He recibido un comando start') bot.send_message( chat_id=update.message.chat_id, text=\"Soy un Achicayna, que entre los primeros pobladores de Canarias era el equivalente a un plebeyo.\" ) Reciben como argumento dos par\u00e1metros: bot , que representa al propio bot y provee de m\u00e9todos para enviar mensajes y update que representa el mensaje que ha desencadenado que se llame a esta funci\u00f3n, en este caso, el comando /start . La primera l\u00ednea a\u00f1adir\u00e1 una salida a nuestro registro que nos avise de que se ha recibido el comando. La segunda l\u00ednea inyectar\u00e1 en el chat en el que se ha lanzado el comando un mensaje de parte de Achicayna. Ahora hay que indicarle al dispatcher qu\u00e9 queremos hacer cuando recibamos cada comando. En esta caso a\u00fan s\u00f3lo se ha definido uno, as\u00ed que la cosa ser\u00e1 f\u00e1cil. Habr\u00e1 que importar CommandHandler desde telegram.ext from telegram.ext import CommandHandler Este objeto recibe como par\u00e1metros tanto la cadena de texto del comando (sin la barra inicial), como el nombre de la funci\u00f3n que deber\u00e1 ejecutarse cuando se reciba, el famoso \u201chandler\u201d. Y todo esto se dar\u00e1 de alta en el dispatcher usando el siguiente c\u00f3digo: dispatcher.add_handler(CommandHandler('start', start)) Esto viene a significar: \u201cDispatcher, cuando recibas un comando \u2018start\u2019 ejecuta la funci\u00f3n start \u201d Finalmente hay que decirle al objeto updater que est\u00e9 atento a cualquier mensaje que pueda llegarle al bot y que mientras no reciba ninguno que se mantenga a la espera. Esto se hace con estas dos nuevas l\u00edneas de c\u00f3digo: updater.start_polling() updater.idle() El c\u00f3digo final del bot quedar\u00eda de este modo: from telegram.ext import Updater, CommandHandler, CallbackContext from config.auth import token import logging logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s \\ - %(message)s', level=logging.INFO) logger = logging.getLogger('romerovargasbot') def start(update: Updater, context: CallbackContext): logger.info('He recibido un comando start') context.bot.send_message( chat_id=update.message.chat_id, text=\"Soy un Achicayna, que entre los primeros pobladores de Canarias\\ era el equivalente a un plebeyo.\") if __name__ == '__main__': updater = Updater(token=token, use_context=True) dispatcher = updater.dispatcher dispatcher.add_handler(CommandHandler('start', start)) updater.start_polling() updater.idle() Si ejecut\u00e1semos el bot haciendo uso del comando python src/bot.py se podr\u00e1 comenzar a conversar con Achicayna, aunque, por ahora, es un bot un poco soso. Nuestra primera breve conversaci\u00f3n con Achicayna En la pr\u00f3xima entrega vamos a hacer que Achicayna no s\u00f3lo reaccione a comandos sino que est\u00e9 pendiente de lo que se escribe en las ventanas de chat en las que participe. Fuente","title":"Bots de Telegram en Python"},{"location":"bots_de_telegram_en_python/#bots-de-telegram-en-python","text":"Este documento pretende ser una peque\u00f1a gu\u00eda sobre c\u00f3mo desarrollar un bot b\u00e1sico.","title":"Bots de Telegram en python"},{"location":"bots_de_telegram_en_python/#que-es-eso-de-un-bot","text":"Es un programa capaz de engancharse a una conversaci\u00f3n de un sistema de mensajer\u00eda, atender a los mensajes de los usuarios e interactuar con estos de distintos modos. Uno de estos modos consiste en tener una serie de comandos que desencadenen acciones preprogramadas , cuando el usuario lanza uno de estos comandos, el bot hace algo concreto. Los comandos, en el caso de los bots de Telegram, siempre empiezan por un car\u00e1cter \u201c/\u201d Por ejemplo, si un nuevo bot entiende un comando /list_languages , cuando un usuario de una conversaci\u00f3n en la que est\u00e1 presente escribe /list_languages , el bot devuelve una lista con nombres de lenguajes de programaci\u00f3n. Lo que ocurrir\u00e1 es que se tendr\u00e1 un nuevo mensaje en la conversaci\u00f3n, enviado por el bot, en respuesta al comando.","title":"\u00bfQu\u00e9 es eso de un bot?"},{"location":"bots_de_telegram_en_python/#bots-inline","text":"Otro modo de actuar totalmente distinto es el de los bots inline . Los bots inline esperan que el resto de miembros de la conversaci\u00f3n empiecen un nuevo mensaje haciendo menci\u00f3n a su nombre precedido del car\u00e1cter @ . Se han desarrollado m\u00faltiples bots inline muy interesantes, por ejemplo, @gif que espera que se le pase un texto y devuelve gifs relacionados con el mismo. Si se escribe @gif en cualquier conversaci\u00f3n de Telegram se puede buscar gif\u2019s animados de una manera muy simple. Es un ejemplo de bot inline. Tambi\u00e9n est\u00e1n los que viven agazapados en la ventana de chat y act\u00faan espont\u00e1neamente reaccionando a los propios mensajes. As\u00ed que \u00e9ste es el tipo de bot sobre con el que se va a trabajar.","title":"Bots inline"},{"location":"bots_de_telegram_en_python/#generando-un-bot","text":"Los desarrolladores de Telegram han elegido un m\u00e9todo muy llamativo para solicitar las credenciales necesarias para comenzar a trabajar con su API de bots. B\u00e1sicamente hay que abrir una conversaci\u00f3n con @BotFather desde el propio Telegram. @BotFather es un bot y reconoce una serie de comandos. El que nos ocupa es /newbot , que pedir\u00e1 que se introduzca un nombre para el nuevo esbirro digital as\u00ed como un nombre de usuario. Los dos datos pueden parecer lo mismo pero no lo son. El nombre aparecer\u00e1 en la informaci\u00f3n de contacto del bot sin embargo, el nombre de usuario ( username ) debe terminar siempre en bot y ser\u00e1 el identificador que se utilizar\u00e1 cuando se haga menci\u00f3n al bot en una ventana de chat, en nuestro caso ser\u00eda @iesromerovargas . De hecho, una manera de abrir una conversaci\u00f3n con este bot es, simplemente, dirigirte a la url http://t.me/<UsernameDelBot> , en nuestro caso http://t.me/iesromerovargas_bot Una vez ejecutado, la respuesta remota a la solicitud tendr\u00e1 forma de mensaje y dentro de \u00e9ste se encontrar\u00e1 un texto algo as\u00ed como: Use this token to access the HTTP API: 110201543:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw Esta ristra de n\u00fameros y letras es el identificador del bot, al que todo el mundo refiere como token y se deber\u00eda cuidar . Cualquiera que utilice ese token ser\u00e1, a efectos de la API de Telegram, nuestro bot. Esto tendr\u00e1 sentido en un momento -por cierto, ese token no es v\u00e1lido, ;-). Lo siguiente que se debe hacer es lanzar en la conversaci\u00f3n con @BotFather el comando /setdescription ; con \u00e9l se podr\u00e1 introducir un texto breve que sirva para presentar en sociedad al bot. Cada vez que alguien abra una conversaci\u00f3n con \u00e9l, ver\u00e1 esta descripci\u00f3n. Por \u00faltimo, habr\u00e1 que ponerle cara, as\u00ed que buscar una imagen adecuada y, una vez m\u00e1s, dentro de la ventana de la conversaci\u00f3n con \u201c@BotFather\u201d lanzar el comando /setuserpic \u201c@BotFather\u201d . Pedir\u00e1 que se suba una imagen de la galer\u00eda que pasar\u00e1 a ser la imagen del perfil del bot. Todas las piezas est\u00e1n en su sitio, el bot existe, tiene un nombre e imagen de perfil, ahora toca darle un poco de vida.","title":"Generando un bot"},{"location":"bots_de_telegram_en_python/#dandole-vida-al-bot","text":"Para Python existen varias librer\u00edas con las que desarrollar bots de Telegram, unas m\u00e1s eficientes que otras, para este ejemplo nos vamos a centrar en python-telegram-bot . Se puede acceder al repositorio en la siguiente direcci\u00f3n: https://github.com/python-telegram-bot/python-telegram-bot Para instalarla no hay m\u00e1s que ejecutar: pipenv install python-telegram-bot Del mismo modo, tambi\u00e9n tenemos creado un repositorio en github para este proyecto. Si te sientes perdido o no entiendes algo, ah\u00ed est\u00e1 disponible todo el proceso de desarrollo. La direcci\u00f3n del repositorio es: https://gitlab.com/goyoregalado/achicaynabot Cada paso formar\u00e1 parte de una nueva rama del repositorio as\u00ed se puede hacer un seguimiento secuencial del mismo y volver atr\u00e1s cuando sea necesario. La estructura del proyecto es muy simple: En este primer momento, todo el c\u00f3digo que har\u00e1 que el bot cobre vida estar\u00e1 en el archivo bot.py . La mayor\u00eda de ejemplos siguen esta misma estructura, sin embargo, vamos a a\u00f1adir un paquete de Python m\u00ednimo dentro del directorio config que permita aislar el token de autenticaci\u00f3n del repositorio. De esta manera, solamente se tendr\u00e1 que a\u00f1adir un archivo denominado auth.py tal y como se muestra en la imagen e incluir dentro de \u00e9l el token del bot como se puede ver a continuaci\u00f3n. Este valor debe ser el token que ofreci\u00f3 \u201c@BotFather\u201d cuando se solicit\u00f3 la creaci\u00f3n del bot. Sup\u00f3ngase que el Token que se devolvi\u00f3 fue este: 110201543:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw Como \u00faltima precauci\u00f3n, se ditar\u00e1 el fichero .gitignore para que no se pueda almacenar por error los datos de autenticaci\u00f3n en el repositorio. Vamos a empezar con un c\u00f3digo m\u00ednimo que nos permita interactuar con el bot. Dentro del fichero bot.py se encontrar\u00e1 lo siguiente: from telegram.ext import Updater from config.auth import token if __name__ == '__main__': updater = Updater(token=token, use_context=True) dispatcher = updater.dispatcher Si ahora se ejecuta este c\u00f3digo utilizando el int\u00e9rprete de Python se ver\u00e1 que el resultado es bastante pobre, b\u00e1sicamente, tras poco m\u00e1s de un segundo el programa terminar\u00e1 sin errores. El objeto Updater es el responsable de enviar las \u201creacciones\u201d del bot de vuelta a las ventanas de chat. Por ejemplo, si un usuario enviase el comando /start al bot, Updater ser\u00eda el que sabr\u00eda c\u00f3mo debe responder a ese comando. Para inicializar el bot, habr\u00e1 que pasarle el token que nos identifica un\u00edvocamente en los servidores de Telegram . El propio objeto Updater nos devuelve la referencia a otro objeto important\u00edsimo, el dispatcher . Si el bot fuera un ser vivo, el dispatcher ser\u00eda su oreja. La funci\u00f3n del dispatcher es mantenerse a la escucha en todas las ventanas de chat en las que est\u00e9 presente el ente digital.","title":"D\u00e1ndole vida al bot"},{"location":"bots_de_telegram_en_python/#un-poco-de-feedback","text":"Lo siguiente que se ha de hacer es que el bot devuelva algo de informaci\u00f3n. Para lograrlo importaremos una nueva librer\u00eda, logging . La funci\u00f3n de esta librer\u00eda es registrar eventos, devolver informaci\u00f3n sobre el estado del bot. Es un software bastante vers\u00e1til, se puede conectar directamente a los registros del sistema operativo. Solamente se utilizar\u00e1 para que muestre por pantalla la informaci\u00f3n que se considere oportuna. La manera de utilizar logging puede parecer un poco extra\u00f1a, pero se ver\u00e1 que no es tan compleja como parece. import logging logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO) logger = logging.getLogger('AchicaynaBot') La primera l\u00ednea importa la librer\u00eda. La segunda l\u00ednea, sin embargo s\u00ed empieza a ser interesante. Lo que hacemos es configurar qu\u00e9 informaci\u00f3n se va a almacenar cada vez que se registre un evento. El primer argumento es format y, en este caso, se ha decidido configurar las salidas de esta manera: format='%(asctime)s - %(name)s - %(levelname)s - %(message)s' Esto no significa otra cosa que se quiere que cada l\u00ednea comience con la fecha y hora en un formato como el siguiente: 2019\u201301\u201313 22:19:36,146 A continuaci\u00f3n, separado por un gui\u00f3n, aparecer\u00e1 el nombre del bot, separado por un nuevo gui\u00f3n el nivel del registro que se est\u00e1 mostrando y por \u00faltimo el mensaje que el bot quiere mostrar. El segundo argumento es level que establece la gravedad m\u00ednima que tiene que tener un evento para que el bot decida molestar. Los mensajes de registro suelen tener una jerarqu\u00eda donde los mensajes menos prioritarios son aquellos que los programadores utilizan para buscar errores en el c\u00f3digo y los m\u00e1s importantes son aquellos que, de producirse, podr\u00edan hacer que la aplicaci\u00f3n no pudiera continuar funcionando. Por orden de menor a mayor prioridad, se dir\u00eda que los niveles de registro son: Debug , info , warning , error y critical . Si no se indica otra cosa, la librer\u00eda logging est\u00e1 configurada para mostrar mensajes con categor\u00eda m\u00ednima de warning . Esta categor\u00eda de eventos representa un aviso de que ha ocurrido algo inesperado. Si se deja esta configuraci\u00f3n tal cual, la informaci\u00f3n que se espera recibir no se mostrar\u00eda, porque no es algo inesperado, as\u00ed que se establece el nivel m\u00ednimo de prioridad en info. Esto se hace pasando el siguiente valor como segundo argumento: level=logging.INFO Por \u00faltimo, se almacena en la variable logger una instancia del objeto logger que permita enviar un mensaje. De manera que, si se quisiere enviar un mensaje al usuario para informarle de que est\u00e1 ocurriendo algo se har\u00eda uso de alguno de los siguientes m\u00e9todos. logger.debug('Este mensaje es s\u00f3lo para frikis programadores como nosotros') logger.info('Este mensaje representa algo normal') logger.warning('Esto ya no es tan normal') logger.error('Deber\u00edas empezar a preocuparte') logger.critical('El bot est\u00e1 as\u00ed X(') En primer lugar, vamos a hacer que pueda responder a su primer comando. Este comando ser\u00e1 /start y como respuesta enviar\u00e1 un mensaje al chat en el que diga: \u201cSoy de Jerez de la Frontera, cuna del fino, de los caballos cartujanos y Capital Mundial del Motociclismo\u201d . Habr\u00e1 que hablar de nuevo con @BotFather e indicarle que se quiere configurar el bot. Para ello se le env\u00eda el comando /mybots , que listar\u00e1 todos los bots que se han creado hasta la fecha. Con el comando /mybots siempre se puede consultar la lista de los bots creados. Una vez seleccionado el bot, dar\u00e1 una serie de opciones que permiten configurar distintos aspectos del mismo. Seleccionar la opci\u00f3n \u201cEdit Bot\u201d y una vez all\u00ed \u201c@BotFather\u201d ofrecer\u00e1 un nuevo men\u00fa. En este men\u00fa se puede definir la lista de comandos del bot. Para informar a Telegram de los comandos que entender\u00e1 el bot bastar\u00e1 con pulsar sobre el bot\u00f3n \u201cEdit Commands\u201d. Una vez m\u00e1s, la manera de establecer esa lista de comandos es muy original. Habr\u00e1 que enviarle un mensaje a \u201c@BotFather\u201d con el siguiente formato: comando1 - Texto explicativo sobre el comando1. comando2 - Texto explicativo sobre el comando2. Se a\u00f1ade el comando start. Una vez hecho esto, se est\u00e1 listo para indicar al bot c\u00f3mo debe reaccionar cuando reciba el \u00fanico comando que entender\u00e1 de momento. En primer lugar se programa la funci\u00f3n que se har\u00e1 cargo de esta respuesta. A estas funciones se les llama \u201c handlers \u201d y siempre tienen la misma estructura. def start(bot, update): logger.info('He recibido un comando start') bot.send_message( chat_id=update.message.chat_id, text=\"Soy un Achicayna, que entre los primeros pobladores de Canarias era el equivalente a un plebeyo.\" ) Reciben como argumento dos par\u00e1metros: bot , que representa al propio bot y provee de m\u00e9todos para enviar mensajes y update que representa el mensaje que ha desencadenado que se llame a esta funci\u00f3n, en este caso, el comando /start . La primera l\u00ednea a\u00f1adir\u00e1 una salida a nuestro registro que nos avise de que se ha recibido el comando. La segunda l\u00ednea inyectar\u00e1 en el chat en el que se ha lanzado el comando un mensaje de parte de Achicayna. Ahora hay que indicarle al dispatcher qu\u00e9 queremos hacer cuando recibamos cada comando. En esta caso a\u00fan s\u00f3lo se ha definido uno, as\u00ed que la cosa ser\u00e1 f\u00e1cil. Habr\u00e1 que importar CommandHandler desde telegram.ext from telegram.ext import CommandHandler Este objeto recibe como par\u00e1metros tanto la cadena de texto del comando (sin la barra inicial), como el nombre de la funci\u00f3n que deber\u00e1 ejecutarse cuando se reciba, el famoso \u201chandler\u201d. Y todo esto se dar\u00e1 de alta en el dispatcher usando el siguiente c\u00f3digo: dispatcher.add_handler(CommandHandler('start', start)) Esto viene a significar: \u201cDispatcher, cuando recibas un comando \u2018start\u2019 ejecuta la funci\u00f3n start \u201d Finalmente hay que decirle al objeto updater que est\u00e9 atento a cualquier mensaje que pueda llegarle al bot y que mientras no reciba ninguno que se mantenga a la espera. Esto se hace con estas dos nuevas l\u00edneas de c\u00f3digo: updater.start_polling() updater.idle() El c\u00f3digo final del bot quedar\u00eda de este modo: from telegram.ext import Updater, CommandHandler, CallbackContext from config.auth import token import logging logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s \\ - %(message)s', level=logging.INFO) logger = logging.getLogger('romerovargasbot') def start(update: Updater, context: CallbackContext): logger.info('He recibido un comando start') context.bot.send_message( chat_id=update.message.chat_id, text=\"Soy un Achicayna, que entre los primeros pobladores de Canarias\\ era el equivalente a un plebeyo.\") if __name__ == '__main__': updater = Updater(token=token, use_context=True) dispatcher = updater.dispatcher dispatcher.add_handler(CommandHandler('start', start)) updater.start_polling() updater.idle() Si ejecut\u00e1semos el bot haciendo uso del comando python src/bot.py se podr\u00e1 comenzar a conversar con Achicayna, aunque, por ahora, es un bot un poco soso. Nuestra primera breve conversaci\u00f3n con Achicayna En la pr\u00f3xima entrega vamos a hacer que Achicayna no s\u00f3lo reaccione a comandos sino que est\u00e9 pendiente de lo que se escribe en las ventanas de chat en las que participe. Fuente","title":"Un poco de feedback"},{"location":"buenas_practicas/","text":"README.md : Una documentaci\u00f3n a nivel de proyecto ayuda a tener una estructura limpia, esto ayuda a todo el equipo en el futuro. Escribir esto en el archivo README.md, es un buen punto para empezar, esto luego se puede expandir en la carpeta docs/ de ser necesario. Incluya el proposito del proyecto, que hay en cada folder, de donde provienen los datos, que archivos son criticos y como se ejecutan los test. Utilice Docker : utilizar Docker le permitir\u00e1 simplificar el despliegue de la aplicaci\u00f3n en otros m\u00e1quinas o realizar el despliegue en alg\u00fan entorno cloud. Test : Agrega el archivo test/ y agrega pruebas unitarias. Una de las librer\u00edas que se recomiendan utilizar es pytest , un moderno entorno para ejecutar las pruebas. Empezar con un par de test y luego ir continuar mejorando estos. Utilice el coverage para determinar que porcentaje de su c\u00f3digo esta cubierto por pruebas. Test de integraci\u00f3n: Si tiene c\u00f3digo heredado y carece de pruebas, una actividad de alto valor es agregar algunas \u00abpruebas de integraci\u00f3n\u00bb que verifiquen el flujo general del proyecto y verifiquen que con ciertos datos de entrada se obtienen resultados de salida espec\u00edficos. Docstrings : Agregue documentaci\u00f3n en el c\u00f3digo para las funciones, clases y m\u00f3dulos, esto es de gran ayuda. Agregue informaci\u00f3n de que se espera de la funci\u00f3n y un peque\u00f1o ejemplo de lo que se espera como salida. Puede revisar el doc-strings de numpy como inspiraci\u00f3n. Refactoring : Si el c\u00f3digo se convierte muy largo, como una funci\u00f3n extensa que ocupe m\u00e1s de una pantalla, sientase comodo de hacer un refactoring del c\u00f3digo y hacerlo m\u00e1s peque\u00f1o o reducirlo en funciones m\u00e1s peque\u00f1as. C\u00f3digo m\u00e1s corto es m\u00e1s f\u00e1cil para hacer pruebas y para darle mantenimiento. Git : Utiliza una herramienta para el control de versiones, esto le ayudara en momentos que sobre escriba algo cr\u00edtico. Acost\u00fambrese a realizar commits frecuentemente y realice el push hacia el repositorio diariamente. PEP8 : Mantenga el estandard de codificaci\u00f3n PEP8. A\u00fan mejor, adopte Black como un enlace de control del c\u00f3digo previo, para que simplemente reescriba el c\u00f3digo est\u00e1ndar por usted. Utilice flake8 para limpiar su c\u00f3digo y evitar otros errores. PipEnv : Crear entornos aislados del sistema operativo les facilitar\u00e1 la vida. Algunos recomendados son Anaconda, otro puede ser pipenv con Docker, ambas son soluciones adecuadas. Legibilidad : Finalmente recuerde que la legibilidad es m\u00e1s importante que ser inteligente. Los fragmentos cortos de c\u00f3digo complejo y dific\u00edl de leer ser\u00e1n dif\u00edciles de mantener para usted y sus colegas, por lo que el equipo tendr\u00e1 miedo de tocar ese c\u00f3digo. En su lugar, prefiera escibir una funci\u00f3n m\u00e1s larga y m\u00e1s f\u00e1cil de leer y que este respaldada con documentaci\u00f3n \u00fatil que muestre lo que devolver\u00e1 y complemente esto con pruebas unitarias. https://www.clubdetecnologia.net/blog/2019/buenas-practicas-en-python/","title":"Buenas practicas"},{"location":"comentarios/","text":"En Python la \u00fanica forma de crear comentarios es usando el s\u00edmbolo # (numeral). No hay otra . La proposici\u00f3n seg\u00fan la cual las triples comillas operan tambi\u00e9n como comentarios es falsa . # Esto es un comentario. a = 1 \"\"\"\u00a1\u00a1\u00a1Error!!! Esto no es un comentario.\"\"\" b = 2 La confusi\u00f3n radica en que las triples comillas suelen emplearse para crear la documentaci\u00f3n de una funci\u00f3n. Por ejemplo: def add(a, b): \"\"\" Retorna el resultado de a + b. \"\"\" return a + b Luego, esa documentaci\u00f3n, conocida tambi\u00e9n como docstring , se almacena en el atributo add.__doc__ y es accedida por la funci\u00f3n help() . print(add.__doc__) help(add) No obstante, la realidad es que, en una funci\u00f3n, la primera cadena literal que se encuentra es interpretada por Python como la documentaci\u00f3n , sin importar si se usan triples comillas o un par de comillas dobles o simples. # Ambas documentaciones son v\u00e1lidas. def add(a, b): \"Retorna el resultado de a + b.\" return a + b def div(a, b): 'Retorna el resultado de a / b.' return a / b Esto funciona porque en Python es v\u00e1lido crear expresiones cuyo resultado no es utlilizado para nada (por ejemplo, para asignarlo a una variable o pasarlo como argumento a una funci\u00f3n). El siguiente c\u00f3digo no arroja ning\u00fan error: 7 + 5 \"Hola mundo\" \"\"\"Esto es una cadena.\"\"\" 15 / 3 Ahora bien, eso es exactamente lo que se est\u00e1 haciendo cuando se crea un \u00abcomentario\u00bb usando triples comillas: generar una cadena que luego es desechada por Python por no emplearse. Pero el problema se origina cuando esas cadenas, creyendo ser comentarios, son ubicadas en lugares donde se espera una expresi\u00f3n. Por ejemplo: languages = [ \"\"\"Lenguaje y a\u00f1o en que fue creado\"\"\" (\"Python\", 1991), (\"Java\", 1996), (\"C++\", 1983), (\"Elixir\", 2011) ] Esto arroja el siguiente error: Traceback (most recent call last): File \"test.py\", line 3, in <module> (\"Python\", 1991), TypeError: 'str' object is not callable El error indica que estamos intentando llamar a una cadena como si fuese una funci\u00f3n. En efecto, no hay ninguna diferencia con esto: \"Lenguaje y a\u00f1o en que fue creado\"(\"Python\", 1991) Quienes se est\u00e1n iniciando en el lenguaje quedan at\u00f3nitos por un error tan extra\u00f1o. Y todo eso es por pensar que las cadenas funcionan como comentarios. La forma correcta, por tanto, es esta: languages = [ # Lenguaje y a\u00f1o en que fue creado (\"Python\", 1991), (\"Java\", 1996), (\"C++\", 1983), (\"Elixir\", 2011) ]","title":"Comentarios"},{"location":"entornos_virtuales/","text":"1. Introducci\u00f3n Un entorno virtual de Python es un ambiente creado con el objetivo de aislar recursos , como las librer\u00edas y el entorno de ejecuci\u00f3n, del sistema principal o de otros entornos virtuales. Lo anterior significa que en el mismo sistema, m\u00e1quina o computadora, es posible tener instaladas m\u00faltiples versiones de una misma librer\u00eda sin crear ning\u00fan tipo de conflicto. Cuando se est\u00e1 desarrollando software con Python, es com\u00fan utilizar diferentes versiones de un mismo paquete . Por ejemplo, imaginemos que se est\u00e1 desarrollando un videojuego con la versi\u00f3n 1.2 de pygame y mientras eso pasa, se comienza el desarrollo de otro videojuego que necesita las nuevas caracter\u00edsticas presentes en la versi\u00f3n 1.3. En este escenario, no es posible para los desarrolladores eliminar la version 1.2 e instalar la 1.3 en sus computadoras. As\u00ed que el problema a solucionar radica en c\u00f3mo instalar las dos versiones de la misma librer\u00eda con el fin de poder desarrollar ambos proyectos de forma simult\u00e1nea. La soluci\u00f3n consiste en crear entornos virtuales . De esta manera, es posible instalar la versi\u00f3n 1.2 de pygame en un entorno virtual y la versi\u00f3n 1.3 en otro diferente o en el sistema principal sin problema alguno. Para poder utilizar este simple pero poderoso concepto es necesario instalar una utilidad que permita gestionar la creaci\u00f3n y utilizaci\u00f3n de dichos entornos virtuales. Hay muchas \u00e1reas de desarrollo de software sobre las que se debaten acaloradamente, pero el uso de entornos virtuales para el desarrollo de Python no es uno de ellos. Hist\u00f3ricamente, los desarrolladores de Python han usado virtualenv o pyenv para configurar entornos virtuales. Pero en 2017 el destacado desarrollador de Python Kenneth Reitz lanz\u00f3 pipenv , que ahora es la herramienta de empaquetado Python recomendada oficialmente por PyPa ( Python Packaging Authority ). pipenv es similar a npm y yarn del ecosistema Node: Crea un Pipfile con las dependencias de software Crea un Pipfile.lock para asegurar construcciones deterministas . \u00c9stos son archivos que buscan reemplazar el antiguo requirements.txt de virtualenv y pyenv con la sintaxis TOML ( Tom\u2019s Obvious, Minimal Language ) para declarar todo tipo de dependencias. Un solo archivo Pipfile para reemplazar la variedad de requirements.txt . Ejemplo dev-requirements , test-requirements , etc. El determinismo se refiere a que cada vez que se descargue el software en un nuevo entorno virtual, tendr\u00e1 exactamente la misma configuraci\u00f3n . Sebastian McKenzie , el creador de yarn que introdujo por primera vez este concepto al empaquetado de JavaScript, tiene una publicaci\u00f3n en su blog concisa que explica qu\u00e9 es el determinismo y por qu\u00e9 es importante. Los problemas que pipenv busca resolver son multifac\u00e9ticos: No se necesitar\u00e1 usar m\u00e1s pip y virtualenv separados. Trabajan juntos. Manejar un archivo requirements.txt puede ser problem\u00e1tico, por eso Pipenv usa en su lugar Pipfile y Pipfile.lock , que son superiores para usos b\u00e1sicos Los Hashes se usan en todas partes, siempre. Seguridad. Autom\u00e1ticamente expone vulnerabilidades de seguridad. Se recomienda encarecidamente el uso de las \u00faltimas versiones de dependencias para minimizar los riesgos de seguridad derivados de componentes obsoletos. Da una vista del \u00e1rbol de dependecias (por ejemplo $ pipenv graph ). Agiliza el flujo de desarrollo cargando archivos .env . La conclusi\u00f3n es que se debe crear un nuevo entorno virtual para cada nuevo proyecto en python . 2. Instalar pipenv Si bien pip puede instalar paquetes de Python, se recomienda pipenv ya que es una herramienta de nivel superior que simplifica la administraci\u00f3n de dependencias para casos de uso comunes. 2.1. Instalaci\u00f3n en Arch y derivadas (ArcoLinux, Manjaro, Anarchy, etc.) Afortunadamente, dentro de los repositorios oficiales de Arch, se encuentra el paquete python-pipenv con lo que la instalaci\u00f3n se convierte en algo tan sencillo como introducir el comando: $ pacman -S python-pipenv 2.2. Instalaci\u00f3n en Debian y derivadas Se usar\u00e1 pip3 para instalar pipenv por tanto, debe estar instalado previamente. Para ello se usar\u00e1: $ sudo apt install python3-pip Gracias a pip3 podemos instalar ahora pipenv . $ pip3 install --user pipenv Esto hace una instalaci\u00f3n de usuario para evitar romper cualquier paquete de todo el sistema. Si pipenv no est\u00e1 disponible en su shell despu\u00e9s de la instalaci\u00f3n , deber\u00e1 agregar el directorio binario de la base de usuarios a su PATH. Se puede encontrar el directorio binario de la base de usuarios ejecutando python -m site --user-base y agregando bin al final. Por ejemplo, esto normalmente imprimir\u00e1 ~/.local (con ~ expandido a la ruta absoluta a su directorio de inicio) por lo que deber\u00e1 agregar ~/.local/bin al PATH. Se puede establecer el PATH permanentemente modificando ~/.profile . Deber\u00eda bastar con recargar ~/.profile usando: source ~/.profile 2.3. Para usuarios de zsh El comportamiento de zsh es algo distinto ya que se basa en usar un fichero de configurari\u00f3n diferente a los habituales de Bash, por tanto, la instalaci\u00f3n del nuevo $PATH depender\u00e1 ahora de configurar convenientemente el fichero .zshrc a\u00f1adi\u00e9ndole lo siguiente como primeras l\u00edneas de c\u00f3digo: # If you come from bash you might have to change your $PATH. export PATH=$HOME/bin:/usr/local/bin:$PATH # set PATH so it includes user's private bin if it exists if [ -d \"$HOME/.local/bin\" ] ; then PATH=\"$HOME/.local/bin:$PATH\" fi 3. Instalando paquetes del proyecto pipenv gestiona las dependencias por proyecto. Para instalar paquetes, cambiar al directorio del proyecto (o simplemente usar un directorio vac\u00edo) y ejecutar: $ cd myproject $ pipenv install request Pipenv instalar\u00e1 la excelente biblioteca request y crear\u00e1 un archivo pipfile en el directorio del proyecto. pipfile se usa para rastrear qu\u00e9 dependencias necesita el proyecto en caso de que se necesite volver a instalarlas, como cuando se comparte el proyecto con otros. 3.1. Usar los paquetes instalados Ahora que las solicitudes est\u00e1n instaladas, se puede crear un archivo main.py simple para usarlo: import requests response = requests.get('https://httpbin.org/ip') print('Su IP en Internet es {0}'.format(response.json()['origin'].split(',')[0])) Luego se puede ejecutar este script usando pipenv run : $ pipenv run python main.py ..y obtener una salida similar a esta: Su IP es 8.8.8.8 El uso de $ pipenv run asegura que los paquetes instalados est\u00e9n disponibles para el script. Tambi\u00e9n es posible generar un nuevo shell que garantice que todos los comandos tengan acceso a sus paquetes instalados con $ pipenv shell . Otro ejemplo: pipenv y Django Crear un nuevo directorio y entrar en \u00e9l. $ cd $ mkdir django $ cd django Ahora se usa pipenv para instalar django $ pipenv install django Si se mira en el directorio, ahora hay dos nuevos archivos: Pipfile y Pipfile.lock . Se tiene la informaci\u00f3n que se necesita para el nuevo entorno virtual pero a\u00fan no ha sido activado. Se hace con: $ pipenv shell Deber\u00eda verse ahora el nombre del entorno envuelto entre par\u00e9ntesis precediendo al prompt . Si ahora se puede ejecutar django-admin startproject a continuaci\u00f3n es que Django se ha instalado correctamente. Lanzar entonces lo siguiente: (django) $ django-admin startproject test_project . El . al final del comando no crear\u00e1 un directorio adicional para test_project pero s\u00ed todos los subdirectorios que se necesitan para la aplicaci\u00f3n, en resumidas cuentas, se har\u00e1 una instalaci\u00f3n en el directorio en curso. Se puede comprobar que todo funciona arrancando el servidor web local con: (django) $ python manage.py runserver Si se visita http://127.0.0.1:8000/ se deber\u00eda ver la p\u00e1gina inicial de Django. El servidor se parar\u00e1 con C-c y se saldr\u00e1 del entorno virtual con el comando exit . 3.2. Desinstalar un projecto pipenv --rm 3.3. Advertencia: mapeo de Virtualenv Pipenv asigna autom\u00e1ticamente proyectos a sus virtualenvs espec\u00edficos. El virtualenv se almacena globalmente con el nombre del directorio ra\u00edz del proyecto m\u00e1s el hash de la ruta completa a la ra\u00edz del proyecto (por ejemplo, my_project-a3de50 ). Si cambia la ruta de su proyecto, interrumpe dicha asignaci\u00f3n predeterminada y pipenv ya no podr\u00e1 encontrar y usar el virtualenv del proyecto. Es posible que desee establecer la exportaci\u00f3n PIPENV_VENV_IN_PROJECT = 1 en su .bashrc/.zshrc (o cualquier archivo de configuraci\u00f3n de shell) para crear el virtualenv dentro del directorio de su proyecto, evitando problemas con los cambios de ruta posteriores. 4. Otros entornos de virtualizaci\u00f3n de python 4.1. virtualenv 4.1.1. C\u00f3mo instalar virtualenv Se puede instalar la utilidad virtualenv utilizando el gestor de paquetes de las diferentes distribuciones Linux: Los siguientes comandos instalar\u00e1n la utilidad virtualenv para las versiones 2 y 3 de Python. $ sudo apt-get install python-virtualenv virtualenv Tambi\u00e9n es posible instalar virtualenv utilizando el instalador de paquetes de Python pip: $ sudo pip install virtualenv 4.1.2. C\u00f3mo crear un entorno virtual de Python con virtualenv virtualenv con Python 3 Para crear un entorno virtual con Python 3, simplemente ejecutamos el comando virtualenv de la siguiente manera: $ virtualenv <entorno> --python=python3 Python 3 debe estar instalado de antemano para poder crear el entorno virtual. virtualenv con Python 2 Para crear un entorno virtual con Python 2, simplemente ejecutamos el comando virtualenv de la siguiente manera: $ virtualenv <entorno> Lamentablemente, no es posible crear un entorno virtual que contenga las dos versiones de Python al mismo tiempo. 4.1.3. Estructura de un entorno virtual de Python La ejecuci\u00f3n de comandos anteriormente explicados crean el directorio <entorno>/ con la siguiente estructura: env/ bin/ include/ lib/ site-packages/ En el directorio bin/ se encuentran los ejecutables necesarios para interactuar con el entorno virtual. En el directorio include/ se encuentran algunos archivos de cabecera de C (cuya extensi\u00f3n es *.h) necesarios para compilar algunas librer\u00edas de Python. Finalmente, en el directorio lib/ se encuentra una copia de la instalaci\u00f3n de Python as\u00ed como un directorio llamado site-packages/ en donde se almacenan los paquetes Python instalados en el entorno virtual. 4.1.4. C\u00f3mo activar un entorno virtual de Python con virtualenv Para activar un entorno virtual de Python, se ejecuta el script activate de virtualenv instalado en el directorio bin/ : $ cd env $ source bin/activate \u00f3 $ . bin/activate (env)$ El prompt de la terminal indica que el entorno virtual mi_proyecto est\u00e1 activado. Ya es posible utilizar los paquetes Python instalados en el entorno virtual as\u00ed como instalar paquetes adicionales. 4.1.5. C\u00f3mo desactivar un entorno virtual de Python con virtualenv Para desactivar un entorno virtual, porque se necesita trabajar en otro diferente, se ejecuta el comando deactivate de virtualenv . No es necesario ir al directorio del entorno virtual para realizar esta operaci\u00f3n: (env)$ deactivate El prompt de la terminal indica que el entorno virtual ha sido desactivado con \u00e9xito. 4.1.6. C\u00f3mo instalar paquetes en un entorno virtual de Python Despu\u00e9s de activarlo, lo \u00fanico que resta es instalar los paquetes que sean necesarios usando el instalador de paquetes pip . Al momento de crear un entorno virtual, la utilidad virtualenv instala de manera autom\u00e1tica el ejecutable pip . Por ejemplo, para instalar Django se ejecuta el siguiente comando: (env)$ pip install Django N\u00f3tese que el prompt de la terminal indica que el entorno virtual env est\u00e1 activado de antemano. 4.1.7. \u00bfEn qu\u00e9 directorio ubico el c\u00f3digo fuente de mi proyecto? La ubicaci\u00f3n del c\u00f3digo fuente del proyecto en el que se est\u00e1 trabajando no es importante. Puede ser colocado inclusive dentro del directorio del entorno virtual. Una vez que el entorno virtual est\u00e1 activado, todas las librer\u00edas de Python que se instalen solo podr\u00e1n ser usadas al activar ese entorno virtual espec\u00edfico. 4.1.8. Instrucciones de instalaci\u00f3n de virtualenv de EDX Para comprobar si tenemos VirtualEnv instalado: virtualenv Para instalar VirtualEnv: sudo apt install virtualenv Para crear un directorio donde almacenar los entornos virtuales: mkdir ~/.virtualenvs Para crear el entorno virtual: virtualenv ~/.virtualenvs/web Impedir la instalaci\u00f3n de m\u00f3dulos fuera de un entorno virtual: export PIP REQUIRE VIRTUALENV =true Permitir eliminar el valor de dicha variable de entorno: unset PIP REQUIRE VIRTUALENV Instalar m\u00f3dulo pprint: pip3 install pprint Para abrir fichero bashrc y especificar en \u00e9l que debe haber un entorno activo para la instalaci\u00f3n de m\u00f3dulos: emacs .bashrc & Activar entorno virtual: source .virtualens/web/bin/activate Desactivar el entorno virtual: deactivate Para conocer qu\u00e9 Python se est\u00e1 ejecutando: which python3 Instalar m\u00f3dulo Flask (necesario tener el entorno virtual web activado): pip3 install flask 4.2. VirtualEnvWrapper VirtualEnvWrapper es una utilidad de Python con la que podemos trabajar con entornos virtuales (creando, activando y desactivando) de forma equivalente a lo que has visto en el v\u00eddeo. Si quieres utilizarla (no es necesario), tendr\u00e1s que instalarla a trav\u00e9s de pip: $ sudo pip3 install virtualenvwrapper Antes de empezar a trabajar con la utilidad, es necesario configurarla, lo cual significa fijar dos variables de entorno e invocar un script. Podemos fijar las variables desde la terminal, pero es m\u00e1s c\u00f3modo hacerlo en el bashrc para que cada vez que arranques una sesi\u00f3n de bash, estas variables se fijen. Para ello, abrimos el fichero con un editor de texto como emacs: $ emacs .bashrc & La primera variable de entorno que necesito es el WORKON HOME , que es equivalente al directorio ~/.virtualenvs. B\u00e1sicamente lo que le est\u00e1 diciendo al wrapper es d\u00f3nde est\u00e1 el directorio con los entornos virtuales. Escribimos al final del fichero: export WORKON<sub>HOME</sub>=~/.virtualenvs\u201d Con VIRTUALENVWRAPPER PYTHON le estamos diciendo qu\u00e9 versi\u00f3n de Python queremos que utilice el wrapper: export VIRTUALENVWRAPPER<sub>PYTHON</sub>=/usr/bin/python3 Y por \u00faltimo hay que invocar a este script, que fija las variables de entorno para que el wrapper funcione: ./usr/local/bin/virtualenvwrapper.sh. Tambi\u00e9n podemos fijar en este archivo la variable VIRTUALENV para que no nos permita instalar ni desinstalar nada si no es un entorno virtual activo: export PIP<sub>REQUIRE</sub><sub>VIRTUALENV</sub>=true Importante: guarda los cambios hechos en el fichero bash. A partir de ahora, con el comando workon puedo saber los entornos virtuales que tengo en mi m\u00e1quina, en el directorio que hemos especificado, y me permite adem\u00e1s activar en un entorno virtual concreto: $ workon web Para desactivarlo, utilizamos el comando: $ deactivate Para crear un nuevo entorno virtual: $ mkvirtualenv web2 Para borrar un entorno virtual, utilizo: $ rmvirtualenv web2 5 Entornos virtuales en Visual Studio Codium/Code Un entorno consta de un int\u00e9rprete y cualquier n\u00famero de paquetes instalados. La extensi\u00f3n de Python para VS Codium/Code proporciona funciones de integraci\u00f3n \u00fatiles para trabajar con diferentes entornos. 5.1. Seleccionar y activar un entorno De forma predeterminada, la extensi\u00f3n de Python busca y usa el primer int\u00e9rprete de Python que encuentra en la ruta del sistema. Si no encuentra un int\u00e9rprete, emite una advertencia (en cualquier caso, se puede deshabilitar estas advertencias configurando python.disableInstallationCheck en true en la configuraci\u00f3n de usuario). Para seleccionar un entorno espec\u00edfico, usar Python: Select Interpreter en la Paleta de comandos( Ctrl+Shift+P ). Se puede cambiar de entorno en cualquier momento; los entornos de conmutaci\u00f3n ayudan a probar diferentes partes de un proyecto con diferentes int\u00e9rpretes o versiones de biblioteca seg\u00fan sea necesario. El comando Python: Select Interpreter muestra una lista de los entornos globales disponibles, los entornos conda y los entornos virtuales . La siguiente imagen, por ejemplo, muestra varias instalaciones de Anaconda y CPython junto con un entorno conda y un entorno virtual (env) que se encuentra dentro de la carpeta del espacio de trabajo. Al seleccionar un int\u00e9rprete de la lista, se agrega una entrada para python.pythonPath con la ruta al int\u00e9rprete dentro de la Configuraci\u00f3n del \u00e1rea de trabajo. Debido a que la ruta forma parte de la configuraci\u00f3n del espacio de trabajo, el mismo entorno ya deber\u00eda estar seleccionado cada vez que se abra ese espacio de trabajo. La extensi\u00f3n de Python utiliza el entorno seleccionado para ejecutar el c\u00f3digo de Python (usando el comando Python: Run Python file , proporcionando servicios del lenguaje (autocompletar, verificaci\u00f3n de sintaxis, linting, formateo, etc.) cuando se tiene un archivo .py abierto en el editor, y abre un terminal con el comando Terminal: Create a New Integrated Terminal . En este \u00faltimo caso, VS Codium/Code activ\u00f3 autom\u00e1ticamente el entorno seleccionado. Para evitar la activaci\u00f3n autom\u00e1tica de un entorno seleccionado, agregar \"python.terminal.activateEnvironment\": false al archivo settings.json (se puede colocar en cualquier lugar como hermano de la configuraci\u00f3n existente). De manera predeterminada, VS Codium/Code usa el int\u00e9rprete identificado por la configuraci\u00f3n de python:pythonPath al depurar el c\u00f3digo. Puede anular este comportamiento especificando una ruta diferente en la propiedad pythonPath de una configuraci\u00f3n de depuraci\u00f3n. La barra de estado siempre muestra el int\u00e9rprete actual. La barra de estado tambi\u00e9n refleja cuando no se selecciona ning\u00fan int\u00e9rprete. En cualquier caso, hacer clic en esta \u00e1rea de la barra de estado es un atajo conveniente para el comando Python: Select Interpreter . Entornos y ventanas de terminal Despu\u00e9s de usar Python: Select Interpreter , ese int\u00e9rprete se aplica al hacer clic con el bot\u00f3n derecho en un archivo y seleccionar Python: Run Python File en la Terminal. El entorno tambi\u00e9n se activa autom\u00e1ticamente cuando usa el comando Terminal: Create New Integrated Terminal , a menos que se cambie la configuraci\u00f3n de python.terminal.activateEnvironment a false . Sin embargo, el lanzamiento de VS Codium/Code desde un shell en el que se activa un determinado entorno de Python no activa autom\u00e1ticamente ese entorno en el terminal integrado predeterminado. Usar el comando Terminal: Create new Integrated Terminal despu\u00e9s de que se est\u00e9 ejecutando el c\u00f3digo VS. Cualquier cambio que realice en un entorno activado dentro del terminal es persistente . Por ejemplo, al utilizar conda install <package> desde el terminal con un entorno conda activado, se instala el paquete en ese entorno de forma permanente. De manera similar, el uso de pip install en un terminal con un entorno virtual activado agrega el paquete a ese entorno. El cambio de int\u00e9rpretes con el comando Python: Select Interpreter no afecta a los paneles de terminales que ya est\u00e1n abiertos. De este modo, se puede activar entornos separados en un terminal dividido: seleccione el primer int\u00e9rprete, cree un terminal para \u00e9l, seleccione un int\u00e9rprete diferente y luego use el bot\u00f3n dividir ( +\\) en la barra de t\u00edtulo del terminal. Elegir un entorno de depuraci\u00f3n De forma predeterminada, la configuraci\u00f3n python.pythonPath especifica el int\u00e9rprete de Python que se usar\u00e1 para la depuraci\u00f3n. Sin embargo, si se tiene una propiedad pythonPath en la configuraci\u00f3n de depuraci\u00f3n de launch.json , se usa ese int\u00e9rprete en su lugar. Para ser m\u00e1s espec\u00edficos, VS Codium/Code aplica el siguiente orden de precedencia al determinar qu\u00e9 int\u00e9rprete usar para la depuraci\u00f3n: Propiedad pythonPath de la configuraci\u00f3n de depuraci\u00f3n seleccionada en launch.json Configuraci\u00f3n de python.pythonPath en el espacio de trabajo de settings.json Configuraci\u00f3n de python.pythonPath en setting del usuario settings.json Para obtener m\u00e1s detalles sobre la configuraci\u00f3n de depuraci\u00f3n, consultar Depuraci\u00f3n de configuraciones . \u00bfD\u00f3nde busca la extensi\u00f3n de Python los entornos virtuales? La extensi\u00f3n busca autom\u00e1ticamente int\u00e9rpretes en las siguientes ubicaciones: Rutas de instalaci\u00f3n est\u00e1ndar como /usr/local/bin , /usr/sbin , /sbin , c:\\python27 , c:\\python36 , etc. Entornos virtuales ubicados directamente debajo de la carpeta del \u00e1rea de trabajo (proyecto). Los entornos virtuales ubicados en la carpeta identificada por la configuraci\u00f3n python.venvPath , que puede contener m\u00faltiples entornos virtuales. La extensi\u00f3n busca entornos virtuales en las subcarpetas de primer nivel de venvPath . Int\u00e9rpretes instalados por pyenv. Un entorno pipenv para la carpeta de trabajo. Si se encuentra uno, no se busca ni se enumera ning\u00fan otro int\u00e9rprete, ya que pipenv espera gestionar todos los aspectos del entorno. Los entornos Conda que contienen un int\u00e9rprete de Python. VS Codium/Code no muestra los entornos de Conda que no contienen un int\u00e9rprete. Int\u00e9rpretes instalados en una carpeta .direnv por direnv bajo la carpeta (proyecto) de trabajo. Tambi\u00e9n se puede especificar manualmente un int\u00e9rprete si VS Codium/Code no lo localiza autom\u00e1ticamente. La extensi\u00f3n tambi\u00e9n carga un archivo de definiciones de variables de entorno identificado por el fichero de configuraci\u00f3n python.envFile . El valor predeterminado de esta configuraci\u00f3n es ${workspaceFolder}/.env . Entornos globales, virtuales y conda. De forma predeterminada, cualquier int\u00e9rprete de Python que se haya instalado se ejecuta en su propio entorno global, que no es espec\u00edfico de ning\u00fan proyecto. Por ejemplo, si solo se ejecuta python o python3 en un nuevo s\u00edmbolo del sistema, se est\u00e1 ejecutando en el entorno global de ese int\u00e9rprete. En consecuencia, cualquier paquete que se instale o desinstale afectar\u00e1 el entorno global y todos los programas que se ejecuten dentro de ese contexto. Aunque trabajar en el entorno global es una forma f\u00e1cil de comenzar, con el tiempo, ese entorno se llenar\u00e1 de muchos paquetes diferentes que habr\u00e1n instalado para diferentes proyectos. Tal desorden hace que sea dif\u00edcil probar una aplicaci\u00f3n a fondo contra un conjunto espec\u00edfico de paquetes con versiones conocidas, que es exactamente el tipo de entorno que se configurar\u00eda en un servidor de compilaci\u00f3n o servidor web. Por esta raz\u00f3n, los desarrolladores a menudo crean un entorno virtual para un proyecto. Un entorno virtual es una subcarpeta en un proyecto que contiene una copia de un int\u00e9rprete espec\u00edfico. Cuando se activa el entorno virtual, los paquetes que se instalen lo har\u00e1n solo en la subcarpeta de ese entorno. Cuando luego se ejecuta un programa Python dentro de ese entorno, sabe que se est\u00e1 ejecutando solo contra esos paquetes espec\u00edficos. Un entorno de Conda es un entorno de Python que se administra mediante el gestor de paquetes conda (consultar Comenzar con conda ). Conda funciona bien para crear entornos con dependencias interrelacionadas, as\u00ed como paquetes binarios. A diferencia de los entornos virtuales, que est\u00e1n incluidos en un proyecto, los entornos de Conda est\u00e1n disponibles globalmente en cualquier computadora. Esta disponibilidad hace que sea f\u00e1cil configurar varios entornos de conda distintos y luego elegir el adecuado para cualquier proyecto dado. Como se se\u00f1al\u00f3 anteriormente, la extensi\u00f3n de Python detecta autom\u00e1ticamente los entornos de conda existentes siempre que el entorno contenga un int\u00e9rprete de Python. Por ejemplo, el siguiente comando crea un entorno conda con el int\u00e9rprete de Python 3.4 y varias bibliotecas, que el C\u00f3digo VS luego muestra en la lista de int\u00e9rpretes disponibles: conda create -n env-01 python=3.4 scipy=0.15.0 astroid babel Por el contrario, si no se especifica un int\u00e9rprete, como con conda create --name env-00 , el entorno no aparecer\u00e1 en la lista. Para obtener m\u00e1s informaci\u00f3n sobre la l\u00ednea de comandos de conda, consulte Entornos de Conda . Especificar manualmente un int\u00e9rprete Si VS Codium/Code no localiza autom\u00e1ticamente el int\u00e9rprete que desea usar, puede configurar la ruta de acceso manualmente en su archivo del \u00e1rea de trabajo settings.json . Con cualquiera de las entradas que siguen, se puede agregar la l\u00ednea como un a\u00f1adido m\u00e1s a otras configuraciones existentes.) Primero, seleccione el comando de men\u00fa File > Preferences > Settings ( +,) para abrir la Configuraci\u00f3n, seleccionar Workspace . A continuaci\u00f3n, realizar cualquiera de los siguientes pasos: Crear o modificar una entrada para python.pythonPath con la ruta completa al ejecutable de Python (si se edita settings.json directamente, agregar la siguiente l\u00ednea como configuraci\u00f3n): Por ejemplo: Windows: \"python.pythonPath\" : \"c:/python36/python.exe\" macOS / Linux: \"python.pythonPath\" : \"/home/python36/python\" Tambi\u00e9n se puede usar python.pythonPath para apuntar a un entorno virtual, por ejemplo: Windows: \u201cpython.pythonPath\u201d : \u201cc:/dev/ala/venv/Scripts/python.exe\u201d macOS / Linux: \u201cpython.pythonPath\u201d : \u201c/home/abc/dev/ala/venv/bin/python\u201d Se puede usar una variable de entorno en la configuraci\u00f3n de ruta usando la sintaxis ${env:VARIABLE} . Por ejemplo, si se ha creado una variable llamada PYTHON_INSTALL_LOC con una ruta a un int\u00e9rprete, se puede usar el siguiente valor de configuraci\u00f3n: \u201cpython.pythonPath\u201d : \u201c${env:PYTHON INSTALL LOC }\u201d Al usar una variable de entorno, se puede transferir f\u00e1cilmente un proyecto entre sistemas operativos donde las rutas son diferentes, solo hay que asegurarse de establecer primero la variable de entorno en el sistema operativo. Archivo de definiciones de variables de entorno Un archivo de definiciones de variables de entorno es un archivo de texto simple que contiene pares clave-valor en forma de variable_de_entorno=valor , con # utilizado para comentarios. Los valores de multil\u00ednea no son compatibles, pero los valores pueden referirse a cualquier otra variable de entorno que ya est\u00e9 definida en el sistema o anterior en el archivo. De forma predeterminada, la extensi\u00f3n de Python busca y carga un archivo llamado .env en la carpeta del \u00e1rea de trabajo actual, luego aplica esas definiciones. El archivo se identifica mediante la entrada predeterminada \"python.envFile\": \"${workspaceFolder}/.env\" en la configuraci\u00f3n del usuario. Se puede cambiar la configuraci\u00f3n de python.envFile en cualquier momento para usar un archivo de definiciones diferente. Una configuraci\u00f3n de depuraci\u00f3n tambi\u00e9n contiene una propiedad envFile que tambi\u00e9n se establece de manera predeterminada en el archivo .env en el \u00e1rea de trabajo actual. Esta propiedad permite establecer f\u00e1cilmente variables para fines de depuraci\u00f3n que reemplazan las variables especificadas en el archivo .env predeterminado. Por ejemplo, al desarrollar una aplicaci\u00f3n web, es posible que se desee cambiar f\u00e1cilmente entre los servidores de desarrollo y de producci\u00f3n. En lugar de codificar las diferentes URL y otras configuraciones en la aplicaci\u00f3n directamente, se pueden usar archivos de definiciones separados para cada una. Por ejemplo: Archivo dev.env # dev.env - development configuration # API endpoint MYPROJECT_APIENDPOINT=https://my.domain.com/api/dev/ # Variables for the database MYPROJECT_DBURL=https://my.domain.com/db/dev MYPROJECT_DBUSER=devadmin MYPROJECT_DBPASSWORD=!dfka**213= Archivo prod.env # prod.env - production configuration # API endpoint MYPROJECT_APIENDPOINT=https://my.domain.com/api/ # Variables for the database MYPROJECT_DBURL=https://my.domain.com/db/ MYPROJECT_DBUSER=coreuser MYPROJECT_DBPASSWORD=kKKfa98*11@ A continuaci\u00f3n, se puede establecer la configuraci\u00f3n python.envFile a ${workspaceFolder}/prod.env , luego establecer la propiedad envFile en la configuraci\u00f3n de depuraci\u00f3n en ${workspaceFolder}/dev.env . Sustituci\u00f3n de variables Al definir una variable de entorno en un archivo de definiciones, se puede utilizar el valor de cualquier variable de entorno existente con la siguiente sintaxis general: <VARIABLE>=... ${EXISTING_VARIABLE} ... donde ... significa cualquier otro texto usado en el valor. Las llaves son necesarias. Dentro de esta sintaxis, se aplican las siguientes reglas: Las variables se procesan en el orden en que aparecen en el archivo .env , por lo que se puede usar cualquier variable que se haya definido anteriormente en el archivo. Las comillas simples o dobles no afectan el valor sustituido y se incluyen en el valor definido. Por ejemplo, si el valor de VAR1 es abcedfg , entonces VAR2='${OTHERVAR}' asigna el valor 'abcedfg' a VAR2 . El car\u00e1cter $ se puede escapar con una barra invertida, como en \\$ . Se puede usar la sustituci\u00f3n recursiva, como PYTHONPATH=${PROJ_DIR}:${PYTHONPATH} (donde PROJ_DIR es cualquier otra variable de entorno). Se puede usar solo la sustituci\u00f3n simple; anidar como ${_${OTHERVAR}_EX} no es compatible. Las entradas con sintaxis no admitida se dejan como est\u00e1n. Uso de la variable PYTHONPATH La variable de entorno PYTHONPATH especifica ubicaciones adicionales donde el int\u00e9rprete de Python debe buscar m\u00f3dulos. El valor de PYTHONPATH puede contener m\u00faltiples valores de ruta separados por os.pathsep (puntos y coma en Windows, dos puntos en Linux/macOS). Las rutas no v\u00e1lidas se ignoran. Nota: se debe configurar la variable PYTHONPATH a trav\u00e9s del sistema operativo, ya que VS Codium/Code no proporciona un medio para establecer las variables de entorno directamente. En el C\u00f3digo VS, PYTHONPATH afecta la depuraci\u00f3n, el linting, el IntelliSense, las pruebas de unidades y cualquier otra operaci\u00f3n que dependa de los m\u00f3dulos de resoluci\u00f3n de Python. Por ejemplo, suponga que se tiene el c\u00f3digo fuente en una carpeta src y las pruebas en una carpeta de tests. Sin embargo, al ejecutar pruebas, normalmente no pueden acceder a los m\u00f3dulos en src menos que se codifiquen las rutas relativas. Para resolver este problema, se agrega la ruta a src a PYTHONPATH . Se recomienda que establezca la variable PYTHONPATH en un archivo de definiciones de variable de entorno, descrito anteriormente. Nota: PYTHONPATH no, repetimos no , especifica una ruta al int\u00e9rprete de Python y, por lo tanto, nunca se usa con la configuraci\u00f3n python.pythonPath . Claramente, la variable de entorno est\u00e1 mal llamada, pero\u2026 c\u2019est la vie . As\u00ed que asegurarse de leer la documentaci\u00f3n de PYTHONPATH varias veces y t\u00e9ngase en cuenta que PYTHONPATH no es un camino a un int\u00e9rprete . Bootstrap Instalar con: $ pipenv install bootstrap4","title":"Entornos Virtuales"},{"location":"entornos_virtuales/#1-introduccion","text":"Un entorno virtual de Python es un ambiente creado con el objetivo de aislar recursos , como las librer\u00edas y el entorno de ejecuci\u00f3n, del sistema principal o de otros entornos virtuales. Lo anterior significa que en el mismo sistema, m\u00e1quina o computadora, es posible tener instaladas m\u00faltiples versiones de una misma librer\u00eda sin crear ning\u00fan tipo de conflicto. Cuando se est\u00e1 desarrollando software con Python, es com\u00fan utilizar diferentes versiones de un mismo paquete . Por ejemplo, imaginemos que se est\u00e1 desarrollando un videojuego con la versi\u00f3n 1.2 de pygame y mientras eso pasa, se comienza el desarrollo de otro videojuego que necesita las nuevas caracter\u00edsticas presentes en la versi\u00f3n 1.3. En este escenario, no es posible para los desarrolladores eliminar la version 1.2 e instalar la 1.3 en sus computadoras. As\u00ed que el problema a solucionar radica en c\u00f3mo instalar las dos versiones de la misma librer\u00eda con el fin de poder desarrollar ambos proyectos de forma simult\u00e1nea. La soluci\u00f3n consiste en crear entornos virtuales . De esta manera, es posible instalar la versi\u00f3n 1.2 de pygame en un entorno virtual y la versi\u00f3n 1.3 en otro diferente o en el sistema principal sin problema alguno. Para poder utilizar este simple pero poderoso concepto es necesario instalar una utilidad que permita gestionar la creaci\u00f3n y utilizaci\u00f3n de dichos entornos virtuales. Hay muchas \u00e1reas de desarrollo de software sobre las que se debaten acaloradamente, pero el uso de entornos virtuales para el desarrollo de Python no es uno de ellos. Hist\u00f3ricamente, los desarrolladores de Python han usado virtualenv o pyenv para configurar entornos virtuales. Pero en 2017 el destacado desarrollador de Python Kenneth Reitz lanz\u00f3 pipenv , que ahora es la herramienta de empaquetado Python recomendada oficialmente por PyPa ( Python Packaging Authority ). pipenv es similar a npm y yarn del ecosistema Node: Crea un Pipfile con las dependencias de software Crea un Pipfile.lock para asegurar construcciones deterministas . \u00c9stos son archivos que buscan reemplazar el antiguo requirements.txt de virtualenv y pyenv con la sintaxis TOML ( Tom\u2019s Obvious, Minimal Language ) para declarar todo tipo de dependencias. Un solo archivo Pipfile para reemplazar la variedad de requirements.txt . Ejemplo dev-requirements , test-requirements , etc. El determinismo se refiere a que cada vez que se descargue el software en un nuevo entorno virtual, tendr\u00e1 exactamente la misma configuraci\u00f3n . Sebastian McKenzie , el creador de yarn que introdujo por primera vez este concepto al empaquetado de JavaScript, tiene una publicaci\u00f3n en su blog concisa que explica qu\u00e9 es el determinismo y por qu\u00e9 es importante. Los problemas que pipenv busca resolver son multifac\u00e9ticos: No se necesitar\u00e1 usar m\u00e1s pip y virtualenv separados. Trabajan juntos. Manejar un archivo requirements.txt puede ser problem\u00e1tico, por eso Pipenv usa en su lugar Pipfile y Pipfile.lock , que son superiores para usos b\u00e1sicos Los Hashes se usan en todas partes, siempre. Seguridad. Autom\u00e1ticamente expone vulnerabilidades de seguridad. Se recomienda encarecidamente el uso de las \u00faltimas versiones de dependencias para minimizar los riesgos de seguridad derivados de componentes obsoletos. Da una vista del \u00e1rbol de dependecias (por ejemplo $ pipenv graph ). Agiliza el flujo de desarrollo cargando archivos .env . La conclusi\u00f3n es que se debe crear un nuevo entorno virtual para cada nuevo proyecto en python .","title":"1. Introducci\u00f3n"},{"location":"entornos_virtuales/#2-instalar-pipenv","text":"Si bien pip puede instalar paquetes de Python, se recomienda pipenv ya que es una herramienta de nivel superior que simplifica la administraci\u00f3n de dependencias para casos de uso comunes.","title":"2. Instalar pipenv"},{"location":"entornos_virtuales/#21-instalacion-en-arch-y-derivadas-arcolinux-manjaro-anarchy-etc","text":"Afortunadamente, dentro de los repositorios oficiales de Arch, se encuentra el paquete python-pipenv con lo que la instalaci\u00f3n se convierte en algo tan sencillo como introducir el comando: $ pacman -S python-pipenv","title":"2.1. Instalaci\u00f3n en Arch y derivadas (ArcoLinux, Manjaro, Anarchy, etc.)"},{"location":"entornos_virtuales/#22-instalacion-en-debian-y-derivadas","text":"Se usar\u00e1 pip3 para instalar pipenv por tanto, debe estar instalado previamente. Para ello se usar\u00e1: $ sudo apt install python3-pip Gracias a pip3 podemos instalar ahora pipenv . $ pip3 install --user pipenv Esto hace una instalaci\u00f3n de usuario para evitar romper cualquier paquete de todo el sistema. Si pipenv no est\u00e1 disponible en su shell despu\u00e9s de la instalaci\u00f3n , deber\u00e1 agregar el directorio binario de la base de usuarios a su PATH. Se puede encontrar el directorio binario de la base de usuarios ejecutando python -m site --user-base y agregando bin al final. Por ejemplo, esto normalmente imprimir\u00e1 ~/.local (con ~ expandido a la ruta absoluta a su directorio de inicio) por lo que deber\u00e1 agregar ~/.local/bin al PATH. Se puede establecer el PATH permanentemente modificando ~/.profile . Deber\u00eda bastar con recargar ~/.profile usando: source ~/.profile","title":"2.2. Instalaci\u00f3n en Debian y derivadas"},{"location":"entornos_virtuales/#23-para-usuarios-de-zsh","text":"El comportamiento de zsh es algo distinto ya que se basa en usar un fichero de configurari\u00f3n diferente a los habituales de Bash, por tanto, la instalaci\u00f3n del nuevo $PATH depender\u00e1 ahora de configurar convenientemente el fichero .zshrc a\u00f1adi\u00e9ndole lo siguiente como primeras l\u00edneas de c\u00f3digo: # If you come from bash you might have to change your $PATH. export PATH=$HOME/bin:/usr/local/bin:$PATH # set PATH so it includes user's private bin if it exists if [ -d \"$HOME/.local/bin\" ] ; then PATH=\"$HOME/.local/bin:$PATH\" fi","title":"2.3. Para usuarios de zsh"},{"location":"entornos_virtuales/#3-instalando-paquetes-del-proyecto","text":"pipenv gestiona las dependencias por proyecto. Para instalar paquetes, cambiar al directorio del proyecto (o simplemente usar un directorio vac\u00edo) y ejecutar: $ cd myproject $ pipenv install request Pipenv instalar\u00e1 la excelente biblioteca request y crear\u00e1 un archivo pipfile en el directorio del proyecto. pipfile se usa para rastrear qu\u00e9 dependencias necesita el proyecto en caso de que se necesite volver a instalarlas, como cuando se comparte el proyecto con otros.","title":"3. Instalando paquetes del proyecto"},{"location":"entornos_virtuales/#31-usar-los-paquetes-instalados","text":"Ahora que las solicitudes est\u00e1n instaladas, se puede crear un archivo main.py simple para usarlo: import requests response = requests.get('https://httpbin.org/ip') print('Su IP en Internet es {0}'.format(response.json()['origin'].split(',')[0])) Luego se puede ejecutar este script usando pipenv run : $ pipenv run python main.py ..y obtener una salida similar a esta: Su IP es 8.8.8.8 El uso de $ pipenv run asegura que los paquetes instalados est\u00e9n disponibles para el script. Tambi\u00e9n es posible generar un nuevo shell que garantice que todos los comandos tengan acceso a sus paquetes instalados con $ pipenv shell .","title":"3.1. Usar los paquetes instalados"},{"location":"entornos_virtuales/#otro-ejemplo-pipenv-y-django","text":"Crear un nuevo directorio y entrar en \u00e9l. $ cd $ mkdir django $ cd django Ahora se usa pipenv para instalar django $ pipenv install django Si se mira en el directorio, ahora hay dos nuevos archivos: Pipfile y Pipfile.lock . Se tiene la informaci\u00f3n que se necesita para el nuevo entorno virtual pero a\u00fan no ha sido activado. Se hace con: $ pipenv shell Deber\u00eda verse ahora el nombre del entorno envuelto entre par\u00e9ntesis precediendo al prompt . Si ahora se puede ejecutar django-admin startproject a continuaci\u00f3n es que Django se ha instalado correctamente. Lanzar entonces lo siguiente: (django) $ django-admin startproject test_project . El . al final del comando no crear\u00e1 un directorio adicional para test_project pero s\u00ed todos los subdirectorios que se necesitan para la aplicaci\u00f3n, en resumidas cuentas, se har\u00e1 una instalaci\u00f3n en el directorio en curso. Se puede comprobar que todo funciona arrancando el servidor web local con: (django) $ python manage.py runserver Si se visita http://127.0.0.1:8000/ se deber\u00eda ver la p\u00e1gina inicial de Django. El servidor se parar\u00e1 con C-c y se saldr\u00e1 del entorno virtual con el comando exit .","title":"Otro ejemplo: pipenv y Django"},{"location":"entornos_virtuales/#32-desinstalar-un-projecto","text":"pipenv --rm","title":"3.2. Desinstalar un projecto"},{"location":"entornos_virtuales/#33-advertencia-mapeo-de-virtualenv","text":"Pipenv asigna autom\u00e1ticamente proyectos a sus virtualenvs espec\u00edficos. El virtualenv se almacena globalmente con el nombre del directorio ra\u00edz del proyecto m\u00e1s el hash de la ruta completa a la ra\u00edz del proyecto (por ejemplo, my_project-a3de50 ). Si cambia la ruta de su proyecto, interrumpe dicha asignaci\u00f3n predeterminada y pipenv ya no podr\u00e1 encontrar y usar el virtualenv del proyecto. Es posible que desee establecer la exportaci\u00f3n PIPENV_VENV_IN_PROJECT = 1 en su .bashrc/.zshrc (o cualquier archivo de configuraci\u00f3n de shell) para crear el virtualenv dentro del directorio de su proyecto, evitando problemas con los cambios de ruta posteriores.","title":"3.3. Advertencia: mapeo de Virtualenv"},{"location":"entornos_virtuales/#4-otros-entornos-de-virtualizacion-de-python","text":"","title":"4. Otros entornos de virtualizaci\u00f3n de python"},{"location":"entornos_virtuales/#41-virtualenv","text":"","title":"4.1. virtualenv"},{"location":"entornos_virtuales/#411-como-instalar-virtualenv","text":"Se puede instalar la utilidad virtualenv utilizando el gestor de paquetes de las diferentes distribuciones Linux: Los siguientes comandos instalar\u00e1n la utilidad virtualenv para las versiones 2 y 3 de Python. $ sudo apt-get install python-virtualenv virtualenv Tambi\u00e9n es posible instalar virtualenv utilizando el instalador de paquetes de Python pip: $ sudo pip install virtualenv","title":"4.1.1. C\u00f3mo instalar virtualenv"},{"location":"entornos_virtuales/#412-como-crear-un-entorno-virtual-de-python-con-virtualenv","text":"virtualenv con Python 3 Para crear un entorno virtual con Python 3, simplemente ejecutamos el comando virtualenv de la siguiente manera: $ virtualenv <entorno> --python=python3 Python 3 debe estar instalado de antemano para poder crear el entorno virtual. virtualenv con Python 2 Para crear un entorno virtual con Python 2, simplemente ejecutamos el comando virtualenv de la siguiente manera: $ virtualenv <entorno> Lamentablemente, no es posible crear un entorno virtual que contenga las dos versiones de Python al mismo tiempo.","title":"4.1.2. C\u00f3mo crear un entorno virtual de Python con virtualenv"},{"location":"entornos_virtuales/#413-estructura-de-un-entorno-virtual-de-python","text":"La ejecuci\u00f3n de comandos anteriormente explicados crean el directorio <entorno>/ con la siguiente estructura: env/ bin/ include/ lib/ site-packages/ En el directorio bin/ se encuentran los ejecutables necesarios para interactuar con el entorno virtual. En el directorio include/ se encuentran algunos archivos de cabecera de C (cuya extensi\u00f3n es *.h) necesarios para compilar algunas librer\u00edas de Python. Finalmente, en el directorio lib/ se encuentra una copia de la instalaci\u00f3n de Python as\u00ed como un directorio llamado site-packages/ en donde se almacenan los paquetes Python instalados en el entorno virtual.","title":"4.1.3. Estructura de un entorno virtual de Python"},{"location":"entornos_virtuales/#414-como-activar-un-entorno-virtual-de-python-con-virtualenv","text":"Para activar un entorno virtual de Python, se ejecuta el script activate de virtualenv instalado en el directorio bin/ : $ cd env $ source bin/activate \u00f3 $ . bin/activate (env)$ El prompt de la terminal indica que el entorno virtual mi_proyecto est\u00e1 activado. Ya es posible utilizar los paquetes Python instalados en el entorno virtual as\u00ed como instalar paquetes adicionales.","title":"4.1.4. C\u00f3mo activar un entorno virtual de Python con virtualenv"},{"location":"entornos_virtuales/#415-como-desactivar-un-entorno-virtual-de-python-con-virtualenv","text":"Para desactivar un entorno virtual, porque se necesita trabajar en otro diferente, se ejecuta el comando deactivate de virtualenv . No es necesario ir al directorio del entorno virtual para realizar esta operaci\u00f3n: (env)$ deactivate El prompt de la terminal indica que el entorno virtual ha sido desactivado con \u00e9xito.","title":"4.1.5. C\u00f3mo desactivar un entorno virtual de Python con virtualenv"},{"location":"entornos_virtuales/#416-como-instalar-paquetes-en-un-entorno-virtual-de-python","text":"Despu\u00e9s de activarlo, lo \u00fanico que resta es instalar los paquetes que sean necesarios usando el instalador de paquetes pip . Al momento de crear un entorno virtual, la utilidad virtualenv instala de manera autom\u00e1tica el ejecutable pip . Por ejemplo, para instalar Django se ejecuta el siguiente comando: (env)$ pip install Django N\u00f3tese que el prompt de la terminal indica que el entorno virtual env est\u00e1 activado de antemano.","title":"4.1.6. C\u00f3mo instalar paquetes en un entorno virtual de Python"},{"location":"entornos_virtuales/#417-en-que-directorio-ubico-el-codigo-fuente-de-mi-proyecto","text":"La ubicaci\u00f3n del c\u00f3digo fuente del proyecto en el que se est\u00e1 trabajando no es importante. Puede ser colocado inclusive dentro del directorio del entorno virtual. Una vez que el entorno virtual est\u00e1 activado, todas las librer\u00edas de Python que se instalen solo podr\u00e1n ser usadas al activar ese entorno virtual espec\u00edfico.","title":"4.1.7. \u00bfEn qu\u00e9 directorio ubico el c\u00f3digo fuente de mi proyecto?"},{"location":"entornos_virtuales/#418-instrucciones-de-instalacion-de-virtualenv-de-edx","text":"Para comprobar si tenemos VirtualEnv instalado: virtualenv Para instalar VirtualEnv: sudo apt install virtualenv Para crear un directorio donde almacenar los entornos virtuales: mkdir ~/.virtualenvs Para crear el entorno virtual: virtualenv ~/.virtualenvs/web Impedir la instalaci\u00f3n de m\u00f3dulos fuera de un entorno virtual: export PIP REQUIRE VIRTUALENV =true Permitir eliminar el valor de dicha variable de entorno: unset PIP REQUIRE VIRTUALENV Instalar m\u00f3dulo pprint: pip3 install pprint Para abrir fichero bashrc y especificar en \u00e9l que debe haber un entorno activo para la instalaci\u00f3n de m\u00f3dulos: emacs .bashrc & Activar entorno virtual: source .virtualens/web/bin/activate Desactivar el entorno virtual: deactivate Para conocer qu\u00e9 Python se est\u00e1 ejecutando: which python3 Instalar m\u00f3dulo Flask (necesario tener el entorno virtual web activado): pip3 install flask","title":"4.1.8. Instrucciones de instalaci\u00f3n de virtualenv de EDX"},{"location":"entornos_virtuales/#42-virtualenvwrapper","text":"VirtualEnvWrapper es una utilidad de Python con la que podemos trabajar con entornos virtuales (creando, activando y desactivando) de forma equivalente a lo que has visto en el v\u00eddeo. Si quieres utilizarla (no es necesario), tendr\u00e1s que instalarla a trav\u00e9s de pip: $ sudo pip3 install virtualenvwrapper Antes de empezar a trabajar con la utilidad, es necesario configurarla, lo cual significa fijar dos variables de entorno e invocar un script. Podemos fijar las variables desde la terminal, pero es m\u00e1s c\u00f3modo hacerlo en el bashrc para que cada vez que arranques una sesi\u00f3n de bash, estas variables se fijen. Para ello, abrimos el fichero con un editor de texto como emacs: $ emacs .bashrc & La primera variable de entorno que necesito es el WORKON HOME , que es equivalente al directorio ~/.virtualenvs. B\u00e1sicamente lo que le est\u00e1 diciendo al wrapper es d\u00f3nde est\u00e1 el directorio con los entornos virtuales. Escribimos al final del fichero: export WORKON<sub>HOME</sub>=~/.virtualenvs\u201d Con VIRTUALENVWRAPPER PYTHON le estamos diciendo qu\u00e9 versi\u00f3n de Python queremos que utilice el wrapper: export VIRTUALENVWRAPPER<sub>PYTHON</sub>=/usr/bin/python3 Y por \u00faltimo hay que invocar a este script, que fija las variables de entorno para que el wrapper funcione: ./usr/local/bin/virtualenvwrapper.sh. Tambi\u00e9n podemos fijar en este archivo la variable VIRTUALENV para que no nos permita instalar ni desinstalar nada si no es un entorno virtual activo: export PIP<sub>REQUIRE</sub><sub>VIRTUALENV</sub>=true Importante: guarda los cambios hechos en el fichero bash. A partir de ahora, con el comando workon puedo saber los entornos virtuales que tengo en mi m\u00e1quina, en el directorio que hemos especificado, y me permite adem\u00e1s activar en un entorno virtual concreto: $ workon web Para desactivarlo, utilizamos el comando: $ deactivate Para crear un nuevo entorno virtual: $ mkvirtualenv web2 Para borrar un entorno virtual, utilizo: $ rmvirtualenv web2","title":"4.2. VirtualEnvWrapper"},{"location":"entornos_virtuales/#5-entornos-virtuales-en-visual-studio-codiumcode","text":"Un entorno consta de un int\u00e9rprete y cualquier n\u00famero de paquetes instalados. La extensi\u00f3n de Python para VS Codium/Code proporciona funciones de integraci\u00f3n \u00fatiles para trabajar con diferentes entornos.","title":"5 Entornos virtuales en Visual Studio Codium/Code"},{"location":"entornos_virtuales/#51-seleccionar-y-activar-un-entorno","text":"De forma predeterminada, la extensi\u00f3n de Python busca y usa el primer int\u00e9rprete de Python que encuentra en la ruta del sistema. Si no encuentra un int\u00e9rprete, emite una advertencia (en cualquier caso, se puede deshabilitar estas advertencias configurando python.disableInstallationCheck en true en la configuraci\u00f3n de usuario). Para seleccionar un entorno espec\u00edfico, usar Python: Select Interpreter en la Paleta de comandos( Ctrl+Shift+P ). Se puede cambiar de entorno en cualquier momento; los entornos de conmutaci\u00f3n ayudan a probar diferentes partes de un proyecto con diferentes int\u00e9rpretes o versiones de biblioteca seg\u00fan sea necesario. El comando Python: Select Interpreter muestra una lista de los entornos globales disponibles, los entornos conda y los entornos virtuales . La siguiente imagen, por ejemplo, muestra varias instalaciones de Anaconda y CPython junto con un entorno conda y un entorno virtual (env) que se encuentra dentro de la carpeta del espacio de trabajo. Al seleccionar un int\u00e9rprete de la lista, se agrega una entrada para python.pythonPath con la ruta al int\u00e9rprete dentro de la Configuraci\u00f3n del \u00e1rea de trabajo. Debido a que la ruta forma parte de la configuraci\u00f3n del espacio de trabajo, el mismo entorno ya deber\u00eda estar seleccionado cada vez que se abra ese espacio de trabajo. La extensi\u00f3n de Python utiliza el entorno seleccionado para ejecutar el c\u00f3digo de Python (usando el comando Python: Run Python file , proporcionando servicios del lenguaje (autocompletar, verificaci\u00f3n de sintaxis, linting, formateo, etc.) cuando se tiene un archivo .py abierto en el editor, y abre un terminal con el comando Terminal: Create a New Integrated Terminal . En este \u00faltimo caso, VS Codium/Code activ\u00f3 autom\u00e1ticamente el entorno seleccionado. Para evitar la activaci\u00f3n autom\u00e1tica de un entorno seleccionado, agregar \"python.terminal.activateEnvironment\": false al archivo settings.json (se puede colocar en cualquier lugar como hermano de la configuraci\u00f3n existente). De manera predeterminada, VS Codium/Code usa el int\u00e9rprete identificado por la configuraci\u00f3n de python:pythonPath al depurar el c\u00f3digo. Puede anular este comportamiento especificando una ruta diferente en la propiedad pythonPath de una configuraci\u00f3n de depuraci\u00f3n. La barra de estado siempre muestra el int\u00e9rprete actual. La barra de estado tambi\u00e9n refleja cuando no se selecciona ning\u00fan int\u00e9rprete. En cualquier caso, hacer clic en esta \u00e1rea de la barra de estado es un atajo conveniente para el comando Python: Select Interpreter . Entornos y ventanas de terminal Despu\u00e9s de usar Python: Select Interpreter , ese int\u00e9rprete se aplica al hacer clic con el bot\u00f3n derecho en un archivo y seleccionar Python: Run Python File en la Terminal. El entorno tambi\u00e9n se activa autom\u00e1ticamente cuando usa el comando Terminal: Create New Integrated Terminal , a menos que se cambie la configuraci\u00f3n de python.terminal.activateEnvironment a false . Sin embargo, el lanzamiento de VS Codium/Code desde un shell en el que se activa un determinado entorno de Python no activa autom\u00e1ticamente ese entorno en el terminal integrado predeterminado. Usar el comando Terminal: Create new Integrated Terminal despu\u00e9s de que se est\u00e9 ejecutando el c\u00f3digo VS. Cualquier cambio que realice en un entorno activado dentro del terminal es persistente . Por ejemplo, al utilizar conda install <package> desde el terminal con un entorno conda activado, se instala el paquete en ese entorno de forma permanente. De manera similar, el uso de pip install en un terminal con un entorno virtual activado agrega el paquete a ese entorno. El cambio de int\u00e9rpretes con el comando Python: Select Interpreter no afecta a los paneles de terminales que ya est\u00e1n abiertos. De este modo, se puede activar entornos separados en un terminal dividido: seleccione el primer int\u00e9rprete, cree un terminal para \u00e9l, seleccione un int\u00e9rprete diferente y luego use el bot\u00f3n dividir ( +\\) en la barra de t\u00edtulo del terminal. Elegir un entorno de depuraci\u00f3n De forma predeterminada, la configuraci\u00f3n python.pythonPath especifica el int\u00e9rprete de Python que se usar\u00e1 para la depuraci\u00f3n. Sin embargo, si se tiene una propiedad pythonPath en la configuraci\u00f3n de depuraci\u00f3n de launch.json , se usa ese int\u00e9rprete en su lugar. Para ser m\u00e1s espec\u00edficos, VS Codium/Code aplica el siguiente orden de precedencia al determinar qu\u00e9 int\u00e9rprete usar para la depuraci\u00f3n: Propiedad pythonPath de la configuraci\u00f3n de depuraci\u00f3n seleccionada en launch.json Configuraci\u00f3n de python.pythonPath en el espacio de trabajo de settings.json Configuraci\u00f3n de python.pythonPath en setting del usuario settings.json Para obtener m\u00e1s detalles sobre la configuraci\u00f3n de depuraci\u00f3n, consultar Depuraci\u00f3n de configuraciones . \u00bfD\u00f3nde busca la extensi\u00f3n de Python los entornos virtuales? La extensi\u00f3n busca autom\u00e1ticamente int\u00e9rpretes en las siguientes ubicaciones: Rutas de instalaci\u00f3n est\u00e1ndar como /usr/local/bin , /usr/sbin , /sbin , c:\\python27 , c:\\python36 , etc. Entornos virtuales ubicados directamente debajo de la carpeta del \u00e1rea de trabajo (proyecto). Los entornos virtuales ubicados en la carpeta identificada por la configuraci\u00f3n python.venvPath , que puede contener m\u00faltiples entornos virtuales. La extensi\u00f3n busca entornos virtuales en las subcarpetas de primer nivel de venvPath . Int\u00e9rpretes instalados por pyenv. Un entorno pipenv para la carpeta de trabajo. Si se encuentra uno, no se busca ni se enumera ning\u00fan otro int\u00e9rprete, ya que pipenv espera gestionar todos los aspectos del entorno. Los entornos Conda que contienen un int\u00e9rprete de Python. VS Codium/Code no muestra los entornos de Conda que no contienen un int\u00e9rprete. Int\u00e9rpretes instalados en una carpeta .direnv por direnv bajo la carpeta (proyecto) de trabajo. Tambi\u00e9n se puede especificar manualmente un int\u00e9rprete si VS Codium/Code no lo localiza autom\u00e1ticamente. La extensi\u00f3n tambi\u00e9n carga un archivo de definiciones de variables de entorno identificado por el fichero de configuraci\u00f3n python.envFile . El valor predeterminado de esta configuraci\u00f3n es ${workspaceFolder}/.env . Entornos globales, virtuales y conda. De forma predeterminada, cualquier int\u00e9rprete de Python que se haya instalado se ejecuta en su propio entorno global, que no es espec\u00edfico de ning\u00fan proyecto. Por ejemplo, si solo se ejecuta python o python3 en un nuevo s\u00edmbolo del sistema, se est\u00e1 ejecutando en el entorno global de ese int\u00e9rprete. En consecuencia, cualquier paquete que se instale o desinstale afectar\u00e1 el entorno global y todos los programas que se ejecuten dentro de ese contexto. Aunque trabajar en el entorno global es una forma f\u00e1cil de comenzar, con el tiempo, ese entorno se llenar\u00e1 de muchos paquetes diferentes que habr\u00e1n instalado para diferentes proyectos. Tal desorden hace que sea dif\u00edcil probar una aplicaci\u00f3n a fondo contra un conjunto espec\u00edfico de paquetes con versiones conocidas, que es exactamente el tipo de entorno que se configurar\u00eda en un servidor de compilaci\u00f3n o servidor web. Por esta raz\u00f3n, los desarrolladores a menudo crean un entorno virtual para un proyecto. Un entorno virtual es una subcarpeta en un proyecto que contiene una copia de un int\u00e9rprete espec\u00edfico. Cuando se activa el entorno virtual, los paquetes que se instalen lo har\u00e1n solo en la subcarpeta de ese entorno. Cuando luego se ejecuta un programa Python dentro de ese entorno, sabe que se est\u00e1 ejecutando solo contra esos paquetes espec\u00edficos. Un entorno de Conda es un entorno de Python que se administra mediante el gestor de paquetes conda (consultar Comenzar con conda ). Conda funciona bien para crear entornos con dependencias interrelacionadas, as\u00ed como paquetes binarios. A diferencia de los entornos virtuales, que est\u00e1n incluidos en un proyecto, los entornos de Conda est\u00e1n disponibles globalmente en cualquier computadora. Esta disponibilidad hace que sea f\u00e1cil configurar varios entornos de conda distintos y luego elegir el adecuado para cualquier proyecto dado. Como se se\u00f1al\u00f3 anteriormente, la extensi\u00f3n de Python detecta autom\u00e1ticamente los entornos de conda existentes siempre que el entorno contenga un int\u00e9rprete de Python. Por ejemplo, el siguiente comando crea un entorno conda con el int\u00e9rprete de Python 3.4 y varias bibliotecas, que el C\u00f3digo VS luego muestra en la lista de int\u00e9rpretes disponibles: conda create -n env-01 python=3.4 scipy=0.15.0 astroid babel Por el contrario, si no se especifica un int\u00e9rprete, como con conda create --name env-00 , el entorno no aparecer\u00e1 en la lista. Para obtener m\u00e1s informaci\u00f3n sobre la l\u00ednea de comandos de conda, consulte Entornos de Conda . Especificar manualmente un int\u00e9rprete Si VS Codium/Code no localiza autom\u00e1ticamente el int\u00e9rprete que desea usar, puede configurar la ruta de acceso manualmente en su archivo del \u00e1rea de trabajo settings.json . Con cualquiera de las entradas que siguen, se puede agregar la l\u00ednea como un a\u00f1adido m\u00e1s a otras configuraciones existentes.) Primero, seleccione el comando de men\u00fa File > Preferences > Settings ( +,) para abrir la Configuraci\u00f3n, seleccionar Workspace . A continuaci\u00f3n, realizar cualquiera de los siguientes pasos: Crear o modificar una entrada para python.pythonPath con la ruta completa al ejecutable de Python (si se edita settings.json directamente, agregar la siguiente l\u00ednea como configuraci\u00f3n): Por ejemplo: Windows: \"python.pythonPath\" : \"c:/python36/python.exe\" macOS / Linux: \"python.pythonPath\" : \"/home/python36/python\" Tambi\u00e9n se puede usar python.pythonPath para apuntar a un entorno virtual, por ejemplo: Windows: \u201cpython.pythonPath\u201d : \u201cc:/dev/ala/venv/Scripts/python.exe\u201d macOS / Linux: \u201cpython.pythonPath\u201d : \u201c/home/abc/dev/ala/venv/bin/python\u201d Se puede usar una variable de entorno en la configuraci\u00f3n de ruta usando la sintaxis ${env:VARIABLE} . Por ejemplo, si se ha creado una variable llamada PYTHON_INSTALL_LOC con una ruta a un int\u00e9rprete, se puede usar el siguiente valor de configuraci\u00f3n: \u201cpython.pythonPath\u201d : \u201c${env:PYTHON INSTALL LOC }\u201d Al usar una variable de entorno, se puede transferir f\u00e1cilmente un proyecto entre sistemas operativos donde las rutas son diferentes, solo hay que asegurarse de establecer primero la variable de entorno en el sistema operativo.","title":"5.1. Seleccionar y activar un entorno"},{"location":"entornos_virtuales/#archivo-de-definiciones-de-variables-de-entorno","text":"Un archivo de definiciones de variables de entorno es un archivo de texto simple que contiene pares clave-valor en forma de variable_de_entorno=valor , con # utilizado para comentarios. Los valores de multil\u00ednea no son compatibles, pero los valores pueden referirse a cualquier otra variable de entorno que ya est\u00e9 definida en el sistema o anterior en el archivo. De forma predeterminada, la extensi\u00f3n de Python busca y carga un archivo llamado .env en la carpeta del \u00e1rea de trabajo actual, luego aplica esas definiciones. El archivo se identifica mediante la entrada predeterminada \"python.envFile\": \"${workspaceFolder}/.env\" en la configuraci\u00f3n del usuario. Se puede cambiar la configuraci\u00f3n de python.envFile en cualquier momento para usar un archivo de definiciones diferente. Una configuraci\u00f3n de depuraci\u00f3n tambi\u00e9n contiene una propiedad envFile que tambi\u00e9n se establece de manera predeterminada en el archivo .env en el \u00e1rea de trabajo actual. Esta propiedad permite establecer f\u00e1cilmente variables para fines de depuraci\u00f3n que reemplazan las variables especificadas en el archivo .env predeterminado. Por ejemplo, al desarrollar una aplicaci\u00f3n web, es posible que se desee cambiar f\u00e1cilmente entre los servidores de desarrollo y de producci\u00f3n. En lugar de codificar las diferentes URL y otras configuraciones en la aplicaci\u00f3n directamente, se pueden usar archivos de definiciones separados para cada una. Por ejemplo: Archivo dev.env # dev.env - development configuration # API endpoint MYPROJECT_APIENDPOINT=https://my.domain.com/api/dev/ # Variables for the database MYPROJECT_DBURL=https://my.domain.com/db/dev MYPROJECT_DBUSER=devadmin MYPROJECT_DBPASSWORD=!dfka**213= Archivo prod.env # prod.env - production configuration # API endpoint MYPROJECT_APIENDPOINT=https://my.domain.com/api/ # Variables for the database MYPROJECT_DBURL=https://my.domain.com/db/ MYPROJECT_DBUSER=coreuser MYPROJECT_DBPASSWORD=kKKfa98*11@ A continuaci\u00f3n, se puede establecer la configuraci\u00f3n python.envFile a ${workspaceFolder}/prod.env , luego establecer la propiedad envFile en la configuraci\u00f3n de depuraci\u00f3n en ${workspaceFolder}/dev.env . Sustituci\u00f3n de variables Al definir una variable de entorno en un archivo de definiciones, se puede utilizar el valor de cualquier variable de entorno existente con la siguiente sintaxis general: <VARIABLE>=... ${EXISTING_VARIABLE} ... donde ... significa cualquier otro texto usado en el valor. Las llaves son necesarias. Dentro de esta sintaxis, se aplican las siguientes reglas: Las variables se procesan en el orden en que aparecen en el archivo .env , por lo que se puede usar cualquier variable que se haya definido anteriormente en el archivo. Las comillas simples o dobles no afectan el valor sustituido y se incluyen en el valor definido. Por ejemplo, si el valor de VAR1 es abcedfg , entonces VAR2='${OTHERVAR}' asigna el valor 'abcedfg' a VAR2 . El car\u00e1cter $ se puede escapar con una barra invertida, como en \\$ . Se puede usar la sustituci\u00f3n recursiva, como PYTHONPATH=${PROJ_DIR}:${PYTHONPATH} (donde PROJ_DIR es cualquier otra variable de entorno). Se puede usar solo la sustituci\u00f3n simple; anidar como ${_${OTHERVAR}_EX} no es compatible. Las entradas con sintaxis no admitida se dejan como est\u00e1n.","title":"Archivo de definiciones de variables de entorno"},{"location":"entornos_virtuales/#uso-de-la-variable-pythonpath","text":"La variable de entorno PYTHONPATH especifica ubicaciones adicionales donde el int\u00e9rprete de Python debe buscar m\u00f3dulos. El valor de PYTHONPATH puede contener m\u00faltiples valores de ruta separados por os.pathsep (puntos y coma en Windows, dos puntos en Linux/macOS). Las rutas no v\u00e1lidas se ignoran. Nota: se debe configurar la variable PYTHONPATH a trav\u00e9s del sistema operativo, ya que VS Codium/Code no proporciona un medio para establecer las variables de entorno directamente. En el C\u00f3digo VS, PYTHONPATH afecta la depuraci\u00f3n, el linting, el IntelliSense, las pruebas de unidades y cualquier otra operaci\u00f3n que dependa de los m\u00f3dulos de resoluci\u00f3n de Python. Por ejemplo, suponga que se tiene el c\u00f3digo fuente en una carpeta src y las pruebas en una carpeta de tests. Sin embargo, al ejecutar pruebas, normalmente no pueden acceder a los m\u00f3dulos en src menos que se codifiquen las rutas relativas. Para resolver este problema, se agrega la ruta a src a PYTHONPATH . Se recomienda que establezca la variable PYTHONPATH en un archivo de definiciones de variable de entorno, descrito anteriormente. Nota: PYTHONPATH no, repetimos no , especifica una ruta al int\u00e9rprete de Python y, por lo tanto, nunca se usa con la configuraci\u00f3n python.pythonPath . Claramente, la variable de entorno est\u00e1 mal llamada, pero\u2026 c\u2019est la vie . As\u00ed que asegurarse de leer la documentaci\u00f3n de PYTHONPATH varias veces y t\u00e9ngase en cuenta que PYTHONPATH no es un camino a un int\u00e9rprete .","title":"Uso de la variable PYTHONPATH"},{"location":"entornos_virtuales/#bootstrap","text":"Instalar con: $ pipenv install bootstrap4","title":"Bootstrap"},{"location":"integracion_continua_con_python/","text":"Integraci\u00f3n Continua con Python Al escribir c\u00f3digo por su cuenta, la \u00fanica prioridad es hacerlo funcionar. Sin embargo, trabajar en un equipo de desarrolladores de software profesionales conlleva una gran cantidad de desaf\u00edos. Uno de esos desaf\u00edos es coordinar a muchas personas que trabajan en el mismo c\u00f3digo. \u00bfC\u00f3mo hacen los equipos profesionales docenas de cambios por d\u00eda mientras se aseguran de que todos est\u00e9n coordinados y que nada se rompa? \u00a1Bienvenidos a la integraci\u00f3n continua! \u00bfQu\u00e9 es la integraci\u00f3n continua? La integraci\u00f3n continua (CI - Continuous Integration ) es la pr\u00e1ctica de generar y probar con frecuencia cada cambio realizado en el c\u00f3digo autom\u00e1ticamente y lo antes posible. El desarrollador y autor prol\u00edfico Martin Fowler define CI de la siguiente manera: \u201cLa integraci\u00f3n continua es una pr\u00e1ctica de desarrollo de software donde los miembros de un equipo integran su trabajo con frecuencia, generalmente cada persona se integra al menos diariamente, lo que lleva a m\u00faltiples integraciones por d\u00eda. Cada integraci\u00f3n se verifica mediante una compilaci\u00f3n automatizada (incluida la prueba) para detectar errores de integraci\u00f3n lo m\u00e1s r\u00e1pido posible\". ( Fuente ) La programaci\u00f3n es iterativa . El c\u00f3digo fuente vive en un repositorio compartido por todos los miembros del equipo. Si se desea trabajar en ese producto, se debe tener una copia. Se har\u00e1n cambios, se probar\u00e1n e integrar\u00e1n nuevamente en el repositorio principal. \"Enjuagar y repetir\". No hace mucho tiempo, estas integraciones eran grandes y estaban separadas por semanas (o meses), causando dolores de cabeza, perdiendo el tiempo y perdiendo dinero. Armados con experiencia, los desarrolladores comenzaron a hacer cambios menores para integrarlos con m\u00e1s frecuencia. Esto reduce las posibilidades de introducir conflictos que se deban resolver m\u00e1s adelante. \u00bfPor qu\u00e9 deber\u00eda importarme? La integraci\u00f3n continua trata realmente de en qu\u00e9 pasan el tiempo los programadores. Con CI, se pasar\u00e1 menos tiempo: Preocupados por introducir un error cada vez que se realizan cambios Arreglando el desastre que alguien m\u00e1s hizo para que poder integrar nuevo c\u00f3digo Asegurando que el c\u00f3digo funciona en cada m\u00e1quina, sistema operativo y navegador Por el contrario, se pasar\u00e1 m\u00e1s tiempo: - Resolviendo problemas interesantes - Escribiendo un c\u00f3digo incre\u00edble en equipo - Co-creando productos incre\u00edbles que brinden valor a los usuarios \u00bfComo suena eso? A nivel de equipo, permite una mejor cultura de ingenier\u00eda, donde se entrega valor temprano y con frecuencia . Se fomenta la colaboraci\u00f3n y los errores se detectan mucho antes . La integraci\u00f3n continua: - Hace al equipo desarrollar m\u00e1s r\u00e1pido - Le damos la confianza de que est\u00e1n creando software estable con menos errores - Se asegura que el producto funciona en otras m\u00e1quinas, no solo en su computadora port\u00e1til - Se eliminan muchos gastos generales tediosos y permite que se concentrarse en lo que importa - Se reduce el tiempo dedicado a resolver conflictos (cuando diferentes personas modifican el mismo c\u00f3digo) Conceptos b\u00e1sicos Hay varias ideas y pr\u00e1cticas clave que se debe comprender para trabajar eficazmente con una integraci\u00f3n continua. Adem\u00e1s, puede haber algunas palabras y frases con las que no se est\u00e9 familiarizado, pero que se usan con frecuencia cuando habla de CI. Este cap\u00edtulo le presentar\u00e1 estos conceptos y la jerga que viene con ellos. Repositorio de fuente \u00fanica Si se est\u00e1 colaborando con otros en una sola base de c\u00f3digo, es t\u00edpico tener un repositorio compartido de c\u00f3digo fuente. Cada desarrollador que trabaja en el proyecto crea una copia local y realiza cambios. Una vez que se est\u00e1 satisfecho con los cambios, se fusionan nuevamente en el repositorio central. Se ha convertido en un est\u00e1ndar usar sistemas de control de versiones (VCS) como Git para manejar este flujo de trabajo. Los equipos suelen utilizar un servicio externo para alojar su c\u00f3digo fuente y manejar todas las partes m\u00f3viles. Los m\u00e1s populares son GitHub, BitBucket y GitLab. Git permite crear m\u00faltiples ramas de un repositorio. Cada rama es una copia independiente del c\u00f3digo fuente y se puede modificar sin afectar a otras ramas. Esta es una caracter\u00edstica esencial, y la mayor\u00eda de los equipos tienen una rama principal (a menudo llamada rama maestra) que representa el estado actual del proyecto. Si se desea agregar o modificar c\u00f3digo, debe crear una copia de la rama principal y trabajar en su nueva rama de desarrollo. Una vez que haya terminado, combine esos cambios nuevamente en la rama maestra. El control de versiones contiene m\u00e1s que solo c\u00f3digo. La documentaci\u00f3n y los scripts de prueba generalmente se almacenan junto con el c\u00f3digo fuente. Algunos programas buscan archivos externos utilizados para configurar sus par\u00e1metros y configuraciones iniciales. Otras aplicaciones necesitan un esquema de base de datos. Todos estos archivos deben ir al repositorio. Si nunca ha usado Git o necesita un repaso, consultar Introducci\u00f3n a Git y GitHub para desarrolladores de Python . Automatizando la construcci\u00f3n (Build) Construir c\u00f3digo ( build ) significa tomar el c\u00f3digo fuente sin procesar, y todo lo necesario para su ejecuci\u00f3n, y traducirlo a un formato que las computadoras puedan ejecutar directamente. Python es un lenguaje interpretado , por lo que su \"compilaci\u00f3n\" gira principalmente en torno a la ejecuci\u00f3n de pruebas en lugar de la compilaci\u00f3n. Ejecutar esos pasos manualmente despu\u00e9s de cada peque\u00f1o cambio es tedioso y requiere tiempo y atenci\u00f3n valiosos de la resoluci\u00f3n de problemas reales que se est\u00e1 tratando de resolver. Una gran parte de la integraci\u00f3n continua es automatizar ese proceso y quitarlo de la vista (y de la mente). \u00bfQu\u00e9 significa eso para Python? Piensar en el c\u00f3digo m\u00e1s complicado posible. Si se us\u00f3 una biblioteca, paquete o marco que no viene con la biblioteca est\u00e1ndar (pensar en todo lo que se necesita para instalar con pip , conda \u00f3 pipenv ), Python necesita saberlo, para que el programa sepa d\u00f3nde buscar cuando encuentre comandos que no reconoce. Se almacena una lista de esos paquetes en require.txt o en un Pipfile . Estas son las dependencias del c\u00f3digo y son necesarias para una compilaci\u00f3n exitosa. A menudo se escucha la frase \"se rompi\u00f3 la compilaci\u00f3n\". Cuando se rompe la compilaci\u00f3n, significa que se introdujo un cambio que dej\u00f3 inutilizable el producto final. Pasa en las mejores familias, incluso a los desarrolladores senior endurecidos por la batalla. Se desea evitar esto principalmente porque esto impedir\u00e1 que el resto trabaje. El objetivo de CI es que todos trabajen en una base estable conocida. Si clonan un repositorio que se rompre durante la compilaci\u00f3n, trabajar\u00e1n con una versi\u00f3n da\u00f1ada del c\u00f3digo y no podr\u00e1n introducir o probar sus cambios. Cuando la compilaci\u00f3n est\u00e1 rota, la principal prioridad es arreglarla para que todos puedan reanudar el trabajo. Cuando la compilaci\u00f3n es autom\u00e1tica, se recomienda que se acometa con frecuencia, generalmente varias veces al d\u00eda. Esto descubrir r\u00e1pidamente los cambios y notar si hay un conflicto entre dos desarrolladores. Si hay numerosos cambios peque\u00f1os en lugar de algunas actualizaciones masivas, es mucho m\u00e1s f\u00e1cil localizar d\u00f3nde se origin\u00f3 el error. Tambi\u00e9n se alenta a dividir el trabajo en trozos m\u00e1s peque\u00f1os, por lo que es m\u00e1s f\u00e1cil de rastrear y probar. Pruebas automatizadas Dado que todos est\u00e1n realizando cambios varias veces al d\u00eda, es importante saber que un cambio no rompi\u00f3 nada m\u00e1s en el c\u00f3digo ni se introdujeron errores. En muchas empresas, las pruebas son ahora responsabilidad de cada desarrollador. Si se escribe c\u00f3digo, se debe escribir pruebas. Como m\u00ednimo, se debe cubrir cada nueva funci\u00f3n con una prueba unitaria. Ejecutar pruebas autom\u00e1ticamente, con cada cambio comprometido, es una excelente manera de detectar errores. Una prueba fallida hace que la compilaci\u00f3n falle autom\u00e1ticamente. Llamar\u00e1 la atenci\u00f3n sobre los problemas revelados por las pruebas, y la compilaci\u00f3n fallida har\u00e1 corregir el error que se introdujo. Las pruebas no garantizan que el c\u00f3digo est\u00e9 libre de errores, pero protege contra muchos cambios descuidados. Automatizar la ejecuci\u00f3n de la prueba da tranquilidad porque as\u00ed, el servidor probar\u00e1 el c\u00f3digo cada vez que se comprometa, incluso si se olvid\u00f3 hacerlo localmente. Uso de un servicio externo de integraci\u00f3n continua Si algo funciona en un ordenador, \u00bffuncionar\u00e1 en todos? Probablemente no. Es una excusa clich\u00e9 y una especie de broma interna entre los desarrolladores decir: \"\u00a1Bueno, funcion\u00f3 en mi m\u00e1quina!\". Hacer que el c\u00f3digo funcione localmente no es el fin de la responsabilidad. Para abordar este problema, la mayor\u00eda de las empresas utilizan un servicio externo para manejar la integraci\u00f3n; al igual que GitHub aloja el repositorio de c\u00f3digo fuente. Los servicios externos tienen servidores donde crean c\u00f3digo y ejecutan pruebas. Act\u00faan como monitores para su repositorio y evitan que cualquier cosa se fusione con la rama maestra si los cambios rompen la compilaci\u00f3n. Existen muchos servicios de este tipo, con varias caracter\u00edsticas y precios. La mayor\u00eda tiene un nivel gratuito (CircleCI) para que se pueda experimentar con uno de sus repositorios. Pruebas en un entorno de ensayo Un entorno de producci\u00f3n es donde finalmente se ejecutar\u00e1 el software. Incluso despu\u00e9s de compilar y probar con \u00e9xito la aplicaci\u00f3n, no se puede estar seguro de que el c\u00f3digo funcionar\u00e1 en la computadora de destino. Es por eso que los equipos implementan el producto final en un entorno que imita el entorno de producci\u00f3n. Una vez que se est\u00e9 seguro de que todo funciona, la aplicaci\u00f3n se implementa en el entorno de producci\u00f3n. Nota: Este paso es m\u00e1s relevante para el c\u00f3digo de la aplicaci\u00f3n que el c\u00f3digo de la biblioteca. Las bibliotecas de Python que se escriban a\u00fan deben probarse en un servidor de compilaci\u00f3n, para garantizar que funcionen en entornos diferentes de su computadora local. Escuchar\u00e1 a las personas hablar sobre este clon del entorno de producci\u00f3n utilizando t\u00e9rminos como entorno de desarrollo, entorno de ensayo o entorno de prueba. Es com\u00fan usar abreviaturas como DEV para el entorno de desarrollo y PROD para el entorno de producci\u00f3n. El entorno de desarrollo debe replicar las condiciones de producci\u00f3n lo m\u00e1s cerca posible. Esta configuraci\u00f3n a menudo se llama paridad DEV/PROD . Hay que mantener el entorno en la computadora local lo m\u00e1s similar posible a los entornos DEV y PROD para minimizar las anomal\u00edas al implementar aplicaciones . Se menciona esto para presentar el vocabulario, pero la implementaci\u00f3n continua de software en DEV y PROD es un tema completamente diferente. El proceso se llama, como era de esperar, despliegue continuo (CD - Continuous Deploy ). Puede encontrar m\u00e1s recursos al respecto en la secci\u00f3n \u00a1Manos a la obra! La mejor manera de aprender es haciendo. Ahora que se comprenden todas las pr\u00e1cticas esenciales de la integraci\u00f3n continua, es hora de ensuciarse las manos y crear toda la cadena de pasos necesarios para usar CI. Esta cadena a menudo se llama una tuber\u00eda de CI. Se supone que se conocen los conceptos b\u00e1sicos de Python y Git. Utilizaremos Github como servicio de alojamiento y CircleCI como servicio externo de integraci\u00f3n continua. Si no se tiene cuenta con estos servicios, habr\u00e1 que registrarse. Definici\u00f3n del problema El enfoque aqu\u00ed es agregar una nueva herramienta a nuestro cintur\u00f3n de servicios p\u00fablicos, la integraci\u00f3n continua . Para este ejemplo, el c\u00f3digo Python en s\u00ed ser\u00e1 sencillo. Se desea pasar la mayor parte del tiempo interiorizando los pasos de la construcci\u00f3n de una tuber\u00eda, en lugar de escribir c\u00f3digo complicado. Imaginemos que el equipo est\u00e1 trabajando en una aplicaci\u00f3n de calculadora simple. La tarea es escribir una biblioteca de funciones matem\u00e1ticas b\u00e1sicas: suma, resta, multiplicaci\u00f3n y divisi\u00f3n. No importa la aplicaci\u00f3n real, porque eso es lo que los programadores desarrollar\u00e1n, utilizando las funciones de la biblioteca. Crear un repositorio Iniciar sesi\u00f3n en la cuenta de GitHub, crear un nuevo repositorio CalculatorLibrary . Agregar un archivo README.md y .gitignore , luego clonar el repositorio en la m\u00e1quina local. Si se necesita m\u00e1s ayuda con este proceso, echar un vistazo al tutorial de GitHub sobre c\u00f3mo crear un nuevo repositorio. Establecer un ambiente de trabajo Para que otros (y el servidor de CI) puedan replicar las condiciones de trabajo, se debe configurar un entorno. Crear un entorno virtual en alg\u00fan lugar fuera del repositorio y activarlo: # Crear entorno virtual $ mkdir CalculatorLibrary $ cd CalculatorLibrary $ pipenv shell Esto crear\u00e1 un directorio que contiene una instalaci\u00f3n de Python e indicar\u00e1 al int\u00e9rprete que lo use. Ahora podemos instalar paquetes sabiendo que no influir\u00e1 en la instalaci\u00f3n predeterminada de Python del sistema. Escribir un ejemplo simple de Python Crear un nuevo archivo llamado calculator.py en el directorio de nivel superior del repositorio y copiar el siguiente c\u00f3digo: \"\"\" Calculator library containing basic math operations. \"\"\" def add(first_term, second_term): return first_term + second_term def subtract(first_term, second_term): return first_term - second_term Este es un ejemplo b\u00e1sico que contiene dos de las cuatro funciones que escribiremos. Una vez que tengamos en funcionamiento nuestra canalizaci\u00f3n de CI, se agregar\u00e1n las dos funciones restantes. Continuar y confirmar esos cambios: # Asegarse de estar en el directorio correcto $ git add calculator.py $ git commit -m \"Agrega funciones para sumar y restar\" La carpeta CalculatorLibrary deber\u00eda tener los siguientes archivos en este momento: CalculatorLibrary / | \u251c\u2500\u2500 .git \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 README.md \u251c\u2500\u2500 calculator.py \u2514\u2500\u2500 Pipfile Genial, se ha completado una parte de la funcionalidad requerida. El siguiente paso es agregar pruebas para asegurarse de que el c\u00f3digo funcione de la manera en que se supone que debe hacerlo. Escribir pruebas unitarias Se probar\u00e1 el c\u00f3digo en dos pasos. El primer paso consiste en linting : ejecutar un programa, llamado linter , para analizar el c\u00f3digo en busca de posibles errores. flake8 se usa com\u00fanmente para verificar si su c\u00f3digo se ajusta al estilo de codificaci\u00f3n Python est\u00e1ndar. Linting asegura que el c\u00f3digo sea f\u00e1cil de leer para el resto de la comunidad de Python. El segundo paso es la prueba unitaria . Una prueba unitaria est\u00e1 dise\u00f1ada para verificar una sola funci\u00f3n, o unidad, de c\u00f3digo. Python viene con una biblioteca de prueba de unidad est\u00e1ndar, pero existen otras bibliotecas y son muy populares. En nuestro caso se usar\u00e1 pytest . Una pr\u00e1ctica est\u00e1ndar que va de la mano con las pruebas es calcular la cobertura del c\u00f3digo . Cobertura del c\u00f3digo .- es el porcentaje del c\u00f3digo fuente que est\u00e1 \"cubierto\" por sus pruebas*. pytest tiene una extensi\u00f3n, pytest-cov , que ayuda a comprender la cobertura de un c\u00f3digo. Estas son dependencias externas y deben ser instaladas: $ pipenv install flake8 pytest pytest-cov El fichero Pipfile almacenar\u00e1 todas las dependencias para poder replicar el entorno. Para lanzar el linter ejecutar: $ flake8 --statistics ./calculator.py:5:1: E302 expected 2 blank lines, found 1 ./calculator.py:8:1: E302 expected 2 blank lines, found 1 ./calculator.py:9:36: W292 no newline at end of file 2 E302 expected 2 blank lines, found 1 1 W292 no newline at end of file La opci\u00f3n --statistics brinda una visi\u00f3n general de cu\u00e1ntas veces ocurri\u00f3 un error en particular. Aqu\u00ed se ven dos violaciones de PEP 8, porque flake8 espera dos l\u00edneas en blanco antes de una definici\u00f3n de funci\u00f3n en lugar de una. Por tanto, hay que agregar una l\u00ednea vac\u00eda antes de cada definici\u00f3n de funciones. Ejecutar flake8 nuevamente para verificar que los mensajes de error ya no aparezcan. Ahora es el momento de escribir las pruebas. Crear un archivo llamado test_calculator.py en el directorio de nivel superior del repositorio y copiar el siguiente c\u00f3digo: \"\"\" Unit tests for the calculator library \"\"\" import calculator class TestCalculator: def test_addition(self): assert 4 == calculator.add(2, 2) def test_subtraction(self): assert 2 == calculator.subtract(4, 2) Estas pruebas aseguran que nuestro c\u00f3digo funcione como se esperaba. Est\u00e1 lejos de ser extenso porque no prueba el posible mal uso del c\u00f3digo, pero mant\u00e9ngase simple por ahora. El siguiente comando ejecuta la prueba: $ pytest -v --cov =================== test session starts ======================= platform linux -- Python 3.8.0, pytest-5.3.1, py-1.8.0, pluggy-0.13.1 -- /home/XXXXX/.local/share/virtualenvs/CalculatorLibrary-T3Wmr6pK/bin/python cachedir: .pytest_cache rootdir: /home/XXXXX/CalculatorLibrary plugins: cov-2.8.1 collected 2 items test_calculator.py::TestCalculator::test_addition PASSED [ 50%] test_calculator.py::TestCalculator::test_subtraction PASSED [100%] pytest es excelente en el descubrimiento de pruebas. Dado que se tiene un archivo con el prefijo test , pytest sabe que contendr\u00e1 pruebas unitarias que se ejecutar. Los mismos principios se aplican a los nombres de clases y m\u00e9todos dentro del archivo. El indicador -v da una salida m\u00e1s agradable e indica qu\u00e9 pruebas pasaron y cu\u00e1les fallaron. En este caso, se pasaron ambas pruebas. El indicador --cov asegura de que pytest-cov se ejecuta y proporciona un informe de cobertura de c\u00f3digo para calculator.py . Se han completado los preparativos. Confirmar el archivo de prueba y enviar todos esos cambios a la rama maestra: $ git add test_calculator.py $ git commit -m \"Agrega pruebas unitarias para calculator.py\" $ git push Al final de esta secci\u00f3n, la carpeta CalculatorLibrary debe tener los siguientes archivos: CalculatorLibrary/ | \u251c\u2500\u2500 .git \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 README.md \u251c\u2500\u2500 calculadora.py \u251c\u2500\u2500 Pipfile \u251c\u2500\u2500 Pipfile.lock \u2514\u2500\u2500 test_calculator.py Excelente, ambas funciones se prueban y funcionan correctamente. Conectar a CircleCI \u00a1Por fin, se est\u00e1 listo para configurar el canal de integraci\u00f3n continua! CircleCI necesita saber c\u00f3mo ejecutar su compilaci\u00f3n y espera que esa informaci\u00f3n se suministre en un formato particular. Requiere una carpeta .circleci dentro del repositorio y un archivo de configuraci\u00f3n dentro de \u00e9l. El archivo de configuraci\u00f3n contiene instrucciones para todos los pasos que el servidor de compilaci\u00f3n necesita ejecutar. CircleCI espera que este archivo se llame config.yml . Un archivo .yml usa un lenguaje de serializaci\u00f3n de datos, YAML, y tiene su propia especificaci\u00f3n . El objetivo de YAML es ser legible por humanos y funcionar bien con lenguajes de programaci\u00f3n modernos para tareas comunes y cotidianas. En un archivo YAML, hay tres formas b\u00e1sicas de representar datos: Mapeos (pares clave-valor) Secuencias (listas) Escalares (cadenas o n\u00fameros) Es muy simple de leer: La sangr\u00eda puede usarse para estructurar. Los dos puntos separan pares clave-valor. Los guiones se usan para crear listas. Crear la carpeta .circleci en el repositorio y un archivo config.yml con el siguiente contenido: # Python CircleCI 2.0 configuration file version: 2 jobs: build: docker: - image: circleci/python:3.7 working_directory: ~/repo steps: # Step 1: obtain repo from GitHub - checkout # Step 2: create virtual env and install dependencies - run: name: install dependencies command: | python3 -m venv venv . venv/bin/activate pip install -r requirements.txt # Step 3: run linter and tests - run: name: run tests command: | . venv/bin/activate flake8 --exclude=venv* --statistics pytest -v --cov=calculator Algunas de estas palabras y conceptos pueden no ser familiares. Por ejemplo, \u00bfqu\u00e9 es Docker y qu\u00e9 son las im\u00e1genes? Retrocedamos un poco en el tiempo. Retomemos el problema que enfrentan los programadores cuando algo funciona en su computadora port\u00e1til pero en ning\u00fan otro lugar. Los desarrolladores sol\u00edan crear un programa que aislaba una parte de los recursos f\u00edsicos de la computadora (memoria, disco duro, etc.) y los convert\u00eda en una m\u00e1quina virtual . Una m\u00e1quina virtual pretende ser una computadora completa por s\u00ed sola. Incluso tendr\u00eda su propio sistema operativo. En ese sistema operativo, despliega su aplicaci\u00f3n o instala su biblioteca y la prueba. Las m\u00e1quinas virtuales ocupan muchos recursos, lo que provoc\u00f3 la invenci\u00f3n de los contenedores. La idea es an\u00e1loga a los contenedores de env\u00edo. Antes de que se inventaran los contenedores de env\u00edo, los fabricantes ten\u00edan que enviar productos en una amplia variedad de tama\u00f1os, embalajes y modos (camiones, trenes, barcos). Al estandarizar el contenedor de env\u00edo, estos productos podr\u00edan transferirse entre diferentes m\u00e9todos de env\u00edo sin ninguna modificaci\u00f3n. La misma idea se aplica a los contenedores de software. Los contenedores son una unidad de c\u00f3digo liviana y sus dependencias de tiempo de ejecuci\u00f3n, empaquetados de manera estandarizada, por lo que pueden conectarse y ejecutarse r\u00e1pidamente en el sistema operativo Linux. No se necesita crear un sistema operativo virtual completo, como se har\u00eda con una m\u00e1quina virtual. Los contenedores solo replican las partes del sistema operativo que se necesita para funcionar. Esto reduce su tama\u00f1o y les da un gran impulso al rendimiento. Docker es actualmente la plataforma de contenedores l\u00edder, e incluso puede ejecutar contenedores de Linux en Windows y macOS. Para crear un contenedor Docker, se necesita una imagen Docker. Las im\u00e1genes proporcionan planos para contenedores al igual que las clases proporcionan planos para objetos. Puede leer m\u00e1s sobre Docker en su gu\u00eda de inicio . CircleCI mantiene im\u00e1genes Docker preconstruidas para varios lenguajes de programaci\u00f3n. En el archivo de configuraci\u00f3n anterior, se ha especificado una imagen de Linux que ya tiene Python instalado. Esa imagen crear\u00e1 un contenedor en el que suceder\u00e1 todo lo dem\u00e1s. Veamos cada l\u00ednea del archivo de configuraci\u00f3n una a una: version : cada config.yml comienza con el n\u00famero de versi\u00f3n CircleCI, utilizado para emitir advertencias sobre cambios importantes. jobs : Representan una sola ejecuci\u00f3n de la compilaci\u00f3n y se definen mediante una colecci\u00f3n de pasos. Si solo hay un trabajo, debe llamarse build . build : build es el nombre del trabajo. Pueden haber varios trabajos, en cuyo caso deben tener nombres \u00fanicos. docker : los pasos de un trabajo se producen en un entorno llamado ejecutor ( executor ). El ejecutor com\u00fan en CircleCI es un contenedor Docker . Es un entorno de ejecuci\u00f3n alojado en la nube , pero existen otras opciones, como un entorno macOS. image : una imagen Docker es un archivo utilizado para crear un contenedor Docker en ejecuci\u00f3n. Estamos utilizando una imagen que tiene preinstalado Python 3.7. working_directory : El repositorio debe ser extra\u00eddo en alg\u00fan lugar del servidor de compilaci\u00f3n. El directorio de trabajo representa la ruta del archivo donde se almacenar\u00e1 el repositorio. steps : Esta clave marca el inicio de una lista de pasos que debe realizar el servidor de compilaci\u00f3n. checkout : El primer paso que debe hacer el servidor es verificar el c\u00f3digo fuente en el directorio de trabajo. Esto se realiza mediante un paso especial llamado checkout . run : La ejecuci\u00f3n de programas o comandos de l\u00ednea de comandos se realiza dentro de la clave command . Los comandos shell reales estar\u00e1n anidados dentro. name : La interfaz de usuario CircleCI le muestra cada paso de compilaci\u00f3n en forma de una secci\u00f3n expandible. El t\u00edtulo de la secci\u00f3n se toma del valor asociado con la clave name . command : Esta clave representa el comando que se ejecuta a trav\u00e9s del shell. El | El s\u00edmbolo especifica que lo que sigue es un conjunto literal de comandos, uno por l\u00ednea, exactamente como se ver\u00eda en un script de shell/bash. Puede leer el documento de referencia de configuraci\u00f3n CircleCI para obtener m\u00e1s informaci\u00f3n. La tuber\u00eda es muy simple y consta de 3 pasos: Revisi\u00f3n del repositorio Instalar las dependencias en un entorno virtual Ejecuci\u00f3n del linter y las pruebas mientras se est\u00e1 dentro del entorno virtual Ahora tenemos todo lo que necesitamos para comenzar nuestra tuber\u00eda. Iniciar sesi\u00f3n en la cuenta CircleCI y hacer clic en Add Projects ( Agregar proyectos ) . Encuentrar el repositorio de CalculatorLibrary y hacer clic en Set Up Project ( Configurar proyecto ). Seleccionar Python como lenguaje. Como ya se cuenta con un config.yml , podemos omitir los siguientes pasos y hacer clic en Start building ( Iniciar construcci\u00f3n ). CircleCI lo llevar\u00e1 al panel de ejecuci\u00f3n para el trabajo. Si se siguieron todos los pasos correctamente, deber\u00eda ver que el trabajo es exitoso. La versi\u00f3n final de la carpeta CalculatorLibrary deber\u00eda verse as\u00ed: CalculatorRepository / | \u251c\u2500\u2500 .circleci \u251c\u2500\u2500 .git \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 README.md \u251c\u2500\u2500 calculadora.py \u251c\u2500\u2500 requisitos.txt \u2514\u2500\u2500 test_calculator.py \u00a1Felicidades! Se ha creado el primer canal de integraci\u00f3n continua. Ahora, cada vez que se haga un push a la rama maestra, se activar\u00e1 un trabajo. Puede ver una lista de sus trabajos actuales y pasados haciendo clic en Jobs en la barra lateral de CircleCI. Hacer cambios Es hora de agregar la multiplicaci\u00f3n a la biblioteca de calculadora. Esta vez, primero se agregara una prueba unitaria sin escribir la funci\u00f3n. Sin el c\u00f3digo, la prueba fallar\u00e1, lo que tambi\u00e9n fallar\u00e1 el trabajo CircleCI. Agregue el siguiente c\u00f3digo al final de su test_calculator.py : def test_multiplication (self): assert 100 == calculator.multiply(10, 10) Subir el c\u00f3digo ( push ) a la rama maestra y se ver\u00e1 que el trabajo falla en CircleCI. Esto muestra que la integraci\u00f3n continua funciona y nos cuida la espalda si se comete alg\u00fan error. Ahora agregar el c\u00f3digo a calculator.py que har\u00e1 pasar la prueba: def multiply(first_term, second_term): return first_term * second_term Asegurarse de que haya dos espacios vac\u00edos entre la funci\u00f3n de multiplicaci\u00f3n y la anterior, de lo contrario, el c\u00f3digo fallar\u00e1 en la verificaci\u00f3n de la interfaz. El trabajo deber\u00eda ser exitoso en esta ocasi\u00f3n. Este flujo de trabajo de escribir primero una prueba fallida y luego agregar el c\u00f3digo para pasar la prueba se llama desarrollo guiado por pruebas o Test Driven Development (TDD). Es una excelente manera de trabajar porque obliga a pensar de antemano en la estructura del c\u00f3digo. Ahora pru\u00e9balo por tu cuenta .- Agregar una prueba para la funci\u00f3n de divisi\u00f3n, ver c\u00f3mo falla y escribir la funci\u00f3n para que pueda pasarla. Notificaciones Cuando se trabaja en aplicaciones grandes que tienen muchas partes m\u00f3viles, puede llevar un tiempo ejecutar el trabajo de integraci\u00f3n continua. La mayor\u00eda de los equipos establecen un procedimiento de notificaci\u00f3n para informarles si uno de sus trabajos falla. Pueden continuar trabajando mientras esperan que se ejecute el trabajo. Las opciones m\u00e1s populares son: Enviar un correo electr\u00f3nico por cada compilaci\u00f3n fallida Env\u00edo de notificaciones de fallas a un canal de Slack Mostrar fallas en un tablero visible para todos Por defecto, CircleCI deber\u00eda enviarle un correo electr\u00f3nico cuando falla un trabajo. Pr\u00f3ximos pasos Se han explicado los conceptos b\u00e1sicos de la integraci\u00f3n continua y se ha practicado con la configuraci\u00f3n de una tuber\u00eda para un programa Python simple. Este es un gran paso adelante en el viaje de un desarrollador. Tal vez la pregunta es: \"\u00bfY ahora qu\u00e9?\" Para simplificar las cosas, se han tocado superficialmente algunos grandes temas. Se puede aumentar enormemente el conjunto de habilidades si se pasa un poco de tiempo profundizando en cada tema. Aqu\u00ed hay algunos temas que se pueden investigar m\u00e1s a fondo. Flujos de trabajo de Git Git tiene mucho m\u00e1s de lo que se ha usado aqu\u00ed. Cada equipo de desarrolladores tiene un flujo de trabajo adaptado a sus necesidades espec\u00edficas. La mayor\u00eda de ellos incluyen estrategias de ramificaci\u00f3n y algo llamado revisi\u00f3n por pares . Se realizan cambios en ramas separadas de la rama master . Cuando se desea fusionar esos cambios con master , otros desarrolladores primero deben mirar los cambios y aprobarlos antes de que se fusionen. Nota: Si se desea obtener m\u00e1s informaci\u00f3n sobre los diferentes flujos de trabajo que utilizan los equipos, echar un vistazo a los tutoriales en GitHub y BitBucket . Si se desea mejorar las habilidades de Git, existe un art\u00edculo llamado Consejos avanzados de Git para desarrolladores de Python . Gesti\u00f3n de dependencias y entornos virtuales Adem\u00e1s de virtualenv , hay otros gestores de paquetes y entornos populares. Algunos de ellos tratan solo con entornos virtuales, mientras que otros manejan tanto la instalaci\u00f3n de paquetes como la administraci\u00f3n del entorno. Uno de ellos es Conda: \u201cConda es un sistema de gesti\u00f3n de paquetes de c\u00f3digo abierto y un sistema de gesti\u00f3n del entorno que se ejecuta en Windows, macOS y Linux. Conda instala, ejecuta y actualiza r\u00e1pidamente los paquetes y sus dependencias. Conda crea, guarda, carga y cambia f\u00e1cilmente entre entornos en su computadora local. Fue dise\u00f1ado para programas Python, pero puede empaquetar y distribuir software para cualquier idioma \". ( Fuente ) Otra opci\u00f3n es Pipenv , un contendiente m\u00e1s joven que est\u00e1 aumentando en popularidad entre los desarrolladores de aplicaciones. Pipenv re\u00fane pip y virtualenv en una sola herramienta y utiliza un Pipfile en lugar de requirements.txt . Los Pipfiles ofrecen entornos deterministas y m\u00e1s seguridad. Esta introducci\u00f3n no le hace justicia, as\u00ed que echa un vistazo a Pipenv: una gu\u00eda para la nueva herramienta de empaquetado de Python . Pruebas Las pruebas unitarias simples con pytest son solo la punta del iceberg. \u00a1Hay todo un mundo por explorar! El software se puede probar en muchos niveles, incluidas las pruebas de integraci\u00f3n, las pruebas de aceptaci\u00f3n, las pruebas de regresi\u00f3n, etc. Para llevar el conocimiento de probar el c\u00f3digo de Python al siguiente nivel, dir\u00edjase a Comenzando con las pruebas en Python . Empaquetado En este tutorial, se comenz\u00f3 a crear una biblioteca de funciones para que otros desarrolladores la utilicen en sus proyectos. Se debe empaquetar esa biblioteca en un formato que sea f\u00e1cil de distribuir e instalar usando, por ejemplo, pip . Crear un paquete instalable requiere un dise\u00f1o diferente y algunos archivos adicionales como __init__.py y setup.py . Lea Dise\u00f1os de aplicaciones Python: una referencia para obtener m\u00e1s informaci\u00f3n sobre la estructuraci\u00f3n de su c\u00f3digo. Para aprender a convertir su repositorio en un paquete Python instalable, lea Empaquetado de proyectos Python . Integraci\u00f3n continua Cubriste todos los conceptos b\u00e1sicos de CI en este tutorial, usando un ejemplo simple de c\u00f3digo Python. Es com\u00fan que el paso final de una canalizaci\u00f3n de CI cree un artefacto desplegable Un artefacto representa una unidad de trabajo terminada y empaquetada que est\u00e1 lista para implementarse en los usuarios o incluirse en productos complejos. Por ejemplo, para convertir su biblioteca de calculadoras en un artefacto desplegable, la organizar\u00eda en un paquete instalable. Finalmente, agregar\u00eda un paso en CircleCI para empaquetar la biblioteca y almacenar ese artefacto donde otros procesos pueden recogerlo. Para aplicaciones m\u00e1s complejas, puede crear un flujo de trabajo para programar y conectar m\u00faltiples trabajos de CI en una sola ejecuci\u00f3n. Si\u00e9ntase libre de explorar la documentaci\u00f3n de CircleCI . Despliegue continuo Puede pensar en la implementaci\u00f3n continua como una extensi\u00f3n de CI. Una vez que su c\u00f3digo se prueba y se integra en un artefacto desplegable, se implementa en producci\u00f3n, lo que significa que la aplicaci\u00f3n en vivo se actualiza con sus cambios. Uno de los objetivos es minimizar el tiempo de entrega, el tiempo transcurrido entre escribir una nueva l\u00ednea de c\u00f3digo y ponerla al frente de los usuarios. Nota: Para agregar un poco de confusi\u00f3n a la mezcla, el acr\u00f3nimo CD no es \u00fanico. Tambi\u00e9n puede significar entrega continua, que es casi lo mismo que la implementaci\u00f3n continua, pero tiene un paso de verificaci\u00f3n manual entre la integraci\u00f3n y la implementaci\u00f3n. Puede integrar su c\u00f3digo en cualquier momento, pero tiene que presionar un bot\u00f3n para liberarlo en la aplicaci\u00f3n en vivo. La mayor\u00eda de las empresas usan CI/CD en conjunto, por lo que vale la pena aprender m\u00e1s sobre la entrega/implementaci\u00f3n continua . Descripci\u00f3n general de los servicios de integraci\u00f3n continua Ha utilizado CircleCI, uno de los servicios de integraci\u00f3n continua m\u00e1s populares. Sin embargo, este es un gran mercado con muchos contendientes fuertes. Los productos de CI se dividen en dos categor\u00edas b\u00e1sicas: servicios remotos y autohospedados. Jenkins es la soluci\u00f3n autohospedada m\u00e1s popular. Es de c\u00f3digo abierto y flexible, y la comunidad ha desarrollado muchas extensiones. En t\u00e9rminos de servicios remotos, hay muchas opciones populares como TravisCI , CodeShip y Semaphore . Las grandes empresas a menudo tienen sus soluciones personalizadas y las venden como un servicio, como AWS CodePipeline , Microsoft Team Foundation Server y Hudson de Oracle . La opci\u00f3n que elija depender\u00e1 de la plataforma y las caracter\u00edsticas que usted y su equipo necesiten. Para un desglose m\u00e1s detallado, eche un vistazo a Best CI Software por G2Crowd. Conclusi\u00f3n Con el conocimiento de este tutorial en su haber, ahora puede responder las siguientes preguntas: \u00bfQu\u00e9 es la integraci\u00f3n continua? \u00bfPor qu\u00e9 es importante la integraci\u00f3n continua? \u00bfCu\u00e1les son las pr\u00e1cticas centrales de la integraci\u00f3n continua? \u00bfC\u00f3mo se puede configurar la integraci\u00f3n continua para un proyecto de Python? \u00a1Has adquirido una superpoder de programaci\u00f3n! Comprender la filosof\u00eda y la pr\u00e1ctica de la integraci\u00f3n continua te convertir\u00e1 en un miembro valioso de cualquier equipo. \u00a1Impresionante trabajo! https://realpython.com/python-continuous-integration/","title":"Integraci\u00f3n Continua con Python"},{"location":"integracion_continua_con_python/#integracion-continua-con-python","text":"Al escribir c\u00f3digo por su cuenta, la \u00fanica prioridad es hacerlo funcionar. Sin embargo, trabajar en un equipo de desarrolladores de software profesionales conlleva una gran cantidad de desaf\u00edos. Uno de esos desaf\u00edos es coordinar a muchas personas que trabajan en el mismo c\u00f3digo. \u00bfC\u00f3mo hacen los equipos profesionales docenas de cambios por d\u00eda mientras se aseguran de que todos est\u00e9n coordinados y que nada se rompa? \u00a1Bienvenidos a la integraci\u00f3n continua!","title":"Integraci\u00f3n Continua con Python"},{"location":"integracion_continua_con_python/#que-es-la-integracion-continua","text":"La integraci\u00f3n continua (CI - Continuous Integration ) es la pr\u00e1ctica de generar y probar con frecuencia cada cambio realizado en el c\u00f3digo autom\u00e1ticamente y lo antes posible. El desarrollador y autor prol\u00edfico Martin Fowler define CI de la siguiente manera: \u201cLa integraci\u00f3n continua es una pr\u00e1ctica de desarrollo de software donde los miembros de un equipo integran su trabajo con frecuencia, generalmente cada persona se integra al menos diariamente, lo que lleva a m\u00faltiples integraciones por d\u00eda. Cada integraci\u00f3n se verifica mediante una compilaci\u00f3n automatizada (incluida la prueba) para detectar errores de integraci\u00f3n lo m\u00e1s r\u00e1pido posible\". ( Fuente ) La programaci\u00f3n es iterativa . El c\u00f3digo fuente vive en un repositorio compartido por todos los miembros del equipo. Si se desea trabajar en ese producto, se debe tener una copia. Se har\u00e1n cambios, se probar\u00e1n e integrar\u00e1n nuevamente en el repositorio principal. \"Enjuagar y repetir\". No hace mucho tiempo, estas integraciones eran grandes y estaban separadas por semanas (o meses), causando dolores de cabeza, perdiendo el tiempo y perdiendo dinero. Armados con experiencia, los desarrolladores comenzaron a hacer cambios menores para integrarlos con m\u00e1s frecuencia. Esto reduce las posibilidades de introducir conflictos que se deban resolver m\u00e1s adelante.","title":"\u00bfQu\u00e9 es la integraci\u00f3n continua?"},{"location":"integracion_continua_con_python/#por-que-deberia-importarme","text":"La integraci\u00f3n continua trata realmente de en qu\u00e9 pasan el tiempo los programadores. Con CI, se pasar\u00e1 menos tiempo: Preocupados por introducir un error cada vez que se realizan cambios Arreglando el desastre que alguien m\u00e1s hizo para que poder integrar nuevo c\u00f3digo Asegurando que el c\u00f3digo funciona en cada m\u00e1quina, sistema operativo y navegador Por el contrario, se pasar\u00e1 m\u00e1s tiempo: - Resolviendo problemas interesantes - Escribiendo un c\u00f3digo incre\u00edble en equipo - Co-creando productos incre\u00edbles que brinden valor a los usuarios \u00bfComo suena eso? A nivel de equipo, permite una mejor cultura de ingenier\u00eda, donde se entrega valor temprano y con frecuencia . Se fomenta la colaboraci\u00f3n y los errores se detectan mucho antes . La integraci\u00f3n continua: - Hace al equipo desarrollar m\u00e1s r\u00e1pido - Le damos la confianza de que est\u00e1n creando software estable con menos errores - Se asegura que el producto funciona en otras m\u00e1quinas, no solo en su computadora port\u00e1til - Se eliminan muchos gastos generales tediosos y permite que se concentrarse en lo que importa - Se reduce el tiempo dedicado a resolver conflictos (cuando diferentes personas modifican el mismo c\u00f3digo)","title":"\u00bfPor qu\u00e9 deber\u00eda importarme?"},{"location":"integracion_continua_con_python/#conceptos-basicos","text":"Hay varias ideas y pr\u00e1cticas clave que se debe comprender para trabajar eficazmente con una integraci\u00f3n continua. Adem\u00e1s, puede haber algunas palabras y frases con las que no se est\u00e9 familiarizado, pero que se usan con frecuencia cuando habla de CI. Este cap\u00edtulo le presentar\u00e1 estos conceptos y la jerga que viene con ellos.","title":"Conceptos b\u00e1sicos"},{"location":"integracion_continua_con_python/#repositorio-de-fuente-unica","text":"Si se est\u00e1 colaborando con otros en una sola base de c\u00f3digo, es t\u00edpico tener un repositorio compartido de c\u00f3digo fuente. Cada desarrollador que trabaja en el proyecto crea una copia local y realiza cambios. Una vez que se est\u00e1 satisfecho con los cambios, se fusionan nuevamente en el repositorio central. Se ha convertido en un est\u00e1ndar usar sistemas de control de versiones (VCS) como Git para manejar este flujo de trabajo. Los equipos suelen utilizar un servicio externo para alojar su c\u00f3digo fuente y manejar todas las partes m\u00f3viles. Los m\u00e1s populares son GitHub, BitBucket y GitLab. Git permite crear m\u00faltiples ramas de un repositorio. Cada rama es una copia independiente del c\u00f3digo fuente y se puede modificar sin afectar a otras ramas. Esta es una caracter\u00edstica esencial, y la mayor\u00eda de los equipos tienen una rama principal (a menudo llamada rama maestra) que representa el estado actual del proyecto. Si se desea agregar o modificar c\u00f3digo, debe crear una copia de la rama principal y trabajar en su nueva rama de desarrollo. Una vez que haya terminado, combine esos cambios nuevamente en la rama maestra. El control de versiones contiene m\u00e1s que solo c\u00f3digo. La documentaci\u00f3n y los scripts de prueba generalmente se almacenan junto con el c\u00f3digo fuente. Algunos programas buscan archivos externos utilizados para configurar sus par\u00e1metros y configuraciones iniciales. Otras aplicaciones necesitan un esquema de base de datos. Todos estos archivos deben ir al repositorio. Si nunca ha usado Git o necesita un repaso, consultar Introducci\u00f3n a Git y GitHub para desarrolladores de Python .","title":"Repositorio de fuente \u00fanica"},{"location":"integracion_continua_con_python/#automatizando-la-construccion-build","text":"Construir c\u00f3digo ( build ) significa tomar el c\u00f3digo fuente sin procesar, y todo lo necesario para su ejecuci\u00f3n, y traducirlo a un formato que las computadoras puedan ejecutar directamente. Python es un lenguaje interpretado , por lo que su \"compilaci\u00f3n\" gira principalmente en torno a la ejecuci\u00f3n de pruebas en lugar de la compilaci\u00f3n. Ejecutar esos pasos manualmente despu\u00e9s de cada peque\u00f1o cambio es tedioso y requiere tiempo y atenci\u00f3n valiosos de la resoluci\u00f3n de problemas reales que se est\u00e1 tratando de resolver. Una gran parte de la integraci\u00f3n continua es automatizar ese proceso y quitarlo de la vista (y de la mente). \u00bfQu\u00e9 significa eso para Python? Piensar en el c\u00f3digo m\u00e1s complicado posible. Si se us\u00f3 una biblioteca, paquete o marco que no viene con la biblioteca est\u00e1ndar (pensar en todo lo que se necesita para instalar con pip , conda \u00f3 pipenv ), Python necesita saberlo, para que el programa sepa d\u00f3nde buscar cuando encuentre comandos que no reconoce. Se almacena una lista de esos paquetes en require.txt o en un Pipfile . Estas son las dependencias del c\u00f3digo y son necesarias para una compilaci\u00f3n exitosa. A menudo se escucha la frase \"se rompi\u00f3 la compilaci\u00f3n\". Cuando se rompe la compilaci\u00f3n, significa que se introdujo un cambio que dej\u00f3 inutilizable el producto final. Pasa en las mejores familias, incluso a los desarrolladores senior endurecidos por la batalla. Se desea evitar esto principalmente porque esto impedir\u00e1 que el resto trabaje. El objetivo de CI es que todos trabajen en una base estable conocida. Si clonan un repositorio que se rompre durante la compilaci\u00f3n, trabajar\u00e1n con una versi\u00f3n da\u00f1ada del c\u00f3digo y no podr\u00e1n introducir o probar sus cambios. Cuando la compilaci\u00f3n est\u00e1 rota, la principal prioridad es arreglarla para que todos puedan reanudar el trabajo. Cuando la compilaci\u00f3n es autom\u00e1tica, se recomienda que se acometa con frecuencia, generalmente varias veces al d\u00eda. Esto descubrir r\u00e1pidamente los cambios y notar si hay un conflicto entre dos desarrolladores. Si hay numerosos cambios peque\u00f1os en lugar de algunas actualizaciones masivas, es mucho m\u00e1s f\u00e1cil localizar d\u00f3nde se origin\u00f3 el error. Tambi\u00e9n se alenta a dividir el trabajo en trozos m\u00e1s peque\u00f1os, por lo que es m\u00e1s f\u00e1cil de rastrear y probar.","title":"Automatizando la construcci\u00f3n (Build)"},{"location":"integracion_continua_con_python/#pruebas-automatizadas","text":"Dado que todos est\u00e1n realizando cambios varias veces al d\u00eda, es importante saber que un cambio no rompi\u00f3 nada m\u00e1s en el c\u00f3digo ni se introdujeron errores. En muchas empresas, las pruebas son ahora responsabilidad de cada desarrollador. Si se escribe c\u00f3digo, se debe escribir pruebas. Como m\u00ednimo, se debe cubrir cada nueva funci\u00f3n con una prueba unitaria. Ejecutar pruebas autom\u00e1ticamente, con cada cambio comprometido, es una excelente manera de detectar errores. Una prueba fallida hace que la compilaci\u00f3n falle autom\u00e1ticamente. Llamar\u00e1 la atenci\u00f3n sobre los problemas revelados por las pruebas, y la compilaci\u00f3n fallida har\u00e1 corregir el error que se introdujo. Las pruebas no garantizan que el c\u00f3digo est\u00e9 libre de errores, pero protege contra muchos cambios descuidados. Automatizar la ejecuci\u00f3n de la prueba da tranquilidad porque as\u00ed, el servidor probar\u00e1 el c\u00f3digo cada vez que se comprometa, incluso si se olvid\u00f3 hacerlo localmente.","title":"Pruebas automatizadas"},{"location":"integracion_continua_con_python/#uso-de-un-servicio-externo-de-integracion-continua","text":"Si algo funciona en un ordenador, \u00bffuncionar\u00e1 en todos? Probablemente no. Es una excusa clich\u00e9 y una especie de broma interna entre los desarrolladores decir: \"\u00a1Bueno, funcion\u00f3 en mi m\u00e1quina!\". Hacer que el c\u00f3digo funcione localmente no es el fin de la responsabilidad. Para abordar este problema, la mayor\u00eda de las empresas utilizan un servicio externo para manejar la integraci\u00f3n; al igual que GitHub aloja el repositorio de c\u00f3digo fuente. Los servicios externos tienen servidores donde crean c\u00f3digo y ejecutan pruebas. Act\u00faan como monitores para su repositorio y evitan que cualquier cosa se fusione con la rama maestra si los cambios rompen la compilaci\u00f3n. Existen muchos servicios de este tipo, con varias caracter\u00edsticas y precios. La mayor\u00eda tiene un nivel gratuito (CircleCI) para que se pueda experimentar con uno de sus repositorios.","title":"Uso de un servicio externo de integraci\u00f3n continua"},{"location":"integracion_continua_con_python/#pruebas-en-un-entorno-de-ensayo","text":"Un entorno de producci\u00f3n es donde finalmente se ejecutar\u00e1 el software. Incluso despu\u00e9s de compilar y probar con \u00e9xito la aplicaci\u00f3n, no se puede estar seguro de que el c\u00f3digo funcionar\u00e1 en la computadora de destino. Es por eso que los equipos implementan el producto final en un entorno que imita el entorno de producci\u00f3n. Una vez que se est\u00e9 seguro de que todo funciona, la aplicaci\u00f3n se implementa en el entorno de producci\u00f3n. Nota: Este paso es m\u00e1s relevante para el c\u00f3digo de la aplicaci\u00f3n que el c\u00f3digo de la biblioteca. Las bibliotecas de Python que se escriban a\u00fan deben probarse en un servidor de compilaci\u00f3n, para garantizar que funcionen en entornos diferentes de su computadora local. Escuchar\u00e1 a las personas hablar sobre este clon del entorno de producci\u00f3n utilizando t\u00e9rminos como entorno de desarrollo, entorno de ensayo o entorno de prueba. Es com\u00fan usar abreviaturas como DEV para el entorno de desarrollo y PROD para el entorno de producci\u00f3n. El entorno de desarrollo debe replicar las condiciones de producci\u00f3n lo m\u00e1s cerca posible. Esta configuraci\u00f3n a menudo se llama paridad DEV/PROD . Hay que mantener el entorno en la computadora local lo m\u00e1s similar posible a los entornos DEV y PROD para minimizar las anomal\u00edas al implementar aplicaciones . Se menciona esto para presentar el vocabulario, pero la implementaci\u00f3n continua de software en DEV y PROD es un tema completamente diferente. El proceso se llama, como era de esperar, despliegue continuo (CD - Continuous Deploy ). Puede encontrar m\u00e1s recursos al respecto en la secci\u00f3n","title":"Pruebas en un entorno de ensayo"},{"location":"integracion_continua_con_python/#manos-a-la-obra","text":"La mejor manera de aprender es haciendo. Ahora que se comprenden todas las pr\u00e1cticas esenciales de la integraci\u00f3n continua, es hora de ensuciarse las manos y crear toda la cadena de pasos necesarios para usar CI. Esta cadena a menudo se llama una tuber\u00eda de CI. Se supone que se conocen los conceptos b\u00e1sicos de Python y Git. Utilizaremos Github como servicio de alojamiento y CircleCI como servicio externo de integraci\u00f3n continua. Si no se tiene cuenta con estos servicios, habr\u00e1 que registrarse.","title":"\u00a1Manos a la obra!"},{"location":"integracion_continua_con_python/#definicion-del-problema","text":"El enfoque aqu\u00ed es agregar una nueva herramienta a nuestro cintur\u00f3n de servicios p\u00fablicos, la integraci\u00f3n continua . Para este ejemplo, el c\u00f3digo Python en s\u00ed ser\u00e1 sencillo. Se desea pasar la mayor parte del tiempo interiorizando los pasos de la construcci\u00f3n de una tuber\u00eda, en lugar de escribir c\u00f3digo complicado. Imaginemos que el equipo est\u00e1 trabajando en una aplicaci\u00f3n de calculadora simple. La tarea es escribir una biblioteca de funciones matem\u00e1ticas b\u00e1sicas: suma, resta, multiplicaci\u00f3n y divisi\u00f3n. No importa la aplicaci\u00f3n real, porque eso es lo que los programadores desarrollar\u00e1n, utilizando las funciones de la biblioteca.","title":"Definici\u00f3n del problema"},{"location":"integracion_continua_con_python/#crear-un-repositorio","text":"Iniciar sesi\u00f3n en la cuenta de GitHub, crear un nuevo repositorio CalculatorLibrary . Agregar un archivo README.md y .gitignore , luego clonar el repositorio en la m\u00e1quina local. Si se necesita m\u00e1s ayuda con este proceso, echar un vistazo al tutorial de GitHub sobre c\u00f3mo crear un nuevo repositorio.","title":"Crear un repositorio"},{"location":"integracion_continua_con_python/#establecer-un-ambiente-de-trabajo","text":"Para que otros (y el servidor de CI) puedan replicar las condiciones de trabajo, se debe configurar un entorno. Crear un entorno virtual en alg\u00fan lugar fuera del repositorio y activarlo: # Crear entorno virtual $ mkdir CalculatorLibrary $ cd CalculatorLibrary $ pipenv shell Esto crear\u00e1 un directorio que contiene una instalaci\u00f3n de Python e indicar\u00e1 al int\u00e9rprete que lo use. Ahora podemos instalar paquetes sabiendo que no influir\u00e1 en la instalaci\u00f3n predeterminada de Python del sistema.","title":"Establecer un ambiente de trabajo"},{"location":"integracion_continua_con_python/#escribir-un-ejemplo-simple-de-python","text":"Crear un nuevo archivo llamado calculator.py en el directorio de nivel superior del repositorio y copiar el siguiente c\u00f3digo: \"\"\" Calculator library containing basic math operations. \"\"\" def add(first_term, second_term): return first_term + second_term def subtract(first_term, second_term): return first_term - second_term Este es un ejemplo b\u00e1sico que contiene dos de las cuatro funciones que escribiremos. Una vez que tengamos en funcionamiento nuestra canalizaci\u00f3n de CI, se agregar\u00e1n las dos funciones restantes. Continuar y confirmar esos cambios: # Asegarse de estar en el directorio correcto $ git add calculator.py $ git commit -m \"Agrega funciones para sumar y restar\" La carpeta CalculatorLibrary deber\u00eda tener los siguientes archivos en este momento: CalculatorLibrary / | \u251c\u2500\u2500 .git \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 README.md \u251c\u2500\u2500 calculator.py \u2514\u2500\u2500 Pipfile Genial, se ha completado una parte de la funcionalidad requerida. El siguiente paso es agregar pruebas para asegurarse de que el c\u00f3digo funcione de la manera en que se supone que debe hacerlo.","title":"Escribir un ejemplo simple de Python"},{"location":"integracion_continua_con_python/#escribir-pruebas-unitarias","text":"Se probar\u00e1 el c\u00f3digo en dos pasos. El primer paso consiste en linting : ejecutar un programa, llamado linter , para analizar el c\u00f3digo en busca de posibles errores. flake8 se usa com\u00fanmente para verificar si su c\u00f3digo se ajusta al estilo de codificaci\u00f3n Python est\u00e1ndar. Linting asegura que el c\u00f3digo sea f\u00e1cil de leer para el resto de la comunidad de Python. El segundo paso es la prueba unitaria . Una prueba unitaria est\u00e1 dise\u00f1ada para verificar una sola funci\u00f3n, o unidad, de c\u00f3digo. Python viene con una biblioteca de prueba de unidad est\u00e1ndar, pero existen otras bibliotecas y son muy populares. En nuestro caso se usar\u00e1 pytest . Una pr\u00e1ctica est\u00e1ndar que va de la mano con las pruebas es calcular la cobertura del c\u00f3digo . Cobertura del c\u00f3digo .- es el porcentaje del c\u00f3digo fuente que est\u00e1 \"cubierto\" por sus pruebas*. pytest tiene una extensi\u00f3n, pytest-cov , que ayuda a comprender la cobertura de un c\u00f3digo. Estas son dependencias externas y deben ser instaladas: $ pipenv install flake8 pytest pytest-cov El fichero Pipfile almacenar\u00e1 todas las dependencias para poder replicar el entorno. Para lanzar el linter ejecutar: $ flake8 --statistics ./calculator.py:5:1: E302 expected 2 blank lines, found 1 ./calculator.py:8:1: E302 expected 2 blank lines, found 1 ./calculator.py:9:36: W292 no newline at end of file 2 E302 expected 2 blank lines, found 1 1 W292 no newline at end of file La opci\u00f3n --statistics brinda una visi\u00f3n general de cu\u00e1ntas veces ocurri\u00f3 un error en particular. Aqu\u00ed se ven dos violaciones de PEP 8, porque flake8 espera dos l\u00edneas en blanco antes de una definici\u00f3n de funci\u00f3n en lugar de una. Por tanto, hay que agregar una l\u00ednea vac\u00eda antes de cada definici\u00f3n de funciones. Ejecutar flake8 nuevamente para verificar que los mensajes de error ya no aparezcan. Ahora es el momento de escribir las pruebas. Crear un archivo llamado test_calculator.py en el directorio de nivel superior del repositorio y copiar el siguiente c\u00f3digo: \"\"\" Unit tests for the calculator library \"\"\" import calculator class TestCalculator: def test_addition(self): assert 4 == calculator.add(2, 2) def test_subtraction(self): assert 2 == calculator.subtract(4, 2) Estas pruebas aseguran que nuestro c\u00f3digo funcione como se esperaba. Est\u00e1 lejos de ser extenso porque no prueba el posible mal uso del c\u00f3digo, pero mant\u00e9ngase simple por ahora. El siguiente comando ejecuta la prueba: $ pytest -v --cov =================== test session starts ======================= platform linux -- Python 3.8.0, pytest-5.3.1, py-1.8.0, pluggy-0.13.1 -- /home/XXXXX/.local/share/virtualenvs/CalculatorLibrary-T3Wmr6pK/bin/python cachedir: .pytest_cache rootdir: /home/XXXXX/CalculatorLibrary plugins: cov-2.8.1 collected 2 items test_calculator.py::TestCalculator::test_addition PASSED [ 50%] test_calculator.py::TestCalculator::test_subtraction PASSED [100%] pytest es excelente en el descubrimiento de pruebas. Dado que se tiene un archivo con el prefijo test , pytest sabe que contendr\u00e1 pruebas unitarias que se ejecutar. Los mismos principios se aplican a los nombres de clases y m\u00e9todos dentro del archivo. El indicador -v da una salida m\u00e1s agradable e indica qu\u00e9 pruebas pasaron y cu\u00e1les fallaron. En este caso, se pasaron ambas pruebas. El indicador --cov asegura de que pytest-cov se ejecuta y proporciona un informe de cobertura de c\u00f3digo para calculator.py . Se han completado los preparativos. Confirmar el archivo de prueba y enviar todos esos cambios a la rama maestra: $ git add test_calculator.py $ git commit -m \"Agrega pruebas unitarias para calculator.py\" $ git push Al final de esta secci\u00f3n, la carpeta CalculatorLibrary debe tener los siguientes archivos: CalculatorLibrary/ | \u251c\u2500\u2500 .git \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 README.md \u251c\u2500\u2500 calculadora.py \u251c\u2500\u2500 Pipfile \u251c\u2500\u2500 Pipfile.lock \u2514\u2500\u2500 test_calculator.py Excelente, ambas funciones se prueban y funcionan correctamente.","title":"Escribir pruebas unitarias"},{"location":"integracion_continua_con_python/#conectar-a-circleci","text":"\u00a1Por fin, se est\u00e1 listo para configurar el canal de integraci\u00f3n continua! CircleCI necesita saber c\u00f3mo ejecutar su compilaci\u00f3n y espera que esa informaci\u00f3n se suministre en un formato particular. Requiere una carpeta .circleci dentro del repositorio y un archivo de configuraci\u00f3n dentro de \u00e9l. El archivo de configuraci\u00f3n contiene instrucciones para todos los pasos que el servidor de compilaci\u00f3n necesita ejecutar. CircleCI espera que este archivo se llame config.yml . Un archivo .yml usa un lenguaje de serializaci\u00f3n de datos, YAML, y tiene su propia especificaci\u00f3n . El objetivo de YAML es ser legible por humanos y funcionar bien con lenguajes de programaci\u00f3n modernos para tareas comunes y cotidianas. En un archivo YAML, hay tres formas b\u00e1sicas de representar datos: Mapeos (pares clave-valor) Secuencias (listas) Escalares (cadenas o n\u00fameros) Es muy simple de leer: La sangr\u00eda puede usarse para estructurar. Los dos puntos separan pares clave-valor. Los guiones se usan para crear listas. Crear la carpeta .circleci en el repositorio y un archivo config.yml con el siguiente contenido: # Python CircleCI 2.0 configuration file version: 2 jobs: build: docker: - image: circleci/python:3.7 working_directory: ~/repo steps: # Step 1: obtain repo from GitHub - checkout # Step 2: create virtual env and install dependencies - run: name: install dependencies command: | python3 -m venv venv . venv/bin/activate pip install -r requirements.txt # Step 3: run linter and tests - run: name: run tests command: | . venv/bin/activate flake8 --exclude=venv* --statistics pytest -v --cov=calculator Algunas de estas palabras y conceptos pueden no ser familiares. Por ejemplo, \u00bfqu\u00e9 es Docker y qu\u00e9 son las im\u00e1genes? Retrocedamos un poco en el tiempo. Retomemos el problema que enfrentan los programadores cuando algo funciona en su computadora port\u00e1til pero en ning\u00fan otro lugar. Los desarrolladores sol\u00edan crear un programa que aislaba una parte de los recursos f\u00edsicos de la computadora (memoria, disco duro, etc.) y los convert\u00eda en una m\u00e1quina virtual . Una m\u00e1quina virtual pretende ser una computadora completa por s\u00ed sola. Incluso tendr\u00eda su propio sistema operativo. En ese sistema operativo, despliega su aplicaci\u00f3n o instala su biblioteca y la prueba. Las m\u00e1quinas virtuales ocupan muchos recursos, lo que provoc\u00f3 la invenci\u00f3n de los contenedores. La idea es an\u00e1loga a los contenedores de env\u00edo. Antes de que se inventaran los contenedores de env\u00edo, los fabricantes ten\u00edan que enviar productos en una amplia variedad de tama\u00f1os, embalajes y modos (camiones, trenes, barcos). Al estandarizar el contenedor de env\u00edo, estos productos podr\u00edan transferirse entre diferentes m\u00e9todos de env\u00edo sin ninguna modificaci\u00f3n. La misma idea se aplica a los contenedores de software. Los contenedores son una unidad de c\u00f3digo liviana y sus dependencias de tiempo de ejecuci\u00f3n, empaquetados de manera estandarizada, por lo que pueden conectarse y ejecutarse r\u00e1pidamente en el sistema operativo Linux. No se necesita crear un sistema operativo virtual completo, como se har\u00eda con una m\u00e1quina virtual. Los contenedores solo replican las partes del sistema operativo que se necesita para funcionar. Esto reduce su tama\u00f1o y les da un gran impulso al rendimiento. Docker es actualmente la plataforma de contenedores l\u00edder, e incluso puede ejecutar contenedores de Linux en Windows y macOS. Para crear un contenedor Docker, se necesita una imagen Docker. Las im\u00e1genes proporcionan planos para contenedores al igual que las clases proporcionan planos para objetos. Puede leer m\u00e1s sobre Docker en su gu\u00eda de inicio . CircleCI mantiene im\u00e1genes Docker preconstruidas para varios lenguajes de programaci\u00f3n. En el archivo de configuraci\u00f3n anterior, se ha especificado una imagen de Linux que ya tiene Python instalado. Esa imagen crear\u00e1 un contenedor en el que suceder\u00e1 todo lo dem\u00e1s. Veamos cada l\u00ednea del archivo de configuraci\u00f3n una a una: version : cada config.yml comienza con el n\u00famero de versi\u00f3n CircleCI, utilizado para emitir advertencias sobre cambios importantes. jobs : Representan una sola ejecuci\u00f3n de la compilaci\u00f3n y se definen mediante una colecci\u00f3n de pasos. Si solo hay un trabajo, debe llamarse build . build : build es el nombre del trabajo. Pueden haber varios trabajos, en cuyo caso deben tener nombres \u00fanicos. docker : los pasos de un trabajo se producen en un entorno llamado ejecutor ( executor ). El ejecutor com\u00fan en CircleCI es un contenedor Docker . Es un entorno de ejecuci\u00f3n alojado en la nube , pero existen otras opciones, como un entorno macOS. image : una imagen Docker es un archivo utilizado para crear un contenedor Docker en ejecuci\u00f3n. Estamos utilizando una imagen que tiene preinstalado Python 3.7. working_directory : El repositorio debe ser extra\u00eddo en alg\u00fan lugar del servidor de compilaci\u00f3n. El directorio de trabajo representa la ruta del archivo donde se almacenar\u00e1 el repositorio. steps : Esta clave marca el inicio de una lista de pasos que debe realizar el servidor de compilaci\u00f3n. checkout : El primer paso que debe hacer el servidor es verificar el c\u00f3digo fuente en el directorio de trabajo. Esto se realiza mediante un paso especial llamado checkout . run : La ejecuci\u00f3n de programas o comandos de l\u00ednea de comandos se realiza dentro de la clave command . Los comandos shell reales estar\u00e1n anidados dentro. name : La interfaz de usuario CircleCI le muestra cada paso de compilaci\u00f3n en forma de una secci\u00f3n expandible. El t\u00edtulo de la secci\u00f3n se toma del valor asociado con la clave name . command : Esta clave representa el comando que se ejecuta a trav\u00e9s del shell. El | El s\u00edmbolo especifica que lo que sigue es un conjunto literal de comandos, uno por l\u00ednea, exactamente como se ver\u00eda en un script de shell/bash. Puede leer el documento de referencia de configuraci\u00f3n CircleCI para obtener m\u00e1s informaci\u00f3n. La tuber\u00eda es muy simple y consta de 3 pasos: Revisi\u00f3n del repositorio Instalar las dependencias en un entorno virtual Ejecuci\u00f3n del linter y las pruebas mientras se est\u00e1 dentro del entorno virtual Ahora tenemos todo lo que necesitamos para comenzar nuestra tuber\u00eda. Iniciar sesi\u00f3n en la cuenta CircleCI y hacer clic en Add Projects ( Agregar proyectos ) . Encuentrar el repositorio de CalculatorLibrary y hacer clic en Set Up Project ( Configurar proyecto ). Seleccionar Python como lenguaje. Como ya se cuenta con un config.yml , podemos omitir los siguientes pasos y hacer clic en Start building ( Iniciar construcci\u00f3n ). CircleCI lo llevar\u00e1 al panel de ejecuci\u00f3n para el trabajo. Si se siguieron todos los pasos correctamente, deber\u00eda ver que el trabajo es exitoso. La versi\u00f3n final de la carpeta CalculatorLibrary deber\u00eda verse as\u00ed: CalculatorRepository / | \u251c\u2500\u2500 .circleci \u251c\u2500\u2500 .git \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 README.md \u251c\u2500\u2500 calculadora.py \u251c\u2500\u2500 requisitos.txt \u2514\u2500\u2500 test_calculator.py \u00a1Felicidades! Se ha creado el primer canal de integraci\u00f3n continua. Ahora, cada vez que se haga un push a la rama maestra, se activar\u00e1 un trabajo. Puede ver una lista de sus trabajos actuales y pasados haciendo clic en Jobs en la barra lateral de CircleCI.","title":"Conectar a CircleCI"},{"location":"integracion_continua_con_python/#hacer-cambios","text":"Es hora de agregar la multiplicaci\u00f3n a la biblioteca de calculadora. Esta vez, primero se agregara una prueba unitaria sin escribir la funci\u00f3n. Sin el c\u00f3digo, la prueba fallar\u00e1, lo que tambi\u00e9n fallar\u00e1 el trabajo CircleCI. Agregue el siguiente c\u00f3digo al final de su test_calculator.py : def test_multiplication (self): assert 100 == calculator.multiply(10, 10) Subir el c\u00f3digo ( push ) a la rama maestra y se ver\u00e1 que el trabajo falla en CircleCI. Esto muestra que la integraci\u00f3n continua funciona y nos cuida la espalda si se comete alg\u00fan error. Ahora agregar el c\u00f3digo a calculator.py que har\u00e1 pasar la prueba: def multiply(first_term, second_term): return first_term * second_term Asegurarse de que haya dos espacios vac\u00edos entre la funci\u00f3n de multiplicaci\u00f3n y la anterior, de lo contrario, el c\u00f3digo fallar\u00e1 en la verificaci\u00f3n de la interfaz. El trabajo deber\u00eda ser exitoso en esta ocasi\u00f3n. Este flujo de trabajo de escribir primero una prueba fallida y luego agregar el c\u00f3digo para pasar la prueba se llama desarrollo guiado por pruebas o Test Driven Development (TDD). Es una excelente manera de trabajar porque obliga a pensar de antemano en la estructura del c\u00f3digo. Ahora pru\u00e9balo por tu cuenta .- Agregar una prueba para la funci\u00f3n de divisi\u00f3n, ver c\u00f3mo falla y escribir la funci\u00f3n para que pueda pasarla.","title":"Hacer cambios"},{"location":"integracion_continua_con_python/#notificaciones","text":"Cuando se trabaja en aplicaciones grandes que tienen muchas partes m\u00f3viles, puede llevar un tiempo ejecutar el trabajo de integraci\u00f3n continua. La mayor\u00eda de los equipos establecen un procedimiento de notificaci\u00f3n para informarles si uno de sus trabajos falla. Pueden continuar trabajando mientras esperan que se ejecute el trabajo. Las opciones m\u00e1s populares son: Enviar un correo electr\u00f3nico por cada compilaci\u00f3n fallida Env\u00edo de notificaciones de fallas a un canal de Slack Mostrar fallas en un tablero visible para todos Por defecto, CircleCI deber\u00eda enviarle un correo electr\u00f3nico cuando falla un trabajo.","title":"Notificaciones"},{"location":"integracion_continua_con_python/#proximos-pasos","text":"Se han explicado los conceptos b\u00e1sicos de la integraci\u00f3n continua y se ha practicado con la configuraci\u00f3n de una tuber\u00eda para un programa Python simple. Este es un gran paso adelante en el viaje de un desarrollador. Tal vez la pregunta es: \"\u00bfY ahora qu\u00e9?\" Para simplificar las cosas, se han tocado superficialmente algunos grandes temas. Se puede aumentar enormemente el conjunto de habilidades si se pasa un poco de tiempo profundizando en cada tema. Aqu\u00ed hay algunos temas que se pueden investigar m\u00e1s a fondo.","title":"Pr\u00f3ximos pasos"},{"location":"integracion_continua_con_python/#flujos-de-trabajo-de-git","text":"Git tiene mucho m\u00e1s de lo que se ha usado aqu\u00ed. Cada equipo de desarrolladores tiene un flujo de trabajo adaptado a sus necesidades espec\u00edficas. La mayor\u00eda de ellos incluyen estrategias de ramificaci\u00f3n y algo llamado revisi\u00f3n por pares . Se realizan cambios en ramas separadas de la rama master . Cuando se desea fusionar esos cambios con master , otros desarrolladores primero deben mirar los cambios y aprobarlos antes de que se fusionen. Nota: Si se desea obtener m\u00e1s informaci\u00f3n sobre los diferentes flujos de trabajo que utilizan los equipos, echar un vistazo a los tutoriales en GitHub y BitBucket . Si se desea mejorar las habilidades de Git, existe un art\u00edculo llamado Consejos avanzados de Git para desarrolladores de Python .","title":"Flujos de trabajo de Git"},{"location":"integracion_continua_con_python/#gestion-de-dependencias-y-entornos-virtuales","text":"Adem\u00e1s de virtualenv , hay otros gestores de paquetes y entornos populares. Algunos de ellos tratan solo con entornos virtuales, mientras que otros manejan tanto la instalaci\u00f3n de paquetes como la administraci\u00f3n del entorno. Uno de ellos es Conda: \u201cConda es un sistema de gesti\u00f3n de paquetes de c\u00f3digo abierto y un sistema de gesti\u00f3n del entorno que se ejecuta en Windows, macOS y Linux. Conda instala, ejecuta y actualiza r\u00e1pidamente los paquetes y sus dependencias. Conda crea, guarda, carga y cambia f\u00e1cilmente entre entornos en su computadora local. Fue dise\u00f1ado para programas Python, pero puede empaquetar y distribuir software para cualquier idioma \". ( Fuente ) Otra opci\u00f3n es Pipenv , un contendiente m\u00e1s joven que est\u00e1 aumentando en popularidad entre los desarrolladores de aplicaciones. Pipenv re\u00fane pip y virtualenv en una sola herramienta y utiliza un Pipfile en lugar de requirements.txt . Los Pipfiles ofrecen entornos deterministas y m\u00e1s seguridad. Esta introducci\u00f3n no le hace justicia, as\u00ed que echa un vistazo a Pipenv: una gu\u00eda para la nueva herramienta de empaquetado de Python .","title":"Gesti\u00f3n de dependencias y entornos virtuales"},{"location":"integracion_continua_con_python/#pruebas","text":"Las pruebas unitarias simples con pytest son solo la punta del iceberg. \u00a1Hay todo un mundo por explorar! El software se puede probar en muchos niveles, incluidas las pruebas de integraci\u00f3n, las pruebas de aceptaci\u00f3n, las pruebas de regresi\u00f3n, etc. Para llevar el conocimiento de probar el c\u00f3digo de Python al siguiente nivel, dir\u00edjase a Comenzando con las pruebas en Python .","title":"Pruebas"},{"location":"integracion_continua_con_python/#empaquetado","text":"En este tutorial, se comenz\u00f3 a crear una biblioteca de funciones para que otros desarrolladores la utilicen en sus proyectos. Se debe empaquetar esa biblioteca en un formato que sea f\u00e1cil de distribuir e instalar usando, por ejemplo, pip . Crear un paquete instalable requiere un dise\u00f1o diferente y algunos archivos adicionales como __init__.py y setup.py . Lea Dise\u00f1os de aplicaciones Python: una referencia para obtener m\u00e1s informaci\u00f3n sobre la estructuraci\u00f3n de su c\u00f3digo. Para aprender a convertir su repositorio en un paquete Python instalable, lea Empaquetado de proyectos Python .","title":"Empaquetado"},{"location":"integracion_continua_con_python/#integracion-continua","text":"Cubriste todos los conceptos b\u00e1sicos de CI en este tutorial, usando un ejemplo simple de c\u00f3digo Python. Es com\u00fan que el paso final de una canalizaci\u00f3n de CI cree un artefacto desplegable Un artefacto representa una unidad de trabajo terminada y empaquetada que est\u00e1 lista para implementarse en los usuarios o incluirse en productos complejos. Por ejemplo, para convertir su biblioteca de calculadoras en un artefacto desplegable, la organizar\u00eda en un paquete instalable. Finalmente, agregar\u00eda un paso en CircleCI para empaquetar la biblioteca y almacenar ese artefacto donde otros procesos pueden recogerlo. Para aplicaciones m\u00e1s complejas, puede crear un flujo de trabajo para programar y conectar m\u00faltiples trabajos de CI en una sola ejecuci\u00f3n. Si\u00e9ntase libre de explorar la documentaci\u00f3n de CircleCI .","title":"Integraci\u00f3n continua"},{"location":"integracion_continua_con_python/#despliegue-continuo","text":"Puede pensar en la implementaci\u00f3n continua como una extensi\u00f3n de CI. Una vez que su c\u00f3digo se prueba y se integra en un artefacto desplegable, se implementa en producci\u00f3n, lo que significa que la aplicaci\u00f3n en vivo se actualiza con sus cambios. Uno de los objetivos es minimizar el tiempo de entrega, el tiempo transcurrido entre escribir una nueva l\u00ednea de c\u00f3digo y ponerla al frente de los usuarios. Nota: Para agregar un poco de confusi\u00f3n a la mezcla, el acr\u00f3nimo CD no es \u00fanico. Tambi\u00e9n puede significar entrega continua, que es casi lo mismo que la implementaci\u00f3n continua, pero tiene un paso de verificaci\u00f3n manual entre la integraci\u00f3n y la implementaci\u00f3n. Puede integrar su c\u00f3digo en cualquier momento, pero tiene que presionar un bot\u00f3n para liberarlo en la aplicaci\u00f3n en vivo. La mayor\u00eda de las empresas usan CI/CD en conjunto, por lo que vale la pena aprender m\u00e1s sobre la entrega/implementaci\u00f3n continua .","title":"Despliegue continuo"},{"location":"integracion_continua_con_python/#descripcion-general-de-los-servicios-de-integracion-continua","text":"Ha utilizado CircleCI, uno de los servicios de integraci\u00f3n continua m\u00e1s populares. Sin embargo, este es un gran mercado con muchos contendientes fuertes. Los productos de CI se dividen en dos categor\u00edas b\u00e1sicas: servicios remotos y autohospedados. Jenkins es la soluci\u00f3n autohospedada m\u00e1s popular. Es de c\u00f3digo abierto y flexible, y la comunidad ha desarrollado muchas extensiones. En t\u00e9rminos de servicios remotos, hay muchas opciones populares como TravisCI , CodeShip y Semaphore . Las grandes empresas a menudo tienen sus soluciones personalizadas y las venden como un servicio, como AWS CodePipeline , Microsoft Team Foundation Server y Hudson de Oracle . La opci\u00f3n que elija depender\u00e1 de la plataforma y las caracter\u00edsticas que usted y su equipo necesiten. Para un desglose m\u00e1s detallado, eche un vistazo a Best CI Software por G2Crowd.","title":"Descripci\u00f3n general de los servicios de integraci\u00f3n continua"},{"location":"integracion_continua_con_python/#conclusion","text":"Con el conocimiento de este tutorial en su haber, ahora puede responder las siguientes preguntas: \u00bfQu\u00e9 es la integraci\u00f3n continua? \u00bfPor qu\u00e9 es importante la integraci\u00f3n continua? \u00bfCu\u00e1les son las pr\u00e1cticas centrales de la integraci\u00f3n continua? \u00bfC\u00f3mo se puede configurar la integraci\u00f3n continua para un proyecto de Python? \u00a1Has adquirido una superpoder de programaci\u00f3n! Comprender la filosof\u00eda y la pr\u00e1ctica de la integraci\u00f3n continua te convertir\u00e1 en un miembro valioso de cualquier equipo. \u00a1Impresionante trabajo! https://realpython.com/python-continuous-integration/","title":"Conclusi\u00f3n"},{"location":"la_tortuga_que_dibuja/","text":"La tortuga que dibuja En 1967 Wally Feurzeig y Seymour Papert crearon Logo , un lenguaje de programaci\u00f3n con fines educativos. Ese lenguaje inclu\u00eda los \"gr\u00e1ficos de tortuga\". La \"tortuga\" de Logo es un cursor al que se le pueden dar \u00f3rdenes de movimiento (avance, retroceso o giro) y que puede ir dejando un rastro sobre la pantalla. Moviendo adecuadamente la tortuga se puede conseguir dibujar todo tipo de figuras. Python incluye un m\u00f3dulo llamado turtle que permite crear \u00e9ste tipo de gr\u00e1ficos tortuga . Para utilizar el m\u00f3dulo turtle s\u00f3lo hace falta importarlo: Si se va a escribir c\u00f3digo no orientado a objetos: from turtle import * Si se va a escribir c\u00f3digo orientado a objetos (que es la que se usar\u00e1 a partir de ahora): import turtle La ventana de dibujo: setup() y title() El m\u00f3dulo turtle dibuja en una ventana propia. El m\u00e9todo/funci\u00f3n setup(ancho, alto, posicionX, posicionY) permite definir el tama\u00f1o y la posici\u00f3n inicial de la ventana. Los cuatro argumentos de la funci\u00f3n son (en p\u00edxeles): ancho : ancho de la ventana. alto : alto de la ventana. posicionX : posici\u00f3n horizontal de la ventana. Los valores positivos se miden desde el borde izquierdo de la pantalla, los negativos desde el borde derecho de la pantalla. posicionY : posici\u00f3n vertical de la ventana. Los valores positivos se miden desde el borde superior de la pantalla, los negativos desde el borde inferior de la pantalla. El primer programa con tortugas Se van a trazar un par de l\u00edneas en la terminal de Python para crear una nueva tortuga y empezar a dibujar un rect\u00e1ngulo. (La variable que refiere a la primera tortuga se llamar\u00e1 raphael ). FICHERO: tortuga01.py import turtle # Set the window size to 800x600 pixels at (0, 0) turtle.setup(800, 600, 0, 0) # Set the Screen object as wn wn = turtle.Screen() # Creates the turtle leonardo = turtle.Turtle() leonardo.forward(300) leonardo.left(90) leonardo.forward(200) wn.exitonclick() Tras la segunda instrucci\u00f3n, se abrir\u00e1 una nueva ventana. El tercer comando coloca un cursor \u2013llamando cari\u00f1osamente a una turtle del m\u00f3dulo\u2013 a la que se le ha puesto el nombre de raphael . Las siguientes tres l\u00edneas mueven a raphael hacia adelante, gira hacia la izquierda, y lo mueve hacia adelante una vez m\u00e1s, completando dos lados de un rect\u00e1ngulo. Despu\u00e9s de introducir estos comandos, se ver\u00e1 una ventana que se parecer\u00e1 a esto: Aqu\u00ed hay un par de cosas que se necesita entender acerca de este programa. La primera l\u00ednea le dice a Python que cargue un m\u00f3dulo llamado turtle . Dicho m\u00f3dulo trae dos nuevos tipos que se pueden utilizar: la clase Turtle , y la clase Screen . La notaci\u00f3n de puntos turtle.Turtle significa \u201cLa clase Turtle definida en el m\u00f3dulo turtle \u201d (Python distingue entre may\u00fasculas y min\u00fasculas, as\u00ed que el nombre del m\u00f3dulo, con una t min\u00fascula, es diferente al que la tiene may\u00fascula). A continuaci\u00f3n, se crea y abre lo que se llama una Screen , que se asigna a la variable wn . Cada Screen contiene un lienzo ( canvas ), que es el \u00e1rea dentro de ella en la que se puede dibujar. En la siguiente l\u00ednea se crea una tortuga. La variable leonardo se usa para referirse a ella. Estas tres primeras l\u00edneas son la preparaci\u00f3n para ahora hacer algunas cosas \u00fatiles. A continuaci\u00f3n se instruye al objeto leonardo para que se mueva, y que gire. Se hace mediante la invocaci\u00f3n a los m\u00e9todos de leonardo \u2014instrucciones a las que todas las tortugas saben c\u00f3mo responder. La \u00faltima l\u00ednea tambi\u00e9n desempe\u00f1a un papel: la variable wn se refiere a la ventana activa. Cuando se invoca el m\u00e9todo exitonclick , se detiene la ejecuci\u00f3n del programa y se espera a que el usuario haga click con el rat\u00f3n en alg\u00fan lugar de la ventana. Cuando este evento click se produce, la respuesta es cerrar la ventana de la tortuga y la salida (la ejecuci\u00f3n de la parada) del programa de Python. Un objeto puede tener varios m\u00e9todos \u2014las cosas que puede hacer\u2014 y tambi\u00e9n puede tener atributos (tambi\u00e9n llamados propiedades ). Por ejemplo, cada tortuga ( Turtle ) tiene un atributo color . El modo de invocarlo es leonardo.color(\"red\") que har\u00e1 a leonardo rojo, y el dibujo ser\u00e1 de color rojo tambi\u00e9n. El color de la tortuga, la anchura de la pluma, la posici\u00f3n de la tortuga dentro de la ventana, la apariencia, etc. son partes de su estado actual. Del mismo modo, el objeto Screen tiene un color de fondo y un texto en la barra de t\u00edtulo, y un tama\u00f1o y posici\u00f3n en la pantalla. Todos ellos forman parte del estado del objeto screen . Hay un buen n\u00famero de m\u00e9todos que nos permiten modificar tortugas y screens. Vamos a mostrar un par: FICHERO: tortuga02.py import turtle # set the window size to 800 by 600 pixels at (0, 0) turtle.setup(800, 600, 0, 0) # set wn as a window object wn = turtle.Screen() # set the background color of the window wn.bgcolor(\"lightgreen\") # set the title of the window wn.title(\"\u00a1Hola, Raphael!\") raphael = turtle.Turtle() raphael.color(\"blue\") # make raphael blue raphael.pensize(3) # set the width of the pen raphael.forward(300) raphael.left(120) raphael.forward(300) wn.exitonclick() La ejecuci\u00f3n de este programa crear\u00e1 una ventana gr\u00e1fica que se ver\u00e1 as\u00ed: Cuando se ejecuta este programa aparece esta nueva ventana y permanecer\u00e1 en pantalla hasta que se haga clic en ella. Nota: Se puede encontrar una lista de nombres de colores permitidos en http://www.tcl.tk/man/tcl8.4/TkCmd/colors.htm. Incluye algunos bastante inusuales, como peach puff (bocanada de melocot\u00f3n) y HotPink (rosa caliente) Una manada de tortugas Al igual que podemos tener muchos enteros diferentes en un programa, podemos tener muchas tortugas. Cada una de ellas es una instancia . Cada instancia tiene sus propios atributos y m\u00e9todos -por lo que raphael puede dibujar con un l\u00e1piz negro delgado y estar en alguna posici\u00f3n, mientras que donatello podr\u00eda ir en su propia direcci\u00f3n con un bol\u00edgrafo de color rosa grueso ( fat pink ). Aqu\u00ed est\u00e1 lo que sucede cuando raphael termina su rect\u00e1ngulo, y donatello completa su tri\u00e1ngulo: FICHERO: tortuga03.py import turtle # setup the window and its attributes turtle.setup(800, 600, 0, 0) wn = turtle.Screen() wn.bgcolor(\"lightgreen\") wn.title(\"donatello & raphael\") # instantiate (create) donatello and set his attributes donatello = turtle.Turtle() donatello.color(\"hotpink\") donatello.pensize(5) # instantiate raphael raphael = turtle.Turtle() # draw an equilateral triangle with donatello donatello.forward(320) donatello.left(120) donatello.forward(320) donatello.left(120) donatello.forward(320) donatello.left(120) # turn donatello around and move her away from the origin donatello.right(180) donatello.forward(320) # make raphael draw a square raphael.forward(200) raphael.left(90) raphael.forward(200) raphael.left(90) raphael.forward(200) raphael.left(90) raphael.forward(200) wn.exitonclick() que genera esto cuando se ejecuta: Algunos trucos y m\u00e9todos de tortugas showturtle() , hideturtle() El m\u00e9todo showturtle() muestra el cursor (la tortuga) mientras que hideturtle() la oculta. penup() y pendown() Los m\u00e9todos pendown() y penup() son equivalentes a bajar y levantar el l\u00e1piz del papel. Una vez levantado el l\u00e1piz del papel, al desplazar la tortuga ya no se dibujan segmentos. Al volver a bajar el l\u00e1piz y desplazar la tortuga, vuelven a dibujarse los segmentos. goto() , setx() y sety() Los p\u00edxeles del \u00e1rea de dibujo se pueden localizar mediante un sistema de coordenadas XY centrado en el centro del \u00e1rea de dibujo. Al crear la ventana, el cursor se sit\u00faa en el centro de la ventana, de coordenadas (0, 0). La funci\u00f3n goto(x, y) permite desplazar el cursor a una posici\u00f3n determinada del \u00e1rea de dibujo y, si la tortuga tiene su l\u00e1piz abajo ( pendown ) traza el recorrido desde la posici\u00f3n actual a las coordenadas indicadas por x e y del m\u00e9todo goto . setx(x) y sety(y) realizan la misma funci\u00f3n que goto pero tocando solo una de las dos coordenadas de destino. pensize() , pencolor() y colormode() El m\u00e9todo pensize(grosor) permite modificar el grosor del trazo. El m\u00e9todo pencolor(rojo, azul, verde) permite modificar el color del trazo. El color se da como combinaci\u00f3n de rojo, azul y verde. Los valores de color se pueden dar como valores enteros entre 0 y 255 o como valores decimales entre 0 y 1. Para elegir entre un modo u otro se utiliza la funci\u00f3n colormode(1) o colormode(255) . Tambi\u00e9n se pueden utilizar nombres de colores, que incluyen entre otros los nombres de colores SVG , en cuyo caso no hace falta utilizar el m\u00e9todo colormode() . dot() La funci\u00f3n dot(grosor, color) permite dibujar un punto del grosor y color indicado en el punto en el que se encuentre la tortuga. El grosor se indica en p\u00edxeles y el color se expresa como en la funci\u00f3n pencolor() vista en el apartado anterior (entre par\u00e9ntesis, como tupla, o sin par\u00e9ntesis). Los puntos se dibujan indistintamente de la posici\u00f3n del l\u00e1piz ( penup , pendown ). \u00c1ngulos y distancias negativas Los m\u00e9todos de la tortuga pueden utilizar \u00e1ngulos y distancias negativas. As\u00ed donatello.forward(-100) mover\u00e1 a donatello hacia atr\u00e1s y donatello.left(-30) lo gira a la derecha. Adem\u00e1s, dado que hay 360 grados en un c\u00edrculo, al girar 30 a la izquierda se estar\u00e1 en la misma situaci\u00f3n que si se gira 330 a la derecha! (La animaci\u00f3n en la pantalla ser\u00e1 diferente).Tambi\u00e9n hay un m\u00e9todo backward (si se es muy nerd, uno puede disfrutar de mover a raphael hacia adelante mediante raphael.backward(-100) ). Formas de tortuga: shape() Cada tortuga puede tener su propia forma. Las que est\u00e1n disponibles son arrow (flecha), blank (espacio en blanco), circle (c\u00edrculo), classic (cl\u00e1sico), square (cuadrado), triangle (tri\u00e1ngulo), turtle (tortuga). raphael.shape(\"turtle\") Velocidad: speed() Se puede acelerar o ralentizar la velocidad de la animaci\u00f3n de la tortuga. El ajuste de velocidad var\u00eda entre 1 (lento) a 10 (m\u00e1s r\u00e1pido). Sin embargo, si se establece la velocidad a 0 se desactivar\u00e1 la animaci\u00f3n y se ir\u00e1 lo m\u00e1s r\u00e1pido posible. raphael.speed(10) Sello: stamp() Una tortuga puede crear un \u201csello\u201d ( stamp ) de su huella en el lienzo que seguir\u00e1 as\u00ed despu\u00e9s de que la tortuga se haya movido a otra parte. Se sella, aun cuando la pluma est\u00e9 arriba. El siguiente ejemplo muestra algunas de estas nuevas caracter\u00edsticas: FICHERO: tortuga04.py import turtle turtle.setup(800, 600, 0, 0) wn = turtle.Screen() wn.bgcolor(\"lightgreen\") wn.title(\"Donatello's Spiral\") donatello = turtle.Turtle() donatello.shape(\"turtle\") donatello.color(\"blue\") donatello.penup() # this is new size = 20 for i in range(30): donatello.stamp() # leave an impression on the canvas size = size + 3 # increase the size on every iteration donatello.forward(size) # move donatello along donatello.right(24) # and turn her turtle.done() que genera esto cuando se ejecuta: Relleno de figuras El m\u00e9todo begin_fill() indica a Python que las figuras que se dibujen a partir de ese momento se deben rellenar. El m\u00e9todo end_fill() indica a Python que las figuras deben dejar de rellenarse. El m\u00e9todo fillcollor(color) permite establecer el color de relleno, de la misma manera que la funci\u00f3n pencolor() . Si no se establece un color de relleno distinto, el color de relleno predeterminado es el negro. Para rellenar una figura, se debe llamar a la funci\u00f3n begin_fill() , dibujar la figura y llamar a la funci\u00f3n end_fill() . FICHERO: tortuga05.py import turtle wn = turtle.Screen() wn.setup(800, 600, 0, 0) wn.title(\"Relleno de figuras\") leonardo = turtle.Turtle() leonardo.hideturtle() leonardo.pensize(5) leonardo.fillcolor(\"red\") leonardo.begin_fill() leonardo.goto(100, 0) leonardo.goto(100, 50) leonardo.goto(0, 50) leonardo.goto(0, 0) leonardo.end_fill() wn.exitonclick() Si no se establece un color de relleno distinto, el color de relleno predeterminado es el negro. Aunque realmente no es necesario dibujar la figura completa ya que Python rellena la figura aunque no se cierre (es como si Python uniera el \u00faltimo punto de la figura con el primero). Si las l\u00edneas de la figura se cruzan, Python rellena cada una de las partes cerradas. FICHERO: turtle06.py import turtle wn = turtle.Screen() wn.setup(800, 600, 0, 0) wn.title(\"Relleno de figuras\") leonardo = turtle.Turtle() leonardo.speed(1) leonardo.pensize(5) leonardo.fillcolor(\"red\") leonardo.begin_fill() leonardo.goto(100, 100) leonardo.goto(200, -100) leonardo.goto(300, 0) leonardo.goto(0, 0) leonardo.end_fill() leonardo.hideturtle() wn.exitonclick() Cambio de coordenadas: setworldcoordinates() La funci\u00f3n setworldcoordinates(x1, y1, x2, y2) permite modificar las coordenadas de la ventana, definiendo las coordenadas de la esquina inferior izquierda (x1, y1) y de la esquina superior derecha (x2, y2). El inter\u00e9s de esta funci\u00f3n es poder desplazar el origen del centro de coordenadas y cambiar la escala : De forma predeterminada, el origen est\u00e1 en el centro de la ventana y cada p\u00edxel es una unidad: import turtle wn = turtle.Screen() wn.setup(450, 200, 0, 0) wn.title(\"Romero Vargas\") leonardo = turtle.Turtle() leonardo.hideturtle() leonardo.goto(150, 150) wn.exitonclick() Con setworldcoordinates() se puede cambiar las coordenadas de manera que el origen est\u00e9 en cualquier sitio, por ejemplo en la esquina inferior izquierda. import turtle wn = turtle.Screen() wn.setup(450, 200, 0, 0) wn.title(\"www.mclibre.org\") wn.setworldcoordinates(0, 0, 449, 199) leonardo = turtle.Turtle() leonardo.hideturtle() leonardo.goto(150, 150) wn.exitonclick() Escribir texto: write() La funci\u00f3n write(texto, desplazarTortuga, alineaci\u00f3n, fuente) permite escribir texto en el espacio de dibujo. Los cuatro argumentos de la funci\u00f3n son: texto : cadena de texto a escribir. La esquina inferior izquierda del texto se sit\u00faa donde est\u00e9 el cursor, salvo que se indique otra cosa con el tercer argumento (alineaci\u00f3n). import turtle wn = turtle.Screen() wn.setup(800, 600, 0, 0) leonardo = turtle.Turtle() leonardo.goto(50, 10) leonardo.write(\"Esto es una prueba\") wn.exitonclick() desplazarTortuga : valor booleano que indica si el cursor se desplaza autom\u00e1ticamente a la esquina inferior derecha del texto. El valor predeterminado es False import turtle wn = turtle.Screen() wn.setup(800, 600, 0, 0) leonardo = turtle.Turtle() leonardo.goto(50, 10) leonardo.write(\"Esto es una prueba\", True) wn.exitonclick() ] alineaci\u00f3n : cadena ( left , center , right ) que indica si el texto se escribe a la izquierda, al centro o a la derecha a partir de la posici\u00f3n del cursor. El valor predeterminado es left . from turtle import * setup(450, 150, 0, 0) screensize(300, 150) title(\"www.mclibre.org\") goto(50,10) write(\"Esto es una prueba\", False, \"left\") fuente : tupla de hasta tres elementos que indican el tipo de letra (cualquiera de los instalados en el ordenador: \"arial\", \"courier\", etc.), su tama\u00f1o y variante (\"bold\", \"italic\", \"underline\", \"overstrike\" -se pueden utilizar varios a la vez-). import turtle wn = turtle.Screen() wn.setup(800, 600, 0, 0) leonardo = turtle.Turtle() leonardo.goto(50, 10) leonardo.write(\"Esto es una prueba\", False, \"right\", (\"arial\", 20, \"bold italic\")) wn.exitonclick() ] Se pueden omitir los \u00faltimos argumentos, pero no los anteriores. Por ejemplo, podemos omitir el tipo de letra (el cuarto argumento), pero si queremos especificar el tipo de letra, debemos indicar los tres argumentos anteriores. Solicitar valores al usuario: textinput() y numinput() Para pedir datos al usuario en un programa que dibuja gr\u00e1ficos de tortuga se pueden utilizar la funci\u00f3n input() . El inconveniente es que esta funci\u00f3n solicita los datos en la ventana de la consola, por lo que hay que estar cambiando el foco de una ventana a otra. En vez de la funci\u00f3n input() , se pueden utilizar las funciones textinput() y numinput() de la biblioteca turtle . La funci\u00f3n textinput(<t\u00edtulo>, <mensaje>) solicita una cadena al usuario en una ventana emergente. Los dos argumentos de la funci\u00f3n son: t\u00edtulo : el t\u00edtulo de la ventana emergente. mensaje : el texto que se muestra en la ventana. import turtle wn = turtle.Screen() wn.setup(800, 600, 0, 0) name = wn.textinput(\"Nombre\", \"\u00bfCu\u00e1l es su nombre?\") leonardo = turtle.Turtle() leonardo.write(name) wn.exitonclick() El m\u00e9todo numinput(<t\u00edtulo>, <mensaje>, <valorPredeterminado>, <valorM\u00ednimo>, <valorM\u00e1ximo>) solicita un n\u00famero al usuario en una ventana emergente. Los dos argumentos de la funci\u00f3n son: t\u00edtulo : el t\u00edtulo de la ventana emergente. mensaje : el texto que se muestra en la ventana. valorPredeterminado : el valor que se muestra en la ventana de forma predeterminada. valorM\u00ednimo : el valor m\u00ednimo que puede escribir el usuario. valorM\u00e1ximo : el valor m\u00e1ximo que puede escribir el usuario. from turtle import * setup(450, 150, 0, 0) screensize(300, 150) title(\"www.mclibre.org\") edad = numinput(\"Edad\", \"\u00bfCu\u00e1l es su edad?\", 20, 0, 120) Si se escribe un valor num\u00e9rico menor que valorM\u00ednimo o mayor que valorM\u00e1ximo, se mostrar\u00e1 un aviso. Vista general de los m\u00e9todos para Turtle y Screen Turtle Movimiento de Turtle Mover y dibujar forward() | fd() backward() | bk() | back() right() | rt() left() | lt() goto() | setpos() | setposition() setx() sety() setheading() | seth() home() circle() dot() stamp() clearstamp() clearstamps() undo() speed() Mostrar el estado de Turtle position() | pos() towards() xcor() ycor() heading() distance() Medidas degrees() radians() Control del l\u00e1piz Estado del l\u00e1piz pendown() | pd() | down() penup() | pu() | up() pensize() | width() pen() isdown() Control del color color() pencolor() fillcolor() Relleno filling() begin_fill() end_fill() M\u00e1s controles de dibujo reset() clear() write() Estado de Turtle Visibilidad showturtle() | st() hideturtle() | ht() isvisible() Apariencia shape() resizemode() shapesize() | turtlesize() shearfactor() settiltangle() tiltangle() tilt() shapetransform() get_shapepoly() Uso de eventos onclick() onrelease() ondrag() M\u00e9todos especiales de Turtle begin_poly() end_poly() get_poly() clone() getturtle() | getpen() getscreen() setundobuffer() undobufferentries() M\u00e9todos de TurtleScreen/Screen Control de la ventana bgcolor() bgpic() clear() | clearscreen() reset() | resetscreen() screensize() setworldcoordinates() Control de la animaci\u00f3n delay() tracer() update() Uso de eventos de pantalla listen() onkey() | onkeyrelease() onkeypress() onclick() | onscreenclick() ontimer() mainloop() | done() Configuraciones y m\u00e9todos especiales mode() colormode() getcanvas() getshapes() register_shape() | addshape() turtles() window_height() window_width() M\u00e9todos de entrada textinput() numinput() M\u00e9todos espec\u00edficos de Screen bye() exitonclick() setup() title() Ejercicios 1.- Crea mediante funciones las siguientes formas geom\u00e9tricas: un cuadrado de tama\u00f1o side SOLUCI\u00d3N: eje0101.py una estrella de cinco puntas de lado side SOLUCI\u00d3N: eje0102.py un pol\u00edgono de sides lados de longitud side_lenght SOLUCI\u00d3N: eje0103.py una espiral cuadrada azul en fondo verde de lado size y decremento dec SOLUCI\u00d3N: eje0104.py 2.- Crear un programa que dibuje l\u00edneas de ancho creciente alrededor de un punto central: creando un patr\u00f3n atractivo. SOLUCI\u00d3N: eje0201.py partiendo del ejercicio anterior pero creando un patr\u00f3n hexagonal SOLUCI\u00d3N: eje0202.py terminar dando color para construir el \"Arcoiris de Benceno\" SOLUCI\u00d3N: eje0203.py 3.- Contamos con un fichero covid-19.txt que mantiene un hist\u00f3rico de contagios del virus que nos est\u00e1 confinando con el siguiente formato por l\u00ednea: <fecha \"aaaammdd\">, <casos>, <fallecidos>, <recuperados> Se trata de construir un gr\u00e1fico por cada uno de los par\u00e1metros ofrecidos por este fichero adem\u00e1s de un par\u00e1metro calculado, <casos/d\u00eda> , que nos permitir\u00e1 describir el proceso de evoluci\u00f3n de la curva de contagios. Los gr\u00e1ficos han de ser semejantes a los siguientes: Se recomienda: Hacer uso de funciones para la reutilizaci\u00f3n del c\u00f3digo Utilizar par\u00e1metros para generalizar las posibilidades de reutilizaci\u00f3n del c\u00f3digo SOLUCI\u00d3N: eje0300.py","title":"La tortuga que dibuja"},{"location":"la_tortuga_que_dibuja/#la-tortuga-que-dibuja","text":"En 1967 Wally Feurzeig y Seymour Papert crearon Logo , un lenguaje de programaci\u00f3n con fines educativos. Ese lenguaje inclu\u00eda los \"gr\u00e1ficos de tortuga\". La \"tortuga\" de Logo es un cursor al que se le pueden dar \u00f3rdenes de movimiento (avance, retroceso o giro) y que puede ir dejando un rastro sobre la pantalla. Moviendo adecuadamente la tortuga se puede conseguir dibujar todo tipo de figuras. Python incluye un m\u00f3dulo llamado turtle que permite crear \u00e9ste tipo de gr\u00e1ficos tortuga . Para utilizar el m\u00f3dulo turtle s\u00f3lo hace falta importarlo: Si se va a escribir c\u00f3digo no orientado a objetos: from turtle import * Si se va a escribir c\u00f3digo orientado a objetos (que es la que se usar\u00e1 a partir de ahora): import turtle","title":"La tortuga que dibuja"},{"location":"la_tortuga_que_dibuja/#la-ventana-de-dibujo-setup-y-title","text":"El m\u00f3dulo turtle dibuja en una ventana propia. El m\u00e9todo/funci\u00f3n setup(ancho, alto, posicionX, posicionY) permite definir el tama\u00f1o y la posici\u00f3n inicial de la ventana. Los cuatro argumentos de la funci\u00f3n son (en p\u00edxeles): ancho : ancho de la ventana. alto : alto de la ventana. posicionX : posici\u00f3n horizontal de la ventana. Los valores positivos se miden desde el borde izquierdo de la pantalla, los negativos desde el borde derecho de la pantalla. posicionY : posici\u00f3n vertical de la ventana. Los valores positivos se miden desde el borde superior de la pantalla, los negativos desde el borde inferior de la pantalla.","title":"La ventana de dibujo: setup() y title()"},{"location":"la_tortuga_que_dibuja/#el-primer-programa-con-tortugas","text":"Se van a trazar un par de l\u00edneas en la terminal de Python para crear una nueva tortuga y empezar a dibujar un rect\u00e1ngulo. (La variable que refiere a la primera tortuga se llamar\u00e1 raphael ). FICHERO: tortuga01.py import turtle # Set the window size to 800x600 pixels at (0, 0) turtle.setup(800, 600, 0, 0) # Set the Screen object as wn wn = turtle.Screen() # Creates the turtle leonardo = turtle.Turtle() leonardo.forward(300) leonardo.left(90) leonardo.forward(200) wn.exitonclick() Tras la segunda instrucci\u00f3n, se abrir\u00e1 una nueva ventana. El tercer comando coloca un cursor \u2013llamando cari\u00f1osamente a una turtle del m\u00f3dulo\u2013 a la que se le ha puesto el nombre de raphael . Las siguientes tres l\u00edneas mueven a raphael hacia adelante, gira hacia la izquierda, y lo mueve hacia adelante una vez m\u00e1s, completando dos lados de un rect\u00e1ngulo. Despu\u00e9s de introducir estos comandos, se ver\u00e1 una ventana que se parecer\u00e1 a esto: Aqu\u00ed hay un par de cosas que se necesita entender acerca de este programa. La primera l\u00ednea le dice a Python que cargue un m\u00f3dulo llamado turtle . Dicho m\u00f3dulo trae dos nuevos tipos que se pueden utilizar: la clase Turtle , y la clase Screen . La notaci\u00f3n de puntos turtle.Turtle significa \u201cLa clase Turtle definida en el m\u00f3dulo turtle \u201d (Python distingue entre may\u00fasculas y min\u00fasculas, as\u00ed que el nombre del m\u00f3dulo, con una t min\u00fascula, es diferente al que la tiene may\u00fascula). A continuaci\u00f3n, se crea y abre lo que se llama una Screen , que se asigna a la variable wn . Cada Screen contiene un lienzo ( canvas ), que es el \u00e1rea dentro de ella en la que se puede dibujar. En la siguiente l\u00ednea se crea una tortuga. La variable leonardo se usa para referirse a ella. Estas tres primeras l\u00edneas son la preparaci\u00f3n para ahora hacer algunas cosas \u00fatiles. A continuaci\u00f3n se instruye al objeto leonardo para que se mueva, y que gire. Se hace mediante la invocaci\u00f3n a los m\u00e9todos de leonardo \u2014instrucciones a las que todas las tortugas saben c\u00f3mo responder. La \u00faltima l\u00ednea tambi\u00e9n desempe\u00f1a un papel: la variable wn se refiere a la ventana activa. Cuando se invoca el m\u00e9todo exitonclick , se detiene la ejecuci\u00f3n del programa y se espera a que el usuario haga click con el rat\u00f3n en alg\u00fan lugar de la ventana. Cuando este evento click se produce, la respuesta es cerrar la ventana de la tortuga y la salida (la ejecuci\u00f3n de la parada) del programa de Python. Un objeto puede tener varios m\u00e9todos \u2014las cosas que puede hacer\u2014 y tambi\u00e9n puede tener atributos (tambi\u00e9n llamados propiedades ). Por ejemplo, cada tortuga ( Turtle ) tiene un atributo color . El modo de invocarlo es leonardo.color(\"red\") que har\u00e1 a leonardo rojo, y el dibujo ser\u00e1 de color rojo tambi\u00e9n. El color de la tortuga, la anchura de la pluma, la posici\u00f3n de la tortuga dentro de la ventana, la apariencia, etc. son partes de su estado actual. Del mismo modo, el objeto Screen tiene un color de fondo y un texto en la barra de t\u00edtulo, y un tama\u00f1o y posici\u00f3n en la pantalla. Todos ellos forman parte del estado del objeto screen . Hay un buen n\u00famero de m\u00e9todos que nos permiten modificar tortugas y screens. Vamos a mostrar un par: FICHERO: tortuga02.py import turtle # set the window size to 800 by 600 pixels at (0, 0) turtle.setup(800, 600, 0, 0) # set wn as a window object wn = turtle.Screen() # set the background color of the window wn.bgcolor(\"lightgreen\") # set the title of the window wn.title(\"\u00a1Hola, Raphael!\") raphael = turtle.Turtle() raphael.color(\"blue\") # make raphael blue raphael.pensize(3) # set the width of the pen raphael.forward(300) raphael.left(120) raphael.forward(300) wn.exitonclick() La ejecuci\u00f3n de este programa crear\u00e1 una ventana gr\u00e1fica que se ver\u00e1 as\u00ed: Cuando se ejecuta este programa aparece esta nueva ventana y permanecer\u00e1 en pantalla hasta que se haga clic en ella. Nota: Se puede encontrar una lista de nombres de colores permitidos en http://www.tcl.tk/man/tcl8.4/TkCmd/colors.htm. Incluye algunos bastante inusuales, como peach puff (bocanada de melocot\u00f3n) y HotPink (rosa caliente)","title":"El primer programa con tortugas"},{"location":"la_tortuga_que_dibuja/#una-manada-de-tortugas","text":"Al igual que podemos tener muchos enteros diferentes en un programa, podemos tener muchas tortugas. Cada una de ellas es una instancia . Cada instancia tiene sus propios atributos y m\u00e9todos -por lo que raphael puede dibujar con un l\u00e1piz negro delgado y estar en alguna posici\u00f3n, mientras que donatello podr\u00eda ir en su propia direcci\u00f3n con un bol\u00edgrafo de color rosa grueso ( fat pink ). Aqu\u00ed est\u00e1 lo que sucede cuando raphael termina su rect\u00e1ngulo, y donatello completa su tri\u00e1ngulo: FICHERO: tortuga03.py import turtle # setup the window and its attributes turtle.setup(800, 600, 0, 0) wn = turtle.Screen() wn.bgcolor(\"lightgreen\") wn.title(\"donatello & raphael\") # instantiate (create) donatello and set his attributes donatello = turtle.Turtle() donatello.color(\"hotpink\") donatello.pensize(5) # instantiate raphael raphael = turtle.Turtle() # draw an equilateral triangle with donatello donatello.forward(320) donatello.left(120) donatello.forward(320) donatello.left(120) donatello.forward(320) donatello.left(120) # turn donatello around and move her away from the origin donatello.right(180) donatello.forward(320) # make raphael draw a square raphael.forward(200) raphael.left(90) raphael.forward(200) raphael.left(90) raphael.forward(200) raphael.left(90) raphael.forward(200) wn.exitonclick() que genera esto cuando se ejecuta:","title":"Una manada de tortugas"},{"location":"la_tortuga_que_dibuja/#algunos-trucos-y-metodos-de-tortugas","text":"","title":"Algunos trucos y m\u00e9todos de tortugas"},{"location":"la_tortuga_que_dibuja/#showturtle-hideturtle","text":"El m\u00e9todo showturtle() muestra el cursor (la tortuga) mientras que hideturtle() la oculta.","title":"showturtle(), hideturtle()"},{"location":"la_tortuga_que_dibuja/#penup-y-pendown","text":"Los m\u00e9todos pendown() y penup() son equivalentes a bajar y levantar el l\u00e1piz del papel. Una vez levantado el l\u00e1piz del papel, al desplazar la tortuga ya no se dibujan segmentos. Al volver a bajar el l\u00e1piz y desplazar la tortuga, vuelven a dibujarse los segmentos.","title":"penup() y pendown()"},{"location":"la_tortuga_que_dibuja/#goto-setx-y-sety","text":"Los p\u00edxeles del \u00e1rea de dibujo se pueden localizar mediante un sistema de coordenadas XY centrado en el centro del \u00e1rea de dibujo. Al crear la ventana, el cursor se sit\u00faa en el centro de la ventana, de coordenadas (0, 0). La funci\u00f3n goto(x, y) permite desplazar el cursor a una posici\u00f3n determinada del \u00e1rea de dibujo y, si la tortuga tiene su l\u00e1piz abajo ( pendown ) traza el recorrido desde la posici\u00f3n actual a las coordenadas indicadas por x e y del m\u00e9todo goto . setx(x) y sety(y) realizan la misma funci\u00f3n que goto pero tocando solo una de las dos coordenadas de destino.","title":"goto(), setx() y sety()"},{"location":"la_tortuga_que_dibuja/#pensize-pencolor-y-colormode","text":"El m\u00e9todo pensize(grosor) permite modificar el grosor del trazo. El m\u00e9todo pencolor(rojo, azul, verde) permite modificar el color del trazo. El color se da como combinaci\u00f3n de rojo, azul y verde. Los valores de color se pueden dar como valores enteros entre 0 y 255 o como valores decimales entre 0 y 1. Para elegir entre un modo u otro se utiliza la funci\u00f3n colormode(1) o colormode(255) . Tambi\u00e9n se pueden utilizar nombres de colores, que incluyen entre otros los nombres de colores SVG , en cuyo caso no hace falta utilizar el m\u00e9todo colormode() .","title":"pensize(), pencolor() y colormode()"},{"location":"la_tortuga_que_dibuja/#dot","text":"La funci\u00f3n dot(grosor, color) permite dibujar un punto del grosor y color indicado en el punto en el que se encuentre la tortuga. El grosor se indica en p\u00edxeles y el color se expresa como en la funci\u00f3n pencolor() vista en el apartado anterior (entre par\u00e9ntesis, como tupla, o sin par\u00e9ntesis). Los puntos se dibujan indistintamente de la posici\u00f3n del l\u00e1piz ( penup , pendown ).","title":"dot()"},{"location":"la_tortuga_que_dibuja/#angulos-y-distancias-negativas","text":"Los m\u00e9todos de la tortuga pueden utilizar \u00e1ngulos y distancias negativas. As\u00ed donatello.forward(-100) mover\u00e1 a donatello hacia atr\u00e1s y donatello.left(-30) lo gira a la derecha. Adem\u00e1s, dado que hay 360 grados en un c\u00edrculo, al girar 30 a la izquierda se estar\u00e1 en la misma situaci\u00f3n que si se gira 330 a la derecha! (La animaci\u00f3n en la pantalla ser\u00e1 diferente).Tambi\u00e9n hay un m\u00e9todo backward (si se es muy nerd, uno puede disfrutar de mover a raphael hacia adelante mediante raphael.backward(-100) ).","title":"\u00c1ngulos y distancias negativas"},{"location":"la_tortuga_que_dibuja/#formas-de-tortuga-shape","text":"Cada tortuga puede tener su propia forma. Las que est\u00e1n disponibles son arrow (flecha), blank (espacio en blanco), circle (c\u00edrculo), classic (cl\u00e1sico), square (cuadrado), triangle (tri\u00e1ngulo), turtle (tortuga). raphael.shape(\"turtle\")","title":"Formas de tortuga: shape()"},{"location":"la_tortuga_que_dibuja/#velocidad-speed","text":"Se puede acelerar o ralentizar la velocidad de la animaci\u00f3n de la tortuga. El ajuste de velocidad var\u00eda entre 1 (lento) a 10 (m\u00e1s r\u00e1pido). Sin embargo, si se establece la velocidad a 0 se desactivar\u00e1 la animaci\u00f3n y se ir\u00e1 lo m\u00e1s r\u00e1pido posible. raphael.speed(10)","title":"Velocidad: speed()"},{"location":"la_tortuga_que_dibuja/#sello-stamp","text":"Una tortuga puede crear un \u201csello\u201d ( stamp ) de su huella en el lienzo que seguir\u00e1 as\u00ed despu\u00e9s de que la tortuga se haya movido a otra parte. Se sella, aun cuando la pluma est\u00e9 arriba. El siguiente ejemplo muestra algunas de estas nuevas caracter\u00edsticas: FICHERO: tortuga04.py import turtle turtle.setup(800, 600, 0, 0) wn = turtle.Screen() wn.bgcolor(\"lightgreen\") wn.title(\"Donatello's Spiral\") donatello = turtle.Turtle() donatello.shape(\"turtle\") donatello.color(\"blue\") donatello.penup() # this is new size = 20 for i in range(30): donatello.stamp() # leave an impression on the canvas size = size + 3 # increase the size on every iteration donatello.forward(size) # move donatello along donatello.right(24) # and turn her turtle.done() que genera esto cuando se ejecuta:","title":"Sello: stamp()"},{"location":"la_tortuga_que_dibuja/#relleno-de-figuras","text":"El m\u00e9todo begin_fill() indica a Python que las figuras que se dibujen a partir de ese momento se deben rellenar. El m\u00e9todo end_fill() indica a Python que las figuras deben dejar de rellenarse. El m\u00e9todo fillcollor(color) permite establecer el color de relleno, de la misma manera que la funci\u00f3n pencolor() . Si no se establece un color de relleno distinto, el color de relleno predeterminado es el negro. Para rellenar una figura, se debe llamar a la funci\u00f3n begin_fill() , dibujar la figura y llamar a la funci\u00f3n end_fill() . FICHERO: tortuga05.py import turtle wn = turtle.Screen() wn.setup(800, 600, 0, 0) wn.title(\"Relleno de figuras\") leonardo = turtle.Turtle() leonardo.hideturtle() leonardo.pensize(5) leonardo.fillcolor(\"red\") leonardo.begin_fill() leonardo.goto(100, 0) leonardo.goto(100, 50) leonardo.goto(0, 50) leonardo.goto(0, 0) leonardo.end_fill() wn.exitonclick() Si no se establece un color de relleno distinto, el color de relleno predeterminado es el negro. Aunque realmente no es necesario dibujar la figura completa ya que Python rellena la figura aunque no se cierre (es como si Python uniera el \u00faltimo punto de la figura con el primero). Si las l\u00edneas de la figura se cruzan, Python rellena cada una de las partes cerradas. FICHERO: turtle06.py import turtle wn = turtle.Screen() wn.setup(800, 600, 0, 0) wn.title(\"Relleno de figuras\") leonardo = turtle.Turtle() leonardo.speed(1) leonardo.pensize(5) leonardo.fillcolor(\"red\") leonardo.begin_fill() leonardo.goto(100, 100) leonardo.goto(200, -100) leonardo.goto(300, 0) leonardo.goto(0, 0) leonardo.end_fill() leonardo.hideturtle() wn.exitonclick()","title":"Relleno de figuras"},{"location":"la_tortuga_que_dibuja/#cambio-de-coordenadas-setworldcoordinates","text":"La funci\u00f3n setworldcoordinates(x1, y1, x2, y2) permite modificar las coordenadas de la ventana, definiendo las coordenadas de la esquina inferior izquierda (x1, y1) y de la esquina superior derecha (x2, y2). El inter\u00e9s de esta funci\u00f3n es poder desplazar el origen del centro de coordenadas y cambiar la escala : De forma predeterminada, el origen est\u00e1 en el centro de la ventana y cada p\u00edxel es una unidad: import turtle wn = turtle.Screen() wn.setup(450, 200, 0, 0) wn.title(\"Romero Vargas\") leonardo = turtle.Turtle() leonardo.hideturtle() leonardo.goto(150, 150) wn.exitonclick() Con setworldcoordinates() se puede cambiar las coordenadas de manera que el origen est\u00e9 en cualquier sitio, por ejemplo en la esquina inferior izquierda. import turtle wn = turtle.Screen() wn.setup(450, 200, 0, 0) wn.title(\"www.mclibre.org\") wn.setworldcoordinates(0, 0, 449, 199) leonardo = turtle.Turtle() leonardo.hideturtle() leonardo.goto(150, 150) wn.exitonclick()","title":"Cambio de coordenadas: setworldcoordinates()"},{"location":"la_tortuga_que_dibuja/#escribir-texto-write","text":"La funci\u00f3n write(texto, desplazarTortuga, alineaci\u00f3n, fuente) permite escribir texto en el espacio de dibujo. Los cuatro argumentos de la funci\u00f3n son: texto : cadena de texto a escribir. La esquina inferior izquierda del texto se sit\u00faa donde est\u00e9 el cursor, salvo que se indique otra cosa con el tercer argumento (alineaci\u00f3n). import turtle wn = turtle.Screen() wn.setup(800, 600, 0, 0) leonardo = turtle.Turtle() leonardo.goto(50, 10) leonardo.write(\"Esto es una prueba\") wn.exitonclick() desplazarTortuga : valor booleano que indica si el cursor se desplaza autom\u00e1ticamente a la esquina inferior derecha del texto. El valor predeterminado es False import turtle wn = turtle.Screen() wn.setup(800, 600, 0, 0) leonardo = turtle.Turtle() leonardo.goto(50, 10) leonardo.write(\"Esto es una prueba\", True) wn.exitonclick() ] alineaci\u00f3n : cadena ( left , center , right ) que indica si el texto se escribe a la izquierda, al centro o a la derecha a partir de la posici\u00f3n del cursor. El valor predeterminado es left . from turtle import * setup(450, 150, 0, 0) screensize(300, 150) title(\"www.mclibre.org\") goto(50,10) write(\"Esto es una prueba\", False, \"left\") fuente : tupla de hasta tres elementos que indican el tipo de letra (cualquiera de los instalados en el ordenador: \"arial\", \"courier\", etc.), su tama\u00f1o y variante (\"bold\", \"italic\", \"underline\", \"overstrike\" -se pueden utilizar varios a la vez-). import turtle wn = turtle.Screen() wn.setup(800, 600, 0, 0) leonardo = turtle.Turtle() leonardo.goto(50, 10) leonardo.write(\"Esto es una prueba\", False, \"right\", (\"arial\", 20, \"bold italic\")) wn.exitonclick() ] Se pueden omitir los \u00faltimos argumentos, pero no los anteriores. Por ejemplo, podemos omitir el tipo de letra (el cuarto argumento), pero si queremos especificar el tipo de letra, debemos indicar los tres argumentos anteriores.","title":"Escribir texto: write()"},{"location":"la_tortuga_que_dibuja/#solicitar-valores-al-usuario-textinput-y-numinput","text":"Para pedir datos al usuario en un programa que dibuja gr\u00e1ficos de tortuga se pueden utilizar la funci\u00f3n input() . El inconveniente es que esta funci\u00f3n solicita los datos en la ventana de la consola, por lo que hay que estar cambiando el foco de una ventana a otra. En vez de la funci\u00f3n input() , se pueden utilizar las funciones textinput() y numinput() de la biblioteca turtle . La funci\u00f3n textinput(<t\u00edtulo>, <mensaje>) solicita una cadena al usuario en una ventana emergente. Los dos argumentos de la funci\u00f3n son: t\u00edtulo : el t\u00edtulo de la ventana emergente. mensaje : el texto que se muestra en la ventana. import turtle wn = turtle.Screen() wn.setup(800, 600, 0, 0) name = wn.textinput(\"Nombre\", \"\u00bfCu\u00e1l es su nombre?\") leonardo = turtle.Turtle() leonardo.write(name) wn.exitonclick() El m\u00e9todo numinput(<t\u00edtulo>, <mensaje>, <valorPredeterminado>, <valorM\u00ednimo>, <valorM\u00e1ximo>) solicita un n\u00famero al usuario en una ventana emergente. Los dos argumentos de la funci\u00f3n son: t\u00edtulo : el t\u00edtulo de la ventana emergente. mensaje : el texto que se muestra en la ventana. valorPredeterminado : el valor que se muestra en la ventana de forma predeterminada. valorM\u00ednimo : el valor m\u00ednimo que puede escribir el usuario. valorM\u00e1ximo : el valor m\u00e1ximo que puede escribir el usuario. from turtle import * setup(450, 150, 0, 0) screensize(300, 150) title(\"www.mclibre.org\") edad = numinput(\"Edad\", \"\u00bfCu\u00e1l es su edad?\", 20, 0, 120) Si se escribe un valor num\u00e9rico menor que valorM\u00ednimo o mayor que valorM\u00e1ximo, se mostrar\u00e1 un aviso.","title":"Solicitar valores al usuario: textinput() y numinput()"},{"location":"la_tortuga_que_dibuja/#vista-general-de-los-metodos-para-turtle-y-screen","text":"","title":"Vista general de los m\u00e9todos para Turtle y Screen"},{"location":"la_tortuga_que_dibuja/#turtle","text":"","title":"Turtle"},{"location":"la_tortuga_que_dibuja/#movimiento-de-turtle","text":"","title":"Movimiento de Turtle"},{"location":"la_tortuga_que_dibuja/#mover-y-dibujar","text":"forward() | fd() backward() | bk() | back() right() | rt() left() | lt() goto() | setpos() | setposition() setx() sety() setheading() | seth() home() circle() dot() stamp() clearstamp() clearstamps() undo() speed()","title":"Mover y dibujar"},{"location":"la_tortuga_que_dibuja/#mostrar-el-estado-de-turtle","text":"position() | pos() towards() xcor() ycor() heading() distance()","title":"Mostrar el estado de Turtle"},{"location":"la_tortuga_que_dibuja/#medidas","text":"degrees() radians()","title":"Medidas"},{"location":"la_tortuga_que_dibuja/#control-del-lapiz","text":"","title":"Control del l\u00e1piz"},{"location":"la_tortuga_que_dibuja/#estado-del-lapiz","text":"pendown() | pd() | down() penup() | pu() | up() pensize() | width() pen() isdown()","title":"Estado del l\u00e1piz"},{"location":"la_tortuga_que_dibuja/#control-del-color","text":"color() pencolor() fillcolor()","title":"Control del color"},{"location":"la_tortuga_que_dibuja/#relleno","text":"filling() begin_fill() end_fill()","title":"Relleno"},{"location":"la_tortuga_que_dibuja/#mas-controles-de-dibujo","text":"reset() clear() write()","title":"M\u00e1s controles de dibujo"},{"location":"la_tortuga_que_dibuja/#estado-de-turtle","text":"","title":"Estado de Turtle"},{"location":"la_tortuga_que_dibuja/#visibilidad","text":"showturtle() | st() hideturtle() | ht() isvisible()","title":"Visibilidad"},{"location":"la_tortuga_que_dibuja/#apariencia","text":"shape() resizemode() shapesize() | turtlesize() shearfactor() settiltangle() tiltangle() tilt() shapetransform() get_shapepoly()","title":"Apariencia"},{"location":"la_tortuga_que_dibuja/#uso-de-eventos","text":"onclick() onrelease() ondrag()","title":"Uso de eventos"},{"location":"la_tortuga_que_dibuja/#metodos-especiales-de-turtle","text":"begin_poly() end_poly() get_poly() clone() getturtle() | getpen() getscreen() setundobuffer() undobufferentries()","title":"M\u00e9todos especiales de Turtle"},{"location":"la_tortuga_que_dibuja/#metodos-de-turtlescreenscreen","text":"","title":"M\u00e9todos de TurtleScreen/Screen"},{"location":"la_tortuga_que_dibuja/#control-de-la-ventana","text":"bgcolor() bgpic() clear() | clearscreen() reset() | resetscreen() screensize() setworldcoordinates()","title":"Control de la ventana"},{"location":"la_tortuga_que_dibuja/#control-de-la-animacion","text":"delay() tracer() update()","title":"Control de la animaci\u00f3n"},{"location":"la_tortuga_que_dibuja/#uso-de-eventos-de-pantalla","text":"listen() onkey() | onkeyrelease() onkeypress() onclick() | onscreenclick() ontimer() mainloop() | done()","title":"Uso de eventos de pantalla"},{"location":"la_tortuga_que_dibuja/#configuraciones-y-metodos-especiales","text":"mode() colormode() getcanvas() getshapes() register_shape() | addshape() turtles() window_height() window_width()","title":"Configuraciones y m\u00e9todos especiales"},{"location":"la_tortuga_que_dibuja/#metodos-de-entrada","text":"textinput() numinput()","title":"M\u00e9todos de entrada"},{"location":"la_tortuga_que_dibuja/#metodos-especificos-de-screen","text":"bye() exitonclick() setup() title()","title":"M\u00e9todos espec\u00edficos de Screen"},{"location":"la_tortuga_que_dibuja/#ejercicios","text":"1.- Crea mediante funciones las siguientes formas geom\u00e9tricas: un cuadrado de tama\u00f1o side SOLUCI\u00d3N: eje0101.py una estrella de cinco puntas de lado side SOLUCI\u00d3N: eje0102.py un pol\u00edgono de sides lados de longitud side_lenght SOLUCI\u00d3N: eje0103.py una espiral cuadrada azul en fondo verde de lado size y decremento dec SOLUCI\u00d3N: eje0104.py 2.- Crear un programa que dibuje l\u00edneas de ancho creciente alrededor de un punto central: creando un patr\u00f3n atractivo. SOLUCI\u00d3N: eje0201.py partiendo del ejercicio anterior pero creando un patr\u00f3n hexagonal SOLUCI\u00d3N: eje0202.py terminar dando color para construir el \"Arcoiris de Benceno\" SOLUCI\u00d3N: eje0203.py 3.- Contamos con un fichero covid-19.txt que mantiene un hist\u00f3rico de contagios del virus que nos est\u00e1 confinando con el siguiente formato por l\u00ednea: <fecha \"aaaammdd\">, <casos>, <fallecidos>, <recuperados> Se trata de construir un gr\u00e1fico por cada uno de los par\u00e1metros ofrecidos por este fichero adem\u00e1s de un par\u00e1metro calculado, <casos/d\u00eda> , que nos permitir\u00e1 describir el proceso de evoluci\u00f3n de la curva de contagios. Los gr\u00e1ficos han de ser semejantes a los siguientes: Se recomienda: Hacer uso de funciones para la reutilizaci\u00f3n del c\u00f3digo Utilizar par\u00e1metros para generalizar las posibilidades de reutilizaci\u00f3n del c\u00f3digo SOLUCI\u00d3N: eje0300.py","title":"Ejercicios"},{"location":"listas_por_comprension/","text":"Listas por comprensi\u00f3n en Python Una lista es uno de los tipos de datos fundamentales de Python. Cada vez que nos encontramos con un nombre de variable seguido de un corchete [] , o un constructor de list , tenemos una lista capaz de contener m\u00faltiples elementos, lo que la convierte en un tipo de datos compuesto. Del mismo modo, tambi\u00e9n es muy f\u00e1cil declarar una nueva lista y luego agregarle uno o m\u00e1s elementos. Creemos una nueva lista poblada, por ejemplo: >>> new_list = [1, 2, 3, 4, 5] >>> new_list [1, 2, 3, 4, 5] O simplemente usemos el m\u00e9todo append() para agregar cualquier cosa a la lista: >>> new_list.append(6) >>> new_list [1, 2, 3, 4, 5, 6] Si se necesita agregar varios elementos a la misma lista, el m\u00e9todo extend() ser\u00e1 \u00fatil. Simplemente necesita pasar la lista de elementos para agregar al m\u00e9todo extend , como se muestra a continuaci\u00f3n: >>> new_list.extend([7, 8, 9]) >>> new_list [1, 2, 3, 4, 5, 6, 7, 8, 9] Como se puede ver, crear una lista y agregarla con otros elementos es muy sencillo. Se puede realizar esta tarea sin tener que hacer varias llamadas al m\u00e9todo .append() . Del mismo modo, se puede usar un bucle for para agregar varios elementos a una lista. Por ejemplo, tendremos que escribir el siguiente c\u00f3digo para crear una lista de cuadrados para los enteros 1-20. list_a = [] for i in range(1, 20): list_a.append(i**2) \u00bfQu\u00e9 es una lista por comprensi\u00f3n de Python? En palabras m\u00e1s simples, la lista por comprensi\u00f3n es el proceso de crear una nueva lista a partir de otra existente. O bien, se puede decir que es la forma \u00fanica de Python de agregar un bucle for a una lista. Pero, ya es bastante simple declarar una lista y agregar lo que desee. \u00bfNo es as\u00ed? Entonces, \u00bfpor qu\u00e9 molestarse en \"comprender\" nuestras listas? Las listas por comprensi\u00f3n, de hecho, ofrece muchos beneficios sobre las listas tradicionales. Para empezar, el c\u00f3digo se extiende sobre una sola l\u00ednea, lo que hace que sea a\u00fan m\u00e1s f\u00e1cil declarar y leer. Tambi\u00e9n es menos engorroso comprender listas que usar bucles for para declarar una nueva. Finalmente, tambi\u00e9n es una forma conveniente, m\u00e1s r\u00e1pida e intuitiva de generar una nueva lista poblada. Volviendo a los cuadrados de los enteros 1-20, podemos obtener el mismo resultado utilizando el m\u00e9todo las listas por comprensi\u00f3n. As\u00ed es como se ver\u00e1 nuestro c\u00f3digo ahora: list_b = [i**2 for i in range(1, 20)] Obs\u00e9rvese c\u00f3mo la l\u00f3gica para generar los elementos de la lista est\u00e1n entre par\u00e9ntesis. Cubriremos m\u00e1s el asunto de la sintaxis en la siguiente secci\u00f3n. Sintaxis para las listas por comprensi\u00f3n Antes de seguir, es imprescindible explicar la sintaxis de las listas por comprensi\u00f3n. Aqu\u00ed est\u00e1 la sintaxis b\u00e1sica de las listas por comprensi\u00f3n que contiene una condici\u00f3n: [<expresi\u00f3n> for <item> in <lista> if <condici\u00f3n>] Puede parecer ir un poco hacia atr\u00e1s con la expresi\u00f3n antes del bucle, pero as\u00ed es como se hace. El orden es as\u00ed, presumiblemente, porque ser\u00eda dif\u00edcil poner la expresi\u00f3n despu\u00e9s del condicional sin alg\u00fan tipo de punto y coma, que Python no tiene . Como ya se habr\u00e1 adivinado, <expresi\u00f3n> es en realidad el resultado que obtenemos cuando ejecutamos el resto del c\u00f3digo en la lista por comprensi\u00f3n. El c\u00f3digo en s\u00ed es solo un ciclo iterativo sobre una colecci\u00f3n de datos. En nuestro ejemplo, estamos usando la expresi\u00f3n, o la salida, para generar la lista de cuadrados. T\u00e9ngase en cuenta que el condicional es opcional, por lo que, como en nuestro ejemplo anterior, no es necesario incluirlo. Tambi\u00e9n vale la pena mencionar que tenemos una lista que debe ser recorrida -el elemento o elementos que se iterar\u00e1n- y, por supuesto, una declaraci\u00f3n condicional tanto en la lista por comprensi\u00f3n como en los bucles tradicionales. Por lo tanto, cada m\u00e9todo tiene las mismas construcciones generales, pero la diferencia es c\u00f3mo se formatean y organizan. Veamos otro ejemplo m\u00e1s complejo para comprender mejor el concepto detr\u00e1s de las listas por comprensi\u00f3n list_a = [1, 3, 6, 9, 12, 15] list_b = [] for number in list_a: if number % 4 == 0: list_b.append(number) print(list_b) En realidad, estamos recorriendo list_a en el ejemplo anterior. Despu\u00e9s, a\u00f1adimos a list_b un elemento si su valor es divisible por 4, que se verifica utilizando el operador de m\u00f3dulo ( % ). En este ejemplo, se ver\u00eda lo siguiente impreso en la consola: [12] Esto se debe a que 12 es el \u00fanico n\u00famero en esa matriz que es divisible por 4. Una vez m\u00e1s, podemos usar las listas por comprensi\u00f3na para reducir el n\u00famero total de l\u00edneas de c\u00f3digo que tenemos que escribir para lograr el mismo objetivo. Como se mencion\u00f3 anteriormente, el bucle for en la declaraci\u00f3n anterior est\u00e1 iterando sobre la lista llamada list_a . Luego ejecuta la declaraci\u00f3n condicional que verifica si el valor actual es divisible por 4. Finalmente, ejecuta el m\u00e9todo .append() cuando determina que el valor es realmente divisible por 4. Ahora, si desea escribir el c\u00f3digo de arriba con la comprelista por comprensi\u00f3ner\u00eda as\u00ed: list_a = [1, 3, 6, 9, 12, 15] list_b = [number for number in list_a if not(number % 4)] print(list_b) Como se puede ver, hemos reducido el bucle for , que abarca m\u00e1s de tres l\u00edneas, a solo una l\u00ednea. Esa es en realidad la verdadera belleza de las listas por comprensi\u00f3n Cu\u00e1ndo usar las comprensiones de listas Se puede utilizar las listas por comprensi\u00f3n en aquellos casos en los que se necesita generar una lista a partir de un iterable. Sin embargo, el mejor momento para usar este m\u00e9todo es cuando se necesita agregar o extraer elementos a una lista de manera consistente de acuerdo con un patr\u00f3n establecido. Los desarrolladores de Python los usan principalmente para extraer datos de una gran colecci\u00f3n de elementos. Supongamos que se tiene una lista de miles de estudiantes actuales y anteriores con sus nombres, el nombre del padre y sus direcciones. Los datos de cada uno de los estudiantes se almacenan en un diccionario respectivamente. Pero, \u00bfqu\u00e9 pasa si solo se quiere imprimir sus nombres? students = [ { \"name\" : \"Jacob Martin\", \"father name\" : \"Ros Martin\", \"Address\" : \"123 Hill Street\", }, { \"name\" : \"Angela Stevens\", \"father name\" : \"Robert Stevens\", \"Address\" : \"3 Upper Street London\", }, { \"name\" : \"Ricky Smart\", \"father name\" : \"William Smart\", \"Address\" : \"Unknown\", } ] Tenemos la opci\u00f3n de iterar sobre la lista usando el bucle for tradicional: names_list = [] for student in students: names_list.append(student['name']) print(names_list) Aunque en este ejemplo son solo dos l\u00edneas de c\u00f3digo para el bucle for , ni siquiera necesitamos escribir tantas l\u00edneas. Podemos lograr la misma tarea escribiendo solo una l\u00ednea de c\u00f3digo a trav\u00e9s del m\u00e9todo las listas por comprensi\u00f3n: names_list = [student['name'] for student in students] print(names_list) ['Jacob Martin', 'Angela Stevens', 'Ricky Smart'] Conclusi\u00f3n Es realmente sorprendente c\u00f3mo las listas por comprensi\u00f3n reducen la carga de trabajo. Sin embargo, puede parecer confuso al principio. Es particularmente desconcertante para los principiantes que nunca antes se han aventurado en este territorio, principalmente debido a la sintaxis. Tambi\u00e9n puede resultar dif\u00edcil comprender el concepto si se ha estado programando en otros lenguajes porque las lista por comprensi\u00f3n no existen en ninguno de ellos. La \u00fanica forma de entender las listas por comprensi\u00f3n es practicarlas mucho.","title":"[Listas por comprensi\u00f3n en Python](https://stackabuse.com/list-comprehensions-in-python/)"},{"location":"listas_por_comprension/#listas-por-comprension-en-python","text":"Una lista es uno de los tipos de datos fundamentales de Python. Cada vez que nos encontramos con un nombre de variable seguido de un corchete [] , o un constructor de list , tenemos una lista capaz de contener m\u00faltiples elementos, lo que la convierte en un tipo de datos compuesto. Del mismo modo, tambi\u00e9n es muy f\u00e1cil declarar una nueva lista y luego agregarle uno o m\u00e1s elementos. Creemos una nueva lista poblada, por ejemplo: >>> new_list = [1, 2, 3, 4, 5] >>> new_list [1, 2, 3, 4, 5] O simplemente usemos el m\u00e9todo append() para agregar cualquier cosa a la lista: >>> new_list.append(6) >>> new_list [1, 2, 3, 4, 5, 6] Si se necesita agregar varios elementos a la misma lista, el m\u00e9todo extend() ser\u00e1 \u00fatil. Simplemente necesita pasar la lista de elementos para agregar al m\u00e9todo extend , como se muestra a continuaci\u00f3n: >>> new_list.extend([7, 8, 9]) >>> new_list [1, 2, 3, 4, 5, 6, 7, 8, 9] Como se puede ver, crear una lista y agregarla con otros elementos es muy sencillo. Se puede realizar esta tarea sin tener que hacer varias llamadas al m\u00e9todo .append() . Del mismo modo, se puede usar un bucle for para agregar varios elementos a una lista. Por ejemplo, tendremos que escribir el siguiente c\u00f3digo para crear una lista de cuadrados para los enteros 1-20. list_a = [] for i in range(1, 20): list_a.append(i**2)","title":"Listas por comprensi\u00f3n en Python"},{"location":"listas_por_comprension/#que-es-una-lista-por-comprension-de-python","text":"En palabras m\u00e1s simples, la lista por comprensi\u00f3n es el proceso de crear una nueva lista a partir de otra existente. O bien, se puede decir que es la forma \u00fanica de Python de agregar un bucle for a una lista. Pero, ya es bastante simple declarar una lista y agregar lo que desee. \u00bfNo es as\u00ed? Entonces, \u00bfpor qu\u00e9 molestarse en \"comprender\" nuestras listas? Las listas por comprensi\u00f3n, de hecho, ofrece muchos beneficios sobre las listas tradicionales. Para empezar, el c\u00f3digo se extiende sobre una sola l\u00ednea, lo que hace que sea a\u00fan m\u00e1s f\u00e1cil declarar y leer. Tambi\u00e9n es menos engorroso comprender listas que usar bucles for para declarar una nueva. Finalmente, tambi\u00e9n es una forma conveniente, m\u00e1s r\u00e1pida e intuitiva de generar una nueva lista poblada. Volviendo a los cuadrados de los enteros 1-20, podemos obtener el mismo resultado utilizando el m\u00e9todo las listas por comprensi\u00f3n. As\u00ed es como se ver\u00e1 nuestro c\u00f3digo ahora: list_b = [i**2 for i in range(1, 20)] Obs\u00e9rvese c\u00f3mo la l\u00f3gica para generar los elementos de la lista est\u00e1n entre par\u00e9ntesis. Cubriremos m\u00e1s el asunto de la sintaxis en la siguiente secci\u00f3n.","title":"\u00bfQu\u00e9 es una lista por comprensi\u00f3n de Python?"},{"location":"listas_por_comprension/#sintaxis-para-las-listas-por-comprension","text":"Antes de seguir, es imprescindible explicar la sintaxis de las listas por comprensi\u00f3n. Aqu\u00ed est\u00e1 la sintaxis b\u00e1sica de las listas por comprensi\u00f3n que contiene una condici\u00f3n: [<expresi\u00f3n> for <item> in <lista> if <condici\u00f3n>] Puede parecer ir un poco hacia atr\u00e1s con la expresi\u00f3n antes del bucle, pero as\u00ed es como se hace. El orden es as\u00ed, presumiblemente, porque ser\u00eda dif\u00edcil poner la expresi\u00f3n despu\u00e9s del condicional sin alg\u00fan tipo de punto y coma, que Python no tiene . Como ya se habr\u00e1 adivinado, <expresi\u00f3n> es en realidad el resultado que obtenemos cuando ejecutamos el resto del c\u00f3digo en la lista por comprensi\u00f3n. El c\u00f3digo en s\u00ed es solo un ciclo iterativo sobre una colecci\u00f3n de datos. En nuestro ejemplo, estamos usando la expresi\u00f3n, o la salida, para generar la lista de cuadrados. T\u00e9ngase en cuenta que el condicional es opcional, por lo que, como en nuestro ejemplo anterior, no es necesario incluirlo. Tambi\u00e9n vale la pena mencionar que tenemos una lista que debe ser recorrida -el elemento o elementos que se iterar\u00e1n- y, por supuesto, una declaraci\u00f3n condicional tanto en la lista por comprensi\u00f3n como en los bucles tradicionales. Por lo tanto, cada m\u00e9todo tiene las mismas construcciones generales, pero la diferencia es c\u00f3mo se formatean y organizan. Veamos otro ejemplo m\u00e1s complejo para comprender mejor el concepto detr\u00e1s de las listas por comprensi\u00f3n list_a = [1, 3, 6, 9, 12, 15] list_b = [] for number in list_a: if number % 4 == 0: list_b.append(number) print(list_b) En realidad, estamos recorriendo list_a en el ejemplo anterior. Despu\u00e9s, a\u00f1adimos a list_b un elemento si su valor es divisible por 4, que se verifica utilizando el operador de m\u00f3dulo ( % ). En este ejemplo, se ver\u00eda lo siguiente impreso en la consola: [12] Esto se debe a que 12 es el \u00fanico n\u00famero en esa matriz que es divisible por 4. Una vez m\u00e1s, podemos usar las listas por comprensi\u00f3na para reducir el n\u00famero total de l\u00edneas de c\u00f3digo que tenemos que escribir para lograr el mismo objetivo. Como se mencion\u00f3 anteriormente, el bucle for en la declaraci\u00f3n anterior est\u00e1 iterando sobre la lista llamada list_a . Luego ejecuta la declaraci\u00f3n condicional que verifica si el valor actual es divisible por 4. Finalmente, ejecuta el m\u00e9todo .append() cuando determina que el valor es realmente divisible por 4. Ahora, si desea escribir el c\u00f3digo de arriba con la comprelista por comprensi\u00f3ner\u00eda as\u00ed: list_a = [1, 3, 6, 9, 12, 15] list_b = [number for number in list_a if not(number % 4)] print(list_b) Como se puede ver, hemos reducido el bucle for , que abarca m\u00e1s de tres l\u00edneas, a solo una l\u00ednea. Esa es en realidad la verdadera belleza de las listas por comprensi\u00f3n","title":"Sintaxis para las listas por comprensi\u00f3n"},{"location":"listas_por_comprension/#cuando-usar-las-comprensiones-de-listas","text":"Se puede utilizar las listas por comprensi\u00f3n en aquellos casos en los que se necesita generar una lista a partir de un iterable. Sin embargo, el mejor momento para usar este m\u00e9todo es cuando se necesita agregar o extraer elementos a una lista de manera consistente de acuerdo con un patr\u00f3n establecido. Los desarrolladores de Python los usan principalmente para extraer datos de una gran colecci\u00f3n de elementos. Supongamos que se tiene una lista de miles de estudiantes actuales y anteriores con sus nombres, el nombre del padre y sus direcciones. Los datos de cada uno de los estudiantes se almacenan en un diccionario respectivamente. Pero, \u00bfqu\u00e9 pasa si solo se quiere imprimir sus nombres? students = [ { \"name\" : \"Jacob Martin\", \"father name\" : \"Ros Martin\", \"Address\" : \"123 Hill Street\", }, { \"name\" : \"Angela Stevens\", \"father name\" : \"Robert Stevens\", \"Address\" : \"3 Upper Street London\", }, { \"name\" : \"Ricky Smart\", \"father name\" : \"William Smart\", \"Address\" : \"Unknown\", } ] Tenemos la opci\u00f3n de iterar sobre la lista usando el bucle for tradicional: names_list = [] for student in students: names_list.append(student['name']) print(names_list) Aunque en este ejemplo son solo dos l\u00edneas de c\u00f3digo para el bucle for , ni siquiera necesitamos escribir tantas l\u00edneas. Podemos lograr la misma tarea escribiendo solo una l\u00ednea de c\u00f3digo a trav\u00e9s del m\u00e9todo las listas por comprensi\u00f3n: names_list = [student['name'] for student in students] print(names_list) ['Jacob Martin', 'Angela Stevens', 'Ricky Smart']","title":"Cu\u00e1ndo usar las comprensiones de listas"},{"location":"listas_por_comprension/#conclusion","text":"Es realmente sorprendente c\u00f3mo las listas por comprensi\u00f3n reducen la carga de trabajo. Sin embargo, puede parecer confuso al principio. Es particularmente desconcertante para los principiantes que nunca antes se han aventurado en este territorio, principalmente debido a la sintaxis. Tambi\u00e9n puede resultar dif\u00edcil comprender el concepto si se ha estado programando en otros lenguajes porque las lista por comprensi\u00f3n no existen en ninguno de ellos. La \u00fanica forma de entender las listas por comprensi\u00f3n es practicarlas mucho.","title":"Conclusi\u00f3n"},{"location":"parametros_por_referencia/","text":"Par\u00e1metros por referencia Si sol\u00edas (o sueles) utilizar otro lenguaje de programaci\u00f3n, de seguro en alg\u00fan momento te has preguntado por los par\u00e1metros por referencia. En otros lenguajes de programaci\u00f3n existe el paso de par\u00e1metros por valor y por referencia. En los pasos por valor, una funci\u00f3n no puede modificar el valor de las variables que recibe por fuera de su ejecuci\u00f3n: un intento por hacerlo simplemente altera las copias locales de dichas variables. Por el contrario, al pasar por referencia, una funci\u00f3n obtiene acceso directo a las variables originales, permitiendo as\u00ed su edici\u00f3n. Ejemplos de este \u00faltimo comportamiento en Visual Basic y C, respectivamente: Private Sub CambiarCantidad(ByRef cantidad As Integer) cantidad = 5 End Sub Dim cantidad As Integer cantidad = 1 Call CambiarCantidad(cantidad) print cantidad ' Imprime 5 void CambiarCantidad(int *cantidad) { *cantidad = 5; } int cantidad = 1; CambiarCantidad(&cantidad); printf(\"%d\", cantidad); /* Imprime 5 */ En ambos casos (aunque en Visual Basic no pueda observarse, ya que la m\u00e1quina virtual se encarga de esto) se trata de pasar un puntero en referencia a la variable que se desea editar. En Python, en cambio, no se concibe la dial\u00e9ctica paso por valor/referencia, porque el lenguaje no trabaja con el concepto de variables sino objetos y referencias. Al realizar la asignaci\u00f3n a = 1 no se dice que \u00ab a contiene el valor 1\u2033 sino que \u00ab a referencia a 1\u2033. As\u00ed, en comparaci\u00f3n con otros lenguajes, podr\u00eda decirse que en Python los par\u00e1metros siempre se pasan por referencia. Ahora bien podr\u00edamos preguntar, \u00bfpor qu\u00e9 el siguiente c\u00f3digo no modifica los valores originales? def f(a, b, c): # No altera los objetos originales. a, b, c = 4, 5, 6 a, b, c = 1, 2, 3 f(a, b, c) print(a, b, c) # Imprime 1, 2, 3 La respuesta es que los n\u00fameros enteros (como tambi\u00e9n los de coma flotante, las cadenas y otros objetos) son inmutables. Es decir, una vez creados, su valor no puede ser modificado. \u00bfC\u00f3mo, no puedo acaso hacer a = 1 y luego a = 2 ?. Claro, pero desde la perspectiva del lenguaje, no est\u00e1s cambiando el valor de a de 1 a 2 sino quitando la referencia a 1 y poni\u00e9ndosela a 2. En t\u00e9rminos m\u00e1s simples, no \u00abcambias\u00bb el valor de un objeto sino que le asignas una nueva referencia. En el c\u00f3digo anterior, al ejecutar a, b, c = 4, 5, 6 est\u00e1s creando nuevas referencias para los n\u00fameros 4, 5 y 6 dentro de la funci\u00f3n f con los nombres a , b y c . Sin embargo otros objetos, como las listas o diccionarios, son mutables. Veamos un ejemplo: def f(a): a[0] = \"CPython\" a[1] = \"PyPy\" a.append(\"Stackless\") items = [\"Perro\", \"Gato\"] f(items) print(items) # Imprime ['CPython', 'PyPy', 'Stackless'] Entonces ahora nos entendemos: basta con saber si un objeto es mutable o inmutable para determinar si es posible editarlo dentro de una funci\u00f3n y que tenga efecto fuera de \u00e9sta. Es correcto, pero aqu\u00ed hay una mejor noticia: \u00a1no hay necesidad alguna para que lo hagas! Te dir\u00e9 por qu\u00e9: el paso por referencia es la manera en que los lenguajes que trabajan con variables proveen al programador para retornar m\u00e1s de un valor en una misma funci\u00f3n. En cambio, Python permite devolver varios objetos utilizando tuplas o listas . Por ejemplo: a = 1 b = 2 c = 3 def f(): return 4, 5, 6 a, b, c = f() # Ahora \"a\" es 4, \"b\" es 5 y \"c\" es 6. En Python no es una buena pr\u00e1ctica modificar los objetos pasados como par\u00e1metros desde una funci\u00f3n y puede llevar a resultados inesperados. No hay raz\u00f3n para hacerlo, basta con retornar m\u00faltiples objetos. Otro m\u00e9todo de obtener el mismo resultado (cambiar el valor de un objeto y mantener los cambios fuera de la funci\u00f3n) es utilizando variables globales, poco recomendado (yo dir\u00eda que no recomendado) e inseguro. a, b, c = 1, 2, 3 # Cambio el nombre de los argumentos para evitar errores de nombramiento. def f(d, e, f): global a, b, c a, b, c = 4, 5, 6 f(a, b, c) Para funciones de C que requieran pasar par\u00e1metros por referencia (un puntero), pueden utilizarse las funciones ctypes.byref y ctypes.pointer que, en estos casos, resultan similares, con la diferencia que la primera se ejecuta m\u00e1s r\u00e1pidamente. Ambas toman como par\u00e1metro un objeto que represente un tipo de C (por ejemplo, c_bool , c_char , etc.). from ctypes import byref, c_int, pointer a = c_int(50) a_ref = byref(a) a_ptr = pointer(b) \u00a1Espero que el art\u00edculo te haya resultado esclarecedor y ahora puedas hacer uso de las buenas pr\u00e1cticas del lenguaje! Fuente: https://recursospython.com/guias-y-manuales/parametros-por-referencia/","title":"Par\u00e1metros por referencia"},{"location":"parametros_por_referencia/#parametros-por-referencia","text":"Si sol\u00edas (o sueles) utilizar otro lenguaje de programaci\u00f3n, de seguro en alg\u00fan momento te has preguntado por los par\u00e1metros por referencia. En otros lenguajes de programaci\u00f3n existe el paso de par\u00e1metros por valor y por referencia. En los pasos por valor, una funci\u00f3n no puede modificar el valor de las variables que recibe por fuera de su ejecuci\u00f3n: un intento por hacerlo simplemente altera las copias locales de dichas variables. Por el contrario, al pasar por referencia, una funci\u00f3n obtiene acceso directo a las variables originales, permitiendo as\u00ed su edici\u00f3n. Ejemplos de este \u00faltimo comportamiento en Visual Basic y C, respectivamente: Private Sub CambiarCantidad(ByRef cantidad As Integer) cantidad = 5 End Sub Dim cantidad As Integer cantidad = 1 Call CambiarCantidad(cantidad) print cantidad ' Imprime 5 void CambiarCantidad(int *cantidad) { *cantidad = 5; } int cantidad = 1; CambiarCantidad(&cantidad); printf(\"%d\", cantidad); /* Imprime 5 */ En ambos casos (aunque en Visual Basic no pueda observarse, ya que la m\u00e1quina virtual se encarga de esto) se trata de pasar un puntero en referencia a la variable que se desea editar. En Python, en cambio, no se concibe la dial\u00e9ctica paso por valor/referencia, porque el lenguaje no trabaja con el concepto de variables sino objetos y referencias. Al realizar la asignaci\u00f3n a = 1 no se dice que \u00ab a contiene el valor 1\u2033 sino que \u00ab a referencia a 1\u2033. As\u00ed, en comparaci\u00f3n con otros lenguajes, podr\u00eda decirse que en Python los par\u00e1metros siempre se pasan por referencia. Ahora bien podr\u00edamos preguntar, \u00bfpor qu\u00e9 el siguiente c\u00f3digo no modifica los valores originales? def f(a, b, c): # No altera los objetos originales. a, b, c = 4, 5, 6 a, b, c = 1, 2, 3 f(a, b, c) print(a, b, c) # Imprime 1, 2, 3 La respuesta es que los n\u00fameros enteros (como tambi\u00e9n los de coma flotante, las cadenas y otros objetos) son inmutables. Es decir, una vez creados, su valor no puede ser modificado. \u00bfC\u00f3mo, no puedo acaso hacer a = 1 y luego a = 2 ?. Claro, pero desde la perspectiva del lenguaje, no est\u00e1s cambiando el valor de a de 1 a 2 sino quitando la referencia a 1 y poni\u00e9ndosela a 2. En t\u00e9rminos m\u00e1s simples, no \u00abcambias\u00bb el valor de un objeto sino que le asignas una nueva referencia. En el c\u00f3digo anterior, al ejecutar a, b, c = 4, 5, 6 est\u00e1s creando nuevas referencias para los n\u00fameros 4, 5 y 6 dentro de la funci\u00f3n f con los nombres a , b y c . Sin embargo otros objetos, como las listas o diccionarios, son mutables. Veamos un ejemplo: def f(a): a[0] = \"CPython\" a[1] = \"PyPy\" a.append(\"Stackless\") items = [\"Perro\", \"Gato\"] f(items) print(items) # Imprime ['CPython', 'PyPy', 'Stackless'] Entonces ahora nos entendemos: basta con saber si un objeto es mutable o inmutable para determinar si es posible editarlo dentro de una funci\u00f3n y que tenga efecto fuera de \u00e9sta. Es correcto, pero aqu\u00ed hay una mejor noticia: \u00a1no hay necesidad alguna para que lo hagas! Te dir\u00e9 por qu\u00e9: el paso por referencia es la manera en que los lenguajes que trabajan con variables proveen al programador para retornar m\u00e1s de un valor en una misma funci\u00f3n. En cambio, Python permite devolver varios objetos utilizando tuplas o listas . Por ejemplo: a = 1 b = 2 c = 3 def f(): return 4, 5, 6 a, b, c = f() # Ahora \"a\" es 4, \"b\" es 5 y \"c\" es 6. En Python no es una buena pr\u00e1ctica modificar los objetos pasados como par\u00e1metros desde una funci\u00f3n y puede llevar a resultados inesperados. No hay raz\u00f3n para hacerlo, basta con retornar m\u00faltiples objetos. Otro m\u00e9todo de obtener el mismo resultado (cambiar el valor de un objeto y mantener los cambios fuera de la funci\u00f3n) es utilizando variables globales, poco recomendado (yo dir\u00eda que no recomendado) e inseguro. a, b, c = 1, 2, 3 # Cambio el nombre de los argumentos para evitar errores de nombramiento. def f(d, e, f): global a, b, c a, b, c = 4, 5, 6 f(a, b, c) Para funciones de C que requieran pasar par\u00e1metros por referencia (un puntero), pueden utilizarse las funciones ctypes.byref y ctypes.pointer que, en estos casos, resultan similares, con la diferencia que la primera se ejecuta m\u00e1s r\u00e1pidamente. Ambas toman como par\u00e1metro un objeto que represente un tipo de C (por ejemplo, c_bool , c_char , etc.). from ctypes import byref, c_int, pointer a = c_int(50) a_ref = byref(a) a_ptr = pointer(b) \u00a1Espero que el art\u00edculo te haya resultado esclarecedor y ahora puedas hacer uso de las buenas pr\u00e1cticas del lenguaje! Fuente: https://recursospython.com/guias-y-manuales/parametros-por-referencia/","title":"Par\u00e1metros por referencia"},{"location":"que_es_el_PEP8_y_por_qu\u00e9_deber\u00eda_implementarlo/","text":"\u00bfQu\u00e9 es el PEP 8 y por qu\u00e9 deber\u00eda implementarlo? En el mundo del desarrollo es muy com\u00fan hacer las cosas de distintas formas. Se puede organizar el c\u00f3digo como se quiera, incluso escribirlo de forma abstracta. En muchos casos, se logra que nuestra profesi\u00f3n se considere muchas veces como un arte y no como una ingenier\u00eda. La ausencia de una base s\u00f3lida de c\u00f3mo y por qu\u00e9 se hacen las cosas de una manera especifica conduce a un software mal redactado y mal organizado que nadie quiere leer. La diferencia mas palpable de python con respecto a otros lenguajes es que la comunidad tiene como lema la legibilidad del c\u00f3digo. El ZEN de python establece que \"Debe haber una y preferiblemente solo una forma obvia de hacer las cosas\" . Siguiendo este principio, se defini\u00f3 una gu\u00eda de estilo \u00fanica descrita \u00edntegramente en el Python Enhancement Proposal n\u00famero 8, abreviado como PEP 8, donde se indica como deber\u00eda ser escrito nuestro c\u00f3digo python. Muchos sabemos que a los desarrolladores de software no les suele gustar la imposici\u00f3n obligatoria de cierta forma de hacer su trabajo. Con el devenir del tiempo hemos apreciamos que toda la comunidad use una gu\u00eda de estilo \u00fanica que finalmente nos facilita el trabajo y mejora mucho nuestra productividad. Puntos mas importantes de PEP8 B\u00e1sicos Siempre preferir espacios en lugar de tabuladores. Usar 4 espacios en la indentaci\u00f3n. Las l\u00edneas deben tener menos de 80 caracteres. Las l\u00edneas que pasen de esta longitud deben dividirse en dos, y la linea resultante de la divisi\u00f3n debe estar indentada. Las funciones y las clases deben estar separadas por dos lineas en blanco. No colocar espacios alrededor de los \u00edndices de las listas, llamadas a funciones o argumentos. Nombres Las funciones deben estar declaradas en min\u00fasculas y las palabras separadas por guiones bajos def funcion_cool() Los m\u00e9todos privados de una clase deben comenzar con doble gui\u00f3n bajo def __private_method() . Los m\u00e9todos protegidos de una clase deben comenzar con guion bajo def _protected_method() . Las clases y excepciones deben ser capitalizadas por palabra class SuperClass . Constantes del module deben estar en may\u00fasculas separadas por guiones bajos NUMERO_MAXIMO = 10 . Los m\u00e9todos de instancia de una clase deben usar el par\u00e1metro self como primer par\u00e1metro. Los m\u00e9todos de clase deben usar cls como primer par\u00e1metro, para referirse a la misma clase. Expresiones Usar negaci\u00f3n en l\u00ednea ( if a is not b ) en lugar de negar una expresion positiva (if not a is b) . No validar valores vac\u00edos usando len if (len(lista) == 0) , usar if not lista . Siempre colocar las imports al inicio del archivo. Siempre importar funciones y clases usando from my_module import MyClass en lugar de importar el m\u00f3dulo completo import my_module Si aun se debe usar imports relativos, usar la sintaxis from . import my_module Las importaciones siempre deben estar en el orden: M\u00f3dulos de la librer\u00eda standar. M\u00f3dulos externos. M\u00f3dulos del proyecto. Y cada secci\u00f3n debe estar en orden alfab\u00e9tico. Siguiendo estos sencillos puntos, tu equipo de desarrollo y toda la comunidad python estar\u00e1 muy contenta de tenerte.","title":"[\u00bfQu\u00e9 es el PEP 8 y por qu\u00e9 deber\u00eda implementarlo?](https://dev.to/viktorvillalobos/que-es-el-pep-8-y-porque-deberia-implementarlo-54bh)"},{"location":"que_es_el_PEP8_y_por_qu\u00e9_deber\u00eda_implementarlo/#que-es-el-pep-8-y-por-que-deberia-implementarlo","text":"En el mundo del desarrollo es muy com\u00fan hacer las cosas de distintas formas. Se puede organizar el c\u00f3digo como se quiera, incluso escribirlo de forma abstracta. En muchos casos, se logra que nuestra profesi\u00f3n se considere muchas veces como un arte y no como una ingenier\u00eda. La ausencia de una base s\u00f3lida de c\u00f3mo y por qu\u00e9 se hacen las cosas de una manera especifica conduce a un software mal redactado y mal organizado que nadie quiere leer. La diferencia mas palpable de python con respecto a otros lenguajes es que la comunidad tiene como lema la legibilidad del c\u00f3digo. El ZEN de python establece que \"Debe haber una y preferiblemente solo una forma obvia de hacer las cosas\" . Siguiendo este principio, se defini\u00f3 una gu\u00eda de estilo \u00fanica descrita \u00edntegramente en el Python Enhancement Proposal n\u00famero 8, abreviado como PEP 8, donde se indica como deber\u00eda ser escrito nuestro c\u00f3digo python. Muchos sabemos que a los desarrolladores de software no les suele gustar la imposici\u00f3n obligatoria de cierta forma de hacer su trabajo. Con el devenir del tiempo hemos apreciamos que toda la comunidad use una gu\u00eda de estilo \u00fanica que finalmente nos facilita el trabajo y mejora mucho nuestra productividad.","title":"\u00bfQu\u00e9 es el PEP 8 y por qu\u00e9 deber\u00eda implementarlo?"},{"location":"que_es_el_PEP8_y_por_qu\u00e9_deber\u00eda_implementarlo/#puntos-mas-importantes-de-pep8","text":"","title":"Puntos mas importantes de PEP8"},{"location":"que_es_el_PEP8_y_por_qu\u00e9_deber\u00eda_implementarlo/#basicos","text":"Siempre preferir espacios en lugar de tabuladores. Usar 4 espacios en la indentaci\u00f3n. Las l\u00edneas deben tener menos de 80 caracteres. Las l\u00edneas que pasen de esta longitud deben dividirse en dos, y la linea resultante de la divisi\u00f3n debe estar indentada. Las funciones y las clases deben estar separadas por dos lineas en blanco. No colocar espacios alrededor de los \u00edndices de las listas, llamadas a funciones o argumentos.","title":"B\u00e1sicos"},{"location":"que_es_el_PEP8_y_por_qu\u00e9_deber\u00eda_implementarlo/#nombres","text":"Las funciones deben estar declaradas en min\u00fasculas y las palabras separadas por guiones bajos def funcion_cool() Los m\u00e9todos privados de una clase deben comenzar con doble gui\u00f3n bajo def __private_method() . Los m\u00e9todos protegidos de una clase deben comenzar con guion bajo def _protected_method() . Las clases y excepciones deben ser capitalizadas por palabra class SuperClass . Constantes del module deben estar en may\u00fasculas separadas por guiones bajos NUMERO_MAXIMO = 10 . Los m\u00e9todos de instancia de una clase deben usar el par\u00e1metro self como primer par\u00e1metro. Los m\u00e9todos de clase deben usar cls como primer par\u00e1metro, para referirse a la misma clase.","title":"Nombres"},{"location":"que_es_el_PEP8_y_por_qu\u00e9_deber\u00eda_implementarlo/#expresiones","text":"Usar negaci\u00f3n en l\u00ednea ( if a is not b ) en lugar de negar una expresion positiva (if not a is b) . No validar valores vac\u00edos usando len if (len(lista) == 0) , usar if not lista . Siempre colocar las imports al inicio del archivo. Siempre importar funciones y clases usando from my_module import MyClass en lugar de importar el m\u00f3dulo completo import my_module Si aun se debe usar imports relativos, usar la sintaxis from . import my_module Las importaciones siempre deben estar en el orden: M\u00f3dulos de la librer\u00eda standar. M\u00f3dulos externos. M\u00f3dulos del proyecto. Y cada secci\u00f3n debe estar en orden alfab\u00e9tico. Siguiendo estos sencillos puntos, tu equipo de desarrollo y toda la comunidad python estar\u00e1 muy contenta de tenerte.","title":"Expresiones"},{"location":"switch/","text":"Sentencia Switch Aunque los lenguajes populares como Java y PHP tienen una declaraci\u00f3n switch ya incorporada, puede que sorprenda saber que Python no tiene uno. Como tal, se puede estar tentado a utilizar una serie de bloques if-else-if , usando una condici\u00f3n if para cada alternativa. Sin embargo, debido a la tabla de salto, una instrucci\u00f3n switch es mucho m\u00e1s r\u00e1pido que una escalera if-else-if . En lugar de evaluar cada condici\u00f3n en forma secuencial, solo tiene que buscar la variable/expresi\u00f3n una vez y saltar directamente a la rama apropiada de c\u00f3digo para ejecutarla. \u00bfComo se implementa la sentencia switch en Python? La forma de Python de implementar la instrucci\u00f3n switch es utilizar las asignaciones de diccionarios, tambi\u00e9n conocidas como matrices asociativas, que proporcionan asignaciones simples de clave-valor de uno a uno. Aqu\u00ed esta la implementaci\u00f3n de Python de la declaraci\u00f3n anterior. En el siguiente ejemplo, creamos un diccionario llamado switcher para almacenar todos los casos del tipo switch . def switch_demo(argument): switcher = { 1: \"January\", 2: \"February\", 3: \"March\", 4: \"April\", 5: \"May\", 6: \"June\", 7: \"July\", 8: \"August\", 9: \"September\", 10: \"October\", 11: \"November\", 12: \"December\" } print switcher.get(argument, \"Invalid month\") En el ejemplo, al pasar un argumento en la funci\u00f3n switch_demo , se busca el valor en el diccionario. Si se encuentra una coincidencia, se imprime el valor asociado, de lo contrario se imprime una cadena predeterminada (\u00abInvalid Month\u00bb). La cadena predeterminada ayuda a implementar la opci\u00f3n \u00abdefault\u00bb de la sentencia switch. Asignaci\u00f3n de diccionario para funciones Aqu\u00ed es donde se vuelve m\u00e1s interesante. Los valores de un diccionario de Python pueden ser de cualquier tipo de datos. De modo que no tiene que limitarse a utilizar constantes (enteros, cadenas), tambi\u00e9n puede utilizar nombres de funciones y lambdas como valores. Por ejemplo, tambi\u00e9n puede implementar la instrucci\u00f3n switch anterior creando un diccionario de nombres de funciones como valores. En este caso, switcher es un diccionario de nombres de funciones y no de cadenas. def one(): return \"January\" def two(): return \"February\" def three(): return \"March\" def four(): return \"April\" def five(): return \"May\" def six(): return \"June\" def seven(): return \"July\" def eight(): return \"August\" def nine(): return \"September\" def ten(): return \"October\" def eleven(): return \"November\" def twelve(): return \"December\" def numbers_to_months(argument): switcher = { 1: one, 2: two, 3: three, 4: four, 5: five, 6: six, 7: seven, 8: eight, 9: nine, 10: ten, 11: eleven, 12: twelve } # Get the function from switcher dictionary func = switcher.get(argument, lambda: \"Invalid month\") # Execute the function print func() Aunque las funciones anteriores son bastantes simples y solo devuelven cadenas, puede usar este enfoque para ejecutar bloques elaborados de c\u00f3digo dentro de cada funci\u00f3n. De hecho, si llama m\u00e9todos a objetos, incluso puede usar un m\u00e9todo de env\u00edo para determinar din\u00e1micamente a que funci\u00f3n se debe llamar durante el tiempo de ejecuci\u00f3n. class Switcher(object): def numbers_to_months(self, argument): \"\"\"Dispatch method\"\"\" method_name = 'month_' + str(argument) # Get the method from 'self'. Default to a lambda. method = getattr(self, method_name, lambda: \"Invalid month\") # Call the method as we return it return method() def month_1(self): return \"January\" def month_2(self): return \"February\" def month_3(self): return \"March\" ... Basado en el argumento, la funci\u00f3n getattr() recuperar\u00e1 m\u00e9todos de objetos con el nombre en particular. Input: a=Switcher() Input: a.numbers_to_months(1) Output: January Ventajas de la implementaci\u00f3n switch de Python Dado que puede alterar los diccionarios de Python en tiempo de ejecuci\u00f3n (agregar, eliminar o actualizar pares clave-valor), puede cambiar f\u00e1cilmente la declaraci\u00f3n de conmutaci\u00f3n en tiempo de ejecuci\u00f3n. Aqu\u00ed un ejemplo. def zero(): return \"zero\" def one(): return \"one\" def two(): return \"two\" switcher = { 0: zero, 1: one, 2: two } def numbers_to_strings(argument): # Get the function from switcher dictionary func = switcher.get(argument, \"nothing\") # Execute the function return func() Input: numbers_to_strings(1) Output: One Input: switcher[1]=two #changing the switch case Input: numbers_to_strings(1) Output: Two La sentencia switch es muy \u00fatil, que no s\u00f3lo proporciona un mejor rendimiento que una instrucci\u00f3n if-else, sino que tambi\u00e9n te deja un c\u00f3digo m\u00e1s manejable. Si has tenido l\u00edmites por la falta de la sentencia swith en Python, entonces con suerte, este art\u00edculo te ayudar\u00e1 a implementarlo. https://www.clubdetecnologia.net/blog/2017/python-como-se-implementa-una-sentencia-switch-case/","title":"Switch"},{"location":"switch/#sentencia-switch","text":"Aunque los lenguajes populares como Java y PHP tienen una declaraci\u00f3n switch ya incorporada, puede que sorprenda saber que Python no tiene uno. Como tal, se puede estar tentado a utilizar una serie de bloques if-else-if , usando una condici\u00f3n if para cada alternativa. Sin embargo, debido a la tabla de salto, una instrucci\u00f3n switch es mucho m\u00e1s r\u00e1pido que una escalera if-else-if . En lugar de evaluar cada condici\u00f3n en forma secuencial, solo tiene que buscar la variable/expresi\u00f3n una vez y saltar directamente a la rama apropiada de c\u00f3digo para ejecutarla.","title":"Sentencia Switch"},{"location":"switch/#como-se-implementa-la-sentencia-switch-en-python","text":"La forma de Python de implementar la instrucci\u00f3n switch es utilizar las asignaciones de diccionarios, tambi\u00e9n conocidas como matrices asociativas, que proporcionan asignaciones simples de clave-valor de uno a uno. Aqu\u00ed esta la implementaci\u00f3n de Python de la declaraci\u00f3n anterior. En el siguiente ejemplo, creamos un diccionario llamado switcher para almacenar todos los casos del tipo switch . def switch_demo(argument): switcher = { 1: \"January\", 2: \"February\", 3: \"March\", 4: \"April\", 5: \"May\", 6: \"June\", 7: \"July\", 8: \"August\", 9: \"September\", 10: \"October\", 11: \"November\", 12: \"December\" } print switcher.get(argument, \"Invalid month\") En el ejemplo, al pasar un argumento en la funci\u00f3n switch_demo , se busca el valor en el diccionario. Si se encuentra una coincidencia, se imprime el valor asociado, de lo contrario se imprime una cadena predeterminada (\u00abInvalid Month\u00bb). La cadena predeterminada ayuda a implementar la opci\u00f3n \u00abdefault\u00bb de la sentencia switch.","title":"\u00bfComo se implementa la sentencia switch en Python?"},{"location":"switch/#asignacion-de-diccionario-para-funciones","text":"Aqu\u00ed es donde se vuelve m\u00e1s interesante. Los valores de un diccionario de Python pueden ser de cualquier tipo de datos. De modo que no tiene que limitarse a utilizar constantes (enteros, cadenas), tambi\u00e9n puede utilizar nombres de funciones y lambdas como valores. Por ejemplo, tambi\u00e9n puede implementar la instrucci\u00f3n switch anterior creando un diccionario de nombres de funciones como valores. En este caso, switcher es un diccionario de nombres de funciones y no de cadenas. def one(): return \"January\" def two(): return \"February\" def three(): return \"March\" def four(): return \"April\" def five(): return \"May\" def six(): return \"June\" def seven(): return \"July\" def eight(): return \"August\" def nine(): return \"September\" def ten(): return \"October\" def eleven(): return \"November\" def twelve(): return \"December\" def numbers_to_months(argument): switcher = { 1: one, 2: two, 3: three, 4: four, 5: five, 6: six, 7: seven, 8: eight, 9: nine, 10: ten, 11: eleven, 12: twelve } # Get the function from switcher dictionary func = switcher.get(argument, lambda: \"Invalid month\") # Execute the function print func() Aunque las funciones anteriores son bastantes simples y solo devuelven cadenas, puede usar este enfoque para ejecutar bloques elaborados de c\u00f3digo dentro de cada funci\u00f3n. De hecho, si llama m\u00e9todos a objetos, incluso puede usar un m\u00e9todo de env\u00edo para determinar din\u00e1micamente a que funci\u00f3n se debe llamar durante el tiempo de ejecuci\u00f3n. class Switcher(object): def numbers_to_months(self, argument): \"\"\"Dispatch method\"\"\" method_name = 'month_' + str(argument) # Get the method from 'self'. Default to a lambda. method = getattr(self, method_name, lambda: \"Invalid month\") # Call the method as we return it return method() def month_1(self): return \"January\" def month_2(self): return \"February\" def month_3(self): return \"March\" ... Basado en el argumento, la funci\u00f3n getattr() recuperar\u00e1 m\u00e9todos de objetos con el nombre en particular. Input: a=Switcher() Input: a.numbers_to_months(1) Output: January","title":"Asignaci\u00f3n de diccionario para funciones"},{"location":"switch/#ventajas-de-la-implementacion-switch-de-python","text":"Dado que puede alterar los diccionarios de Python en tiempo de ejecuci\u00f3n (agregar, eliminar o actualizar pares clave-valor), puede cambiar f\u00e1cilmente la declaraci\u00f3n de conmutaci\u00f3n en tiempo de ejecuci\u00f3n. Aqu\u00ed un ejemplo. def zero(): return \"zero\" def one(): return \"one\" def two(): return \"two\" switcher = { 0: zero, 1: one, 2: two } def numbers_to_strings(argument): # Get the function from switcher dictionary func = switcher.get(argument, \"nothing\") # Execute the function return func() Input: numbers_to_strings(1) Output: One Input: switcher[1]=two #changing the switch case Input: numbers_to_strings(1) Output: Two La sentencia switch es muy \u00fatil, que no s\u00f3lo proporciona un mejor rendimiento que una instrucci\u00f3n if-else, sino que tambi\u00e9n te deja un c\u00f3digo m\u00e1s manejable. Si has tenido l\u00edmites por la falta de la sentencia swith en Python, entonces con suerte, este art\u00edculo te ayudar\u00e1 a implementarlo. https://www.clubdetecnologia.net/blog/2017/python-como-se-implementa-una-sentencia-switch-case/","title":"Ventajas de la implementaci\u00f3n switch de Python"}]}